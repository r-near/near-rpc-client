// Auto-generated from OpenRPC schema - DO NOT EDIT
import { z } from "zod";

export const AccessKey = z.object({ "nonce": z.number().int().gte(0).describe("Nonce for this access key, used for tx nonce generation. When access key is created, nonce\nis set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\nSee <https://github.com/near/nearcore/issues/3779> for more details."), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Allowance is a balance limit to use by this access key to pay for function call gas and\ntransaction fees. When this access key is used, both account balance and the allowance is\ndecreased by the same value.\n`None` means unlimited allowance.\nNOTE: To change or increase the allowance, the old access key needs to be deleted and a new\naccess key should be created.").optional(), "method_names": z.array(z.string()).describe("A list of method names that can be used. The access key only allows transactions with the\nfunction call of one of the given method names.\nEmpty list means any method name can be used."), "receiver_id": z.string().describe("The access key only allows transactions with the given receiver's account id.") }).describe("Grants limited permission to make transactions with FunctionCallActions\nThe permission can limit the allowed balance to be spent on the prepaid gas.\nIt also restrict the account ID of the receiver for this function call.\nIt also can restrict the method name for the allowed function calls.") }).strict(), z.literal("FullAccess").describe("Grants full access to the account.\nNOTE: It's used to replace account-level public keys.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Defines permissions for AccessKey").describe("Defines permissions for this access key.") }).describe("Access key provides limited access to an account. Each access key belongs to some account and\nis identified by a unique (within the account) public key. One account may have large number of\naccess keys. Access keys allow to act on behalf of the account by restricting transactions\nthat can be issued.\n`account_id,public_key` is a key in the state")
export type AccessKey = z.infer<typeof AccessKey>


export const AccessKeyCreationConfigView = z.object({ "full_access_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of creating a full access access-key."), "function_call_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of creating an access-key restricted to specific functions."), "function_call_cost_per_byte": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Cost per byte of method_names of creating a restricted access-key.") }).describe("Describes the cost of creating an access key.")
export type AccessKeyCreationConfigView = z.infer<typeof AccessKeyCreationConfigView>


export const AccessKeyInfoView = z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("FullAccess"), z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "method_names": z.array(z.string()), "receiver_id": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the permission scope for an access key. Whether it is a function call or a full access key.") }).describe("Describes access key permission scope and nonce."), "public_key": z.string() }).describe("Describes information about an access key including the public key.")
export type AccessKeyInfoView = z.infer<typeof AccessKeyInfoView>


export const AccessKeyList = z.object({ "keys": z.array(z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("FullAccess"), z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "method_names": z.array(z.string()), "receiver_id": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the permission scope for an access key. Whether it is a function call or a full access key.") }).describe("Describes access key permission scope and nonce."), "public_key": z.string() }).describe("Describes information about an access key including the public key.")) }).describe("Lists access keys")
export type AccessKeyList = z.infer<typeof AccessKeyList>


export const AccessKeyPermission = z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Allowance is a balance limit to use by this access key to pay for function call gas and\ntransaction fees. When this access key is used, both account balance and the allowance is\ndecreased by the same value.\n`None` means unlimited allowance.\nNOTE: To change or increase the allowance, the old access key needs to be deleted and a new\naccess key should be created.").optional(), "method_names": z.array(z.string()).describe("A list of method names that can be used. The access key only allows transactions with the\nfunction call of one of the given method names.\nEmpty list means any method name can be used."), "receiver_id": z.string().describe("The access key only allows transactions with the given receiver's account id.") }).describe("Grants limited permission to make transactions with FunctionCallActions\nThe permission can limit the allowed balance to be spent on the prepaid gas.\nIt also restrict the account ID of the receiver for this function call.\nIt also can restrict the method name for the allowed function calls.") }).strict(), z.literal("FullAccess").describe("Grants full access to the account.\nNOTE: It's used to replace account-level public keys.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Defines permissions for AccessKey")
export type AccessKeyPermission = z.infer<typeof AccessKeyPermission>


export const AccessKeyPermissionView = z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("FullAccess"), z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "method_names": z.array(z.string()), "receiver_id": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the permission scope for an access key. Whether it is a function call or a full access key.")
export type AccessKeyPermissionView = z.infer<typeof AccessKeyPermissionView>


export const AccessKeyView = z.object({ "nonce": z.number().int().gte(0), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("FullAccess"), z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "method_names": z.array(z.string()), "receiver_id": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the permission scope for an access key. Whether it is a function call or a full access key.") }).describe("Describes access key permission scope and nonce.")
export type AccessKeyView = z.infer<typeof AccessKeyView>


export const AccountCreationConfigView = z.object({ "min_allowed_top_level_account_length": z.number().int().gte(0).lte(255).describe("The minimum length of the top-level account ID that is allowed to be created by any account."), "registrar_account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("The account ID of the account registrar. This account ID allowed to create top-level\naccounts of any valid length.") }).describe("The structure describes configuration for creation of new accounts.")
export type AccountCreationConfigView = z.infer<typeof AccountCreationConfigView>


export const AccountDataView = z.object({ "account_key": z.string().describe("Account key of the validator signing this AccountData."), "peer_id": z.string().describe("ID of the node that handles the account key (aka validator key)."), "proxies": z.array(z.object({ "addr": z.string(), "peer_id": z.string() })).describe("Proxy nodes that are directly connected to the validator node\n(this list may include the validator node itself).\nTIER1 nodes should connect to one of the proxies to sent TIER1\nmessages to the validator."), "timestamp": z.string().describe("UTC timestamp of when the AccountData has been signed.") }).describe("AccountData is a piece of global state that a validator\nsigns and broadcasts to the network.\n\nIt is essentially the data that a validator wants to share with the network.\nAll the nodes in the network are collecting the account data\nbroadcasted by the validators.\nSince the number of the validators is bounded and their\nidentity is known (and the maximal size of allowed AccountData is bounded)\nthe global state that is distributed in the form of AccountData is bounded\nas well.\nFind more information in the docs [here](https://github.com/near/nearcore/blob/560f7fc8f4b3106e0d5d46050688610b1f104ac6/chain/client/src/client.rs#L2232)")
export type AccountDataView = z.infer<typeof AccountDataView>


export const AccountId = z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```")
export type AccountId = z.infer<typeof AccountId>


export const AccountIdValidityRulesVersion = z.number().int().gte(0).lte(255)
export type AccountIdValidityRulesVersion = z.infer<typeof AccountIdValidityRulesVersion>


export const AccountInfo = z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "amount": z.string(), "public_key": z.string() }).describe("Account info for validators")
export type AccountInfo = z.infer<typeof AccountInfo>


export const AccountView = z.object({ "amount": z.string(), "code_hash": z.string(), "global_contract_account_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "global_contract_hash": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "locked": z.string(), "storage_paid_at": z.number().int().gte(0).describe("TODO(2271): deprecated.").default(0), "storage_usage": z.number().int().gte(0) }).describe("A view of the account")
export type AccountView = z.infer<typeof AccountView>


export const AccountWithPublicKey = z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }).describe("Account ID with its public key.")
export type AccountWithPublicKey = z.infer<typeof AccountWithPublicKey>


export const ActionCreationConfigView = z.object({ "add_key_cost": z.object({ "full_access_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of creating a full access access-key."), "function_call_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of creating an access-key restricted to specific functions."), "function_call_cost_per_byte": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Cost per byte of method_names of creating a restricted access-key.") }).describe("Describes the cost of creating an access key.").describe("Base cost of adding a key."), "create_account_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of creating an account."), "delegate_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost for processing a delegate action.\n\nThis is on top of the costs for the actions inside the delegate action."), "delete_account_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of deleting an account."), "delete_key_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of deleting a key."), "deploy_contract_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of deploying a contract."), "deploy_contract_cost_per_byte": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Cost per byte of deploying a contract."), "function_call_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of calling a function."), "function_call_cost_per_byte": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Cost per byte of method name and arguments of calling a function."), "stake_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of staking."), "transfer_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of making a transfer.") }).describe("Describes the cost of creating a specific action, `Action`. Includes all variants.")
export type ActionCreationConfigView = z.infer<typeof ActionCreationConfigView>


export const ActionError = z.object({ "index": z.union([z.number().int().gte(0).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`"), z.null().describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`")]).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`").optional(), "kind": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccountAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage"), z.object({ "AccountDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when TX receiver_id doesn't exist (but action is not Action::CreateAccount)"), z.object({ "CreateAccountOnlyByRegistrar": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "registrar_account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A top-level account ID can only be created by registrar."), z.object({ "CreateAccountNotAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A newly created account must be under a namespace of the creator account"), z.object({ "ActorNoPermission": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "actor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\nor the first TX action is a `CreateAccount` action"), z.object({ "DeleteKeyDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("Account tries to remove an access key that doesn't exist"), z.object({ "AddKeyAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The public key is already used for an existing access key"), z.object({ "DeleteAccountStaking": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is staking and can not be deleted"), z.object({ "LackBalanceForState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which needs balance"), "amount": z.string().describe("Balance required to complete an action.") }) }).strict().describe("ActionReceipt can't be completed, because the remaining balance will not be enough to cover storage."), z.object({ "TriesToUnstake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is not yet staked, but tries to unstake"), z.object({ "TriesToStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "balance": z.string(), "locked": z.string(), "stake": z.string() }) }).strict().describe("The account doesn't have enough balance to increase the stake."), z.object({ "InsufficientStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "minimum_stake": z.string(), "stake": z.string() }) }).strict(), z.object({ "FunctionCallError": z.any().superRefine((x, ctx) => {
    const schemas = [z.enum(["WasmUnknownError","_EVMError"]), z.object({ "CompilationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "PrepareError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Serialization").describe("Error happened while serializing the module."), z.literal("Deserialization").describe("Error happened while deserializing the module."), z.literal("InternalMemoryDeclared").describe("Internal memory declaration has been found in the module."), z.literal("GasInstrumentation").describe("Gas instrumentation failed.\n\nThis most likely indicates the module isn't valid."), z.literal("StackHeightInstrumentation").describe("Stack instrumentation failed.\n\nThis  most likely indicates the module isn't valid."), z.literal("Instantiate").describe("Error happened during instantiation.\n\nThis might indicate that `start` function trapped, or module isn't\ninstantiable and/or un-linkable."), z.literal("Memory").describe("Error creating memory."), z.literal("TooManyFunctions").describe("Contract contains too many functions."), z.literal("TooManyLocals").describe("Contract contains too many locals."), z.literal("TooManyTables").describe("Contract contains too many tables."), z.literal("TooManyTableElements").describe("Contract contains too many table elements.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error that can occur while preparing or executing Wasm smart-contract.") }).strict(), z.object({ "WasmerCompileError": z.object({ "msg": z.string() }) }).strict().describe("This is for defense in depth.\nWe expect our runtime-independent preparation code to fully catch all invalid wasms,\nbut, if it ever misses something we’ll emit this error")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Wasm compilation error"), z.object({ "LinkError": z.object({ "msg": z.string() }) }).strict().describe("Wasm binary env link error\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "MethodResolveError": z.enum(["MethodEmptyName","MethodNotFound","MethodInvalidSignature"]) }).strict().describe("Import/export resolve error"), z.object({ "WasmTrap": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unreachable").describe("An `unreachable` opcode was executed."), z.literal("IncorrectCallIndirectSignature").describe("Call indirect incorrect signature trap."), z.literal("MemoryOutOfBounds").describe("Memory out of bounds trap."), z.literal("CallIndirectOOB").describe("Call indirect out of bounds trap."), z.literal("IllegalArithmetic").describe("An arithmetic exception, e.g. divided by zero."), z.literal("MisalignedAtomicAccess").describe("Misaligned atomic access trap."), z.literal("IndirectCallToNull").describe("Indirect call to null."), z.literal("StackOverflow").describe("Stack overflow."), z.literal("GenericTrap").describe("Generic trap.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("A kind of a trap happened during execution of a binary") }).strict().describe("A trap happened during execution of a binary\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "HostError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("BadUTF16").describe("String encoding is bad UTF-16 sequence"), z.literal("BadUTF8").describe("String encoding is bad UTF-8 sequence"), z.literal("GasExceeded").describe("Exceeded the prepaid gas"), z.literal("GasLimitExceeded").describe("Exceeded the maximum amount of gas allowed to burn per contract"), z.literal("BalanceExceeded").describe("Exceeded the account balance"), z.literal("EmptyMethodName").describe("Tried to call an empty method name"), z.object({ "GuestPanic": z.object({ "panic_msg": z.string() }) }).strict().describe("Smart contract panicked"), z.literal("IntegerOverflow").describe("IntegerOverflow happened during a contract execution"), z.object({ "InvalidPromiseIndex": z.object({ "promise_idx": z.number().int().gte(0) }) }).strict().describe("`promise_idx` does not correspond to existing promises"), z.literal("CannotAppendActionToJointPromise").describe("Actions can only be appended to non-joint promise."), z.literal("CannotReturnJointPromise").describe("Returning joint promise is currently prohibited"), z.object({ "InvalidPromiseResultIndex": z.object({ "result_idx": z.number().int().gte(0) }) }).strict().describe("Accessed invalid promise result index"), z.object({ "InvalidRegisterId": z.object({ "register_id": z.number().int().gte(0) }) }).strict().describe("Accessed invalid register id"), z.object({ "IteratorWasInvalidated": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie"), z.literal("MemoryAccessViolation").describe("Accessed memory outside the bounds"), z.object({ "InvalidReceiptIndex": z.object({ "receipt_index": z.number().int().gte(0) }) }).strict().describe("VM Logic returned an invalid receipt index"), z.object({ "InvalidIteratorIndex": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator index `iterator_index` does not exist"), z.literal("InvalidAccountId").describe("VM Logic returned an invalid account id"), z.literal("InvalidMethodName").describe("VM Logic returned an invalid method name"), z.literal("InvalidPublicKey").describe("VM Logic provided an invalid public key"), z.object({ "ProhibitedInView": z.object({ "method_name": z.string() }) }).strict().describe("`method_name` is not allowed in view calls"), z.object({ "NumberOfLogsExceeded": z.object({ "limit": z.number().int().gte(0) }) }).strict().describe("The total number of logs will exceed the limit."), z.object({ "KeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage key length exceeded the limit."), z.object({ "ValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage value length exceeded the limit."), z.object({ "TotalLogLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The total log length exceeded the limit."), z.object({ "NumberPromisesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_promises": z.number().int().gte(0) }) }).strict().describe("The maximum number of promises within a FunctionCall exceeded the limit."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The maximum number of input data dependencies exceeded the limit."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The returned value length exceeded the limit."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The contract size for DeployContract action exceeded the limit."), z.object({ "Deprecated": z.object({ "method_name": z.string() }) }).strict().describe("The host function was deprecated."), z.object({ "ECRecoverError": z.object({ "msg": z.string() }) }).strict().describe("General errors for ECDSA recover."), z.object({ "AltBn128InvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to alt_bn128 family of functions (e.g., point which isn't\non the curve)."), z.object({ "Ed25519VerifyInvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to ed25519 signature verification function (e.g. signature cannot be\nderived from bytes).")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Note: this is only to deserialize old data, use execution error for new data"), z.object({ "ExecutionError": z.string() }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Serializable version of `near-vm-runner::FunctionCallError`.\n\nMust never reorder/remove elements, can only add new variants at the end (but do that very\ncarefully). It describes stable serialization format, and only used by serialization logic.") }).strict().describe("An error occurred during a `FunctionCall` Action, parameter is debug message."), z.object({ "NewReceiptValidationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidPredecessorId": z.object({ "account_id": z.string() }) }).strict().describe("The `predecessor_id` of a Receipt is not valid."), z.object({ "InvalidReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a Receipt is not valid."), z.object({ "InvalidSignerId": z.object({ "account_id": z.string() }) }).strict().describe("The `signer_id` of an ActionReceipt is not valid."), z.object({ "InvalidDataReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a DataReceiver within an ActionReceipt is not valid."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the returned data exceeded the limit in a DataReceipt."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The number of input data dependencies exceeds the limit in an ActionReceipt."), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of an ActionReceipt."), z.object({ "ReceiptSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("Receipt is bigger than the limit."), z.object({ "InvalidRefundTo": z.object({ "account_id": z.string() }) }).strict().describe("The `refund_to` of an ActionReceipt is not valid.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a receipt.") }).strict().describe("Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\nreceipt validation."), z.object({ "OnlyImplicitAccountCreationAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\nSee NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\nAlso, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\nTODO(#8598): This error is named very poorly. A better name would be\n`OnlyNamedAccountCreationAllowed`."), z.object({ "DeleteAccountWithLargeState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Delete account whose state is large is temporarily banned."), z.literal("DelegateActionInvalidSignature").describe("Signature does not match the provided actions and given signer public key."), z.object({ "DelegateActionSenderDoesNotMatchTxReceiver": z.object({ "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Receiver of the transaction doesn't match Sender of the delegate action"), z.literal("DelegateActionExpired").describe("Delegate action has expired. `max_block_height` is less than actual block height."), z.object({ "DelegateActionAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("The given public key doesn't exist for Sender account"), z.object({ "DelegateActionInvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "delegate_nonce": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce must be greater sender[public_key].nonce"), z.object({ "DelegateActionNonceTooLarge": z.object({ "delegate_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce is larger than the upper bound given by the block height"), z.object({ "GlobalContractDoesNotExist": z.object({ "identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("The kind of ActionError happened") }).describe("An error happened during Action execution")
export type ActionError = z.infer<typeof ActionError>


export const ActionErrorKind = z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccountAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage"), z.object({ "AccountDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when TX receiver_id doesn't exist (but action is not Action::CreateAccount)"), z.object({ "CreateAccountOnlyByRegistrar": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "registrar_account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A top-level account ID can only be created by registrar."), z.object({ "CreateAccountNotAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A newly created account must be under a namespace of the creator account"), z.object({ "ActorNoPermission": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "actor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\nor the first TX action is a `CreateAccount` action"), z.object({ "DeleteKeyDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("Account tries to remove an access key that doesn't exist"), z.object({ "AddKeyAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The public key is already used for an existing access key"), z.object({ "DeleteAccountStaking": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is staking and can not be deleted"), z.object({ "LackBalanceForState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which needs balance"), "amount": z.string().describe("Balance required to complete an action.") }) }).strict().describe("ActionReceipt can't be completed, because the remaining balance will not be enough to cover storage."), z.object({ "TriesToUnstake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is not yet staked, but tries to unstake"), z.object({ "TriesToStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "balance": z.string(), "locked": z.string(), "stake": z.string() }) }).strict().describe("The account doesn't have enough balance to increase the stake."), z.object({ "InsufficientStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "minimum_stake": z.string(), "stake": z.string() }) }).strict(), z.object({ "FunctionCallError": z.any().superRefine((x, ctx) => {
    const schemas = [z.enum(["WasmUnknownError","_EVMError"]), z.object({ "CompilationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "PrepareError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Serialization").describe("Error happened while serializing the module."), z.literal("Deserialization").describe("Error happened while deserializing the module."), z.literal("InternalMemoryDeclared").describe("Internal memory declaration has been found in the module."), z.literal("GasInstrumentation").describe("Gas instrumentation failed.\n\nThis most likely indicates the module isn't valid."), z.literal("StackHeightInstrumentation").describe("Stack instrumentation failed.\n\nThis  most likely indicates the module isn't valid."), z.literal("Instantiate").describe("Error happened during instantiation.\n\nThis might indicate that `start` function trapped, or module isn't\ninstantiable and/or un-linkable."), z.literal("Memory").describe("Error creating memory."), z.literal("TooManyFunctions").describe("Contract contains too many functions."), z.literal("TooManyLocals").describe("Contract contains too many locals."), z.literal("TooManyTables").describe("Contract contains too many tables."), z.literal("TooManyTableElements").describe("Contract contains too many table elements.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error that can occur while preparing or executing Wasm smart-contract.") }).strict(), z.object({ "WasmerCompileError": z.object({ "msg": z.string() }) }).strict().describe("This is for defense in depth.\nWe expect our runtime-independent preparation code to fully catch all invalid wasms,\nbut, if it ever misses something we’ll emit this error")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Wasm compilation error"), z.object({ "LinkError": z.object({ "msg": z.string() }) }).strict().describe("Wasm binary env link error\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "MethodResolveError": z.enum(["MethodEmptyName","MethodNotFound","MethodInvalidSignature"]) }).strict().describe("Import/export resolve error"), z.object({ "WasmTrap": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unreachable").describe("An `unreachable` opcode was executed."), z.literal("IncorrectCallIndirectSignature").describe("Call indirect incorrect signature trap."), z.literal("MemoryOutOfBounds").describe("Memory out of bounds trap."), z.literal("CallIndirectOOB").describe("Call indirect out of bounds trap."), z.literal("IllegalArithmetic").describe("An arithmetic exception, e.g. divided by zero."), z.literal("MisalignedAtomicAccess").describe("Misaligned atomic access trap."), z.literal("IndirectCallToNull").describe("Indirect call to null."), z.literal("StackOverflow").describe("Stack overflow."), z.literal("GenericTrap").describe("Generic trap.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("A kind of a trap happened during execution of a binary") }).strict().describe("A trap happened during execution of a binary\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "HostError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("BadUTF16").describe("String encoding is bad UTF-16 sequence"), z.literal("BadUTF8").describe("String encoding is bad UTF-8 sequence"), z.literal("GasExceeded").describe("Exceeded the prepaid gas"), z.literal("GasLimitExceeded").describe("Exceeded the maximum amount of gas allowed to burn per contract"), z.literal("BalanceExceeded").describe("Exceeded the account balance"), z.literal("EmptyMethodName").describe("Tried to call an empty method name"), z.object({ "GuestPanic": z.object({ "panic_msg": z.string() }) }).strict().describe("Smart contract panicked"), z.literal("IntegerOverflow").describe("IntegerOverflow happened during a contract execution"), z.object({ "InvalidPromiseIndex": z.object({ "promise_idx": z.number().int().gte(0) }) }).strict().describe("`promise_idx` does not correspond to existing promises"), z.literal("CannotAppendActionToJointPromise").describe("Actions can only be appended to non-joint promise."), z.literal("CannotReturnJointPromise").describe("Returning joint promise is currently prohibited"), z.object({ "InvalidPromiseResultIndex": z.object({ "result_idx": z.number().int().gte(0) }) }).strict().describe("Accessed invalid promise result index"), z.object({ "InvalidRegisterId": z.object({ "register_id": z.number().int().gte(0) }) }).strict().describe("Accessed invalid register id"), z.object({ "IteratorWasInvalidated": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie"), z.literal("MemoryAccessViolation").describe("Accessed memory outside the bounds"), z.object({ "InvalidReceiptIndex": z.object({ "receipt_index": z.number().int().gte(0) }) }).strict().describe("VM Logic returned an invalid receipt index"), z.object({ "InvalidIteratorIndex": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator index `iterator_index` does not exist"), z.literal("InvalidAccountId").describe("VM Logic returned an invalid account id"), z.literal("InvalidMethodName").describe("VM Logic returned an invalid method name"), z.literal("InvalidPublicKey").describe("VM Logic provided an invalid public key"), z.object({ "ProhibitedInView": z.object({ "method_name": z.string() }) }).strict().describe("`method_name` is not allowed in view calls"), z.object({ "NumberOfLogsExceeded": z.object({ "limit": z.number().int().gte(0) }) }).strict().describe("The total number of logs will exceed the limit."), z.object({ "KeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage key length exceeded the limit."), z.object({ "ValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage value length exceeded the limit."), z.object({ "TotalLogLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The total log length exceeded the limit."), z.object({ "NumberPromisesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_promises": z.number().int().gte(0) }) }).strict().describe("The maximum number of promises within a FunctionCall exceeded the limit."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The maximum number of input data dependencies exceeded the limit."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The returned value length exceeded the limit."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The contract size for DeployContract action exceeded the limit."), z.object({ "Deprecated": z.object({ "method_name": z.string() }) }).strict().describe("The host function was deprecated."), z.object({ "ECRecoverError": z.object({ "msg": z.string() }) }).strict().describe("General errors for ECDSA recover."), z.object({ "AltBn128InvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to alt_bn128 family of functions (e.g., point which isn't\non the curve)."), z.object({ "Ed25519VerifyInvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to ed25519 signature verification function (e.g. signature cannot be\nderived from bytes).")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Note: this is only to deserialize old data, use execution error for new data"), z.object({ "ExecutionError": z.string() }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Serializable version of `near-vm-runner::FunctionCallError`.\n\nMust never reorder/remove elements, can only add new variants at the end (but do that very\ncarefully). It describes stable serialization format, and only used by serialization logic.") }).strict().describe("An error occurred during a `FunctionCall` Action, parameter is debug message."), z.object({ "NewReceiptValidationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidPredecessorId": z.object({ "account_id": z.string() }) }).strict().describe("The `predecessor_id` of a Receipt is not valid."), z.object({ "InvalidReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a Receipt is not valid."), z.object({ "InvalidSignerId": z.object({ "account_id": z.string() }) }).strict().describe("The `signer_id` of an ActionReceipt is not valid."), z.object({ "InvalidDataReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a DataReceiver within an ActionReceipt is not valid."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the returned data exceeded the limit in a DataReceipt."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The number of input data dependencies exceeds the limit in an ActionReceipt."), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of an ActionReceipt."), z.object({ "ReceiptSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("Receipt is bigger than the limit."), z.object({ "InvalidRefundTo": z.object({ "account_id": z.string() }) }).strict().describe("The `refund_to` of an ActionReceipt is not valid.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a receipt.") }).strict().describe("Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\nreceipt validation."), z.object({ "OnlyImplicitAccountCreationAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\nSee NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\nAlso, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\nTODO(#8598): This error is named very poorly. A better name would be\n`OnlyNamedAccountCreationAllowed`."), z.object({ "DeleteAccountWithLargeState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Delete account whose state is large is temporarily banned."), z.literal("DelegateActionInvalidSignature").describe("Signature does not match the provided actions and given signer public key."), z.object({ "DelegateActionSenderDoesNotMatchTxReceiver": z.object({ "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Receiver of the transaction doesn't match Sender of the delegate action"), z.literal("DelegateActionExpired").describe("Delegate action has expired. `max_block_height` is less than actual block height."), z.object({ "DelegateActionAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("The given public key doesn't exist for Sender account"), z.object({ "DelegateActionInvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "delegate_nonce": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce must be greater sender[public_key].nonce"), z.object({ "DelegateActionNonceTooLarge": z.object({ "delegate_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce is larger than the upper bound given by the block height"), z.object({ "GlobalContractDoesNotExist": z.object({ "identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })
export type ActionErrorKind = z.infer<typeof ActionErrorKind>


export const ActionView = z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("CreateAccount"), z.object({ "DeployContract": z.object({ "code": z.string() }) }).strict(), z.object({ "FunctionCall": z.object({ "args": z.string().describe("This type is used to mark function arguments.\n\nNOTE: The main reason for this to exist (except the type-safety) is that the value is\ntransparently serialized and deserialized as a base64-encoded string when serde is used\n(serde_json)."), "deposit": z.string(), "gas": z.number().int().gte(0), "method_name": z.string() }) }).strict(), z.object({ "Transfer": z.object({ "deposit": z.string() }) }).strict(), z.object({ "Stake": z.object({ "public_key": z.string(), "stake": z.string() }) }).strict(), z.object({ "AddKey": z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("FullAccess"), z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "method_names": z.array(z.string()), "receiver_id": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the permission scope for an access key. Whether it is a function call or a full access key.") }).describe("Describes access key permission scope and nonce."), "public_key": z.string() }) }).strict(), z.object({ "DeleteKey": z.object({ "public_key": z.string() }) }).strict(), z.object({ "DeleteAccount": z.object({ "beneficiary_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "Delegate": z.object({ "delegate_action": z.object({ "actions": z.array(z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CreateAccount": z.record(z.any()).describe("Create account action") }).strict().describe("Create an (sub)account using a transaction `receiver_id` as an ID for\na new account ID must pass validation rules described here\n<https://nomicon.io/DataStructures/Account>."), z.object({ "DeployContract": z.object({ "code": z.string().describe("WebAssembly binary") }).describe("Deploy contract action") }).strict().describe("Sets a Wasm code to a receiver_id"), z.object({ "FunctionCall": z.object({ "args": z.string(), "deposit": z.string(), "gas": z.number().int().gte(0), "method_name": z.string() }) }).strict(), z.object({ "Transfer": z.object({ "deposit": z.string() }) }).strict(), z.object({ "Stake": z.object({ "public_key": z.string().describe("Validator key which will be used to sign transactions on behalf of signer_id"), "stake": z.string().describe("Amount of tokens to stake.") }).describe("An action which stakes signer_id tokens and setup's validator public key") }).strict(), z.object({ "AddKey": z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0).describe("Nonce for this access key, used for tx nonce generation. When access key is created, nonce\nis set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\nSee <https://github.com/near/nearcore/issues/3779> for more details."), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Allowance is a balance limit to use by this access key to pay for function call gas and\ntransaction fees. When this access key is used, both account balance and the allowance is\ndecreased by the same value.\n`None` means unlimited allowance.\nNOTE: To change or increase the allowance, the old access key needs to be deleted and a new\naccess key should be created.").optional(), "method_names": z.array(z.string()).describe("A list of method names that can be used. The access key only allows transactions with the\nfunction call of one of the given method names.\nEmpty list means any method name can be used."), "receiver_id": z.string().describe("The access key only allows transactions with the given receiver's account id.") }).describe("Grants limited permission to make transactions with FunctionCallActions\nThe permission can limit the allowed balance to be spent on the prepaid gas.\nIt also restrict the account ID of the receiver for this function call.\nIt also can restrict the method name for the allowed function calls.") }).strict(), z.literal("FullAccess").describe("Grants full access to the account.\nNOTE: It's used to replace account-level public keys.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Defines permissions for AccessKey").describe("Defines permissions for this access key.") }).describe("Access key provides limited access to an account. Each access key belongs to some account and\nis identified by a unique (within the account) public key. One account may have large number of\naccess keys. Access keys allow to act on behalf of the account by restricting transactions\nthat can be issued.\n`account_id,public_key` is a key in the state").describe("An access key with the permission"), "public_key": z.string().describe("A public key which will be associated with an access_key") }).describe("An action that adds key with public key associated") }).strict(), z.object({ "DeleteKey": z.object({ "public_key": z.string().describe("A public key associated with the access_key to be deleted.") }) }).strict(), z.object({ "DeleteAccount": z.object({ "beneficiary_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeployGlobalContract": z.object({ "code": z.string().describe("WebAssembly binary"), "deploy_mode": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("CodeHash").describe("Contract is deployed under its code hash.\nUsers will be able reference it by that hash.\nThis effectively makes the contract immutable."), z.literal("AccountId").describe("Contract is deployed under the owner account id.\nUsers will be able reference it by that account id.\nThis allows the owner to update the contract for all its users.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Deploy global contract action") }).strict(), z.object({ "UseGlobalContract": z.object({ "contract_identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Use global contract action") }).strict(), z.object({ "DeterministicStateInit": z.object({ "deposit": z.string(), "state_init": z.object({ "V1": z.object({ "code": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "data": z.record(z.string()) }) }).strict() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An Action that can be included in a transaction or receipt, excluding delegate actions. This type represents all possible action types except DelegateAction to prevent infinite recursion in meta-transactions.")).describe("List of actions to be executed.\n\nWith the meta transactions MVP defined in NEP-366, nested\nDelegateActions are not allowed. A separate type is used to enforce it."), "max_block_height": z.number().int().gte(0).describe("The maximal height of the block in the blockchain below which the given DelegateAction is valid."), "nonce": z.number().int().gte(0).describe("Nonce to ensure that the same delegate action is not sent twice by a\nrelayer and should match for given account's `public_key`.\nAfter this action is processed it will increment."), "public_key": z.string().describe("Public key used to sign this delegated action."), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("Receiver of the delegated actions."), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("Signer of the delegated actions") }).describe("This action allows to execute the inner actions behalf of the defined sender."), "signature": z.string() }) }).strict(), z.object({ "DeployGlobalContract": z.object({ "code": z.string() }) }).strict(), z.object({ "DeployGlobalContractByAccountId": z.object({ "code": z.string() }) }).strict(), z.object({ "UseGlobalContract": z.object({ "code_hash": z.string() }) }).strict(), z.object({ "UseGlobalContractByAccountId": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInit": z.object({ "code": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "hash": z.string() }).strict(), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "data": z.record(z.string()), "deposit": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })
export type ActionView = z.infer<typeof ActionView>


export const ActionsValidationError = z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.")
export type ActionsValidationError = z.infer<typeof ActionsValidationError>


export const AddKeyAction = z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0).describe("Nonce for this access key, used for tx nonce generation. When access key is created, nonce\nis set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\nSee <https://github.com/near/nearcore/issues/3779> for more details."), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Allowance is a balance limit to use by this access key to pay for function call gas and\ntransaction fees. When this access key is used, both account balance and the allowance is\ndecreased by the same value.\n`None` means unlimited allowance.\nNOTE: To change or increase the allowance, the old access key needs to be deleted and a new\naccess key should be created.").optional(), "method_names": z.array(z.string()).describe("A list of method names that can be used. The access key only allows transactions with the\nfunction call of one of the given method names.\nEmpty list means any method name can be used."), "receiver_id": z.string().describe("The access key only allows transactions with the given receiver's account id.") }).describe("Grants limited permission to make transactions with FunctionCallActions\nThe permission can limit the allowed balance to be spent on the prepaid gas.\nIt also restrict the account ID of the receiver for this function call.\nIt also can restrict the method name for the allowed function calls.") }).strict(), z.literal("FullAccess").describe("Grants full access to the account.\nNOTE: It's used to replace account-level public keys.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Defines permissions for AccessKey").describe("Defines permissions for this access key.") }).describe("Access key provides limited access to an account. Each access key belongs to some account and\nis identified by a unique (within the account) public key. One account may have large number of\naccess keys. Access keys allow to act on behalf of the account by restricting transactions\nthat can be issued.\n`account_id,public_key` is a key in the state").describe("An access key with the permission"), "public_key": z.string().describe("A public key which will be associated with an access_key") }).describe("An action that adds key with public key associated")
export type AddKeyAction = z.infer<typeof AddKeyAction>


export const BandwidthRequest = z.object({ "requested_values_bitmap": z.object({ "data": z.array(z.number().int().gte(0).lte(255)).min(5).max(5) }).describe("Bitmap which describes which values from the predefined list are being requested.\nThe nth bit is set to 1 when the nth value from the list is being requested.").describe("Bitmap which describes what values of bandwidth are requested."), "to_shard": z.number().int().gte(0).lte(65535).describe("Requesting bandwidth to this shard.") }).describe("`BandwidthRequest` describes the size of receipts that a shard would like to send to another shard.\nWhen a shard wants to send a lot of receipts to another shard, it needs to create a request and wait\nfor a bandwidth grant from the bandwidth scheduler.")
export type BandwidthRequest = z.infer<typeof BandwidthRequest>


export const BandwidthRequestBitmap = z.object({ "data": z.array(z.number().int().gte(0).lte(255)).min(5).max(5) }).describe("Bitmap which describes which values from the predefined list are being requested.\nThe nth bit is set to 1 when the nth value from the list is being requested.")
export type BandwidthRequestBitmap = z.infer<typeof BandwidthRequestBitmap>


export const BandwidthRequests = z.object({ "V1": z.object({ "requests": z.array(z.object({ "requested_values_bitmap": z.object({ "data": z.array(z.number().int().gte(0).lte(255)).min(5).max(5) }).describe("Bitmap which describes which values from the predefined list are being requested.\nThe nth bit is set to 1 when the nth value from the list is being requested.").describe("Bitmap which describes what values of bandwidth are requested."), "to_shard": z.number().int().gte(0).lte(65535).describe("Requesting bandwidth to this shard.") }).describe("`BandwidthRequest` describes the size of receipts that a shard would like to send to another shard.\nWhen a shard wants to send a lot of receipts to another shard, it needs to create a request and wait\nfor a bandwidth grant from the bandwidth scheduler.")) }).describe("Version 1 of [`BandwidthRequest`].") }).strict().describe("A list of shard's bandwidth requests.\nDescribes how much the shard would like to send to other shards.")
export type BandwidthRequests = z.infer<typeof BandwidthRequests>


export const BandwidthRequestsV1 = z.object({ "requests": z.array(z.object({ "requested_values_bitmap": z.object({ "data": z.array(z.number().int().gte(0).lte(255)).min(5).max(5) }).describe("Bitmap which describes which values from the predefined list are being requested.\nThe nth bit is set to 1 when the nth value from the list is being requested.").describe("Bitmap which describes what values of bandwidth are requested."), "to_shard": z.number().int().gte(0).lte(65535).describe("Requesting bandwidth to this shard.") }).describe("`BandwidthRequest` describes the size of receipts that a shard would like to send to another shard.\nWhen a shard wants to send a lot of receipts to another shard, it needs to create a request and wait\nfor a bandwidth grant from the bandwidth scheduler.")) }).describe("Version 1 of [`BandwidthRequest`].")
export type BandwidthRequestsV1 = z.infer<typeof BandwidthRequestsV1>


export const BlockHeaderInnerLiteView = z.object({ "block_merkle_root": z.string().describe("The merkle root of all the block hashes"), "epoch_id": z.string().describe("The epoch to which the block that is the current known head belongs"), "height": z.number().int().gte(0), "next_bp_hash": z.string().describe("The hash of the block producers set for the next epoch"), "next_epoch_id": z.string().describe("The epoch that will follow the current epoch"), "outcome_root": z.string(), "prev_state_root": z.string(), "timestamp": z.number().int().gte(0).describe("Legacy json number. Should not be used."), "timestamp_nanosec": z.string() }).describe("A part of a state for the current head of a light client. More info [here](https://nomicon.io/ChainSpec/LightClient).")
export type BlockHeaderInnerLiteView = z.infer<typeof BlockHeaderInnerLiteView>


export const BlockHeaderView = z.object({ "approvals": z.array(z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })), "block_body_hash": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "block_merkle_root": z.string(), "block_ordinal": z.union([z.number().int().gte(0), z.null()]).optional(), "challenges_result": z.array(z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "is_double_sign": z.boolean() })), "challenges_root": z.string(), "chunk_endorsements": z.union([z.array(z.array(z.number().int().gte(0).lte(255))), z.null()]).optional(), "chunk_headers_root": z.string(), "chunk_mask": z.array(z.boolean()), "chunk_receipts_root": z.string(), "chunk_tx_root": z.string(), "chunks_included": z.number().int().gte(0), "epoch_id": z.string(), "epoch_sync_data_hash": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "gas_price": z.string(), "hash": z.string(), "height": z.number().int().gte(0), "last_ds_final_block": z.string(), "last_final_block": z.string(), "latest_protocol_version": z.number().int().gte(0), "next_bp_hash": z.string(), "next_epoch_id": z.string(), "outcome_root": z.string(), "prev_hash": z.string().describe("The hash of the previous Block"), "prev_height": z.union([z.number().int().gte(0), z.null()]).optional(), "prev_state_root": z.string(), "random_value": z.string(), "rent_paid": z.string().describe("TODO(2271): deprecated.").default("0"), "signature": z.string().describe("Signature of the block producer."), "timestamp": z.number().int().gte(0).describe("Legacy json number. Should not be used."), "timestamp_nanosec": z.string(), "total_supply": z.string(), "validator_proposals": z.array(z.object({ "validator_stake_struct_version": z.literal("V1") }).and(z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string(), "stake": z.string() }))), "validator_reward": z.string().describe("TODO(2271): deprecated.").default("0") }).describe("Contains main info about the block.")
export type BlockHeaderView = z.infer<typeof BlockHeaderView>


export const BlockHeightRange = z.object({ "end": z.number().int().gte(0), "start": z.number().int().gte(0) })
export type BlockHeightRange = z.infer<typeof BlockHeightRange>


export const BlockHeightRanges = z.array(z.object({ "end": z.number().int().gte(0), "start": z.number().int().gte(0) }))
export type BlockHeightRanges = z.infer<typeof BlockHeightRanges>


export const BlockId = z.any().superRefine((x, ctx) => {
    const schemas = [z.number().int().gte(0), z.string()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })
export type BlockId = z.infer<typeof BlockId>


export const BlockStatusView = z.object({ "hash": z.string(), "height": z.number().int().gte(0) }).describe("Height and hash of a block")
export type BlockStatusView = z.infer<typeof BlockStatusView>


export const CallResult = z.object({ "logs": z.array(z.string()), "result": z.array(z.number().int().gte(0).lte(255)) }).describe("A result returned by contract method")
export type CallResult = z.infer<typeof CallResult>


export const CatchupStatusView = z.object({ "blocks_to_catchup": z.array(z.object({ "hash": z.string(), "height": z.number().int().gte(0) }).describe("Height and hash of a block")), "shard_sync_status": z.record(z.union([z.string(), z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^\\d+$"))) {
evaluated = true
const result = z.string().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}), "sync_block_hash": z.string(), "sync_block_height": z.number().int().gte(0) }).describe("Status of the [catchup](https://near.github.io/nearcore/architecture/how/sync.html#catchup) process")
export type CatchupStatusView = z.infer<typeof CatchupStatusView>


export const ChunkDistributionNetworkConfig = z.object({ "enabled": z.boolean(), "uris": z.object({ "get": z.string().describe("URI for pulling chunks from the stream."), "set": z.string().describe("URI for publishing chunks to the stream.") }).describe("URIs for the Chunk Distribution Network feature.") }).describe("Config for the Chunk Distribution Network feature.\nThis allows nodes to push and pull chunks from a central stream.\nThe two benefits of this approach are: (1) less request/response traffic\non the peer-to-peer network and (2) lower latency for RPC nodes indexing the chain.")
export type ChunkDistributionNetworkConfig = z.infer<typeof ChunkDistributionNetworkConfig>


export const ChunkDistributionUris = z.object({ "get": z.string().describe("URI for pulling chunks from the stream."), "set": z.string().describe("URI for publishing chunks to the stream.") }).describe("URIs for the Chunk Distribution Network feature.")
export type ChunkDistributionUris = z.infer<typeof ChunkDistributionUris>


export const ChunkHeaderView = z.object({ "balance_burnt": z.string(), "bandwidth_requests": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "V1": z.object({ "requests": z.array(z.object({ "requested_values_bitmap": z.object({ "data": z.array(z.number().int().gte(0).lte(255)).min(5).max(5) }).describe("Bitmap which describes which values from the predefined list are being requested.\nThe nth bit is set to 1 when the nth value from the list is being requested.").describe("Bitmap which describes what values of bandwidth are requested."), "to_shard": z.number().int().gte(0).lte(65535).describe("Requesting bandwidth to this shard.") }).describe("`BandwidthRequest` describes the size of receipts that a shard would like to send to another shard.\nWhen a shard wants to send a lot of receipts to another shard, it needs to create a request and wait\nfor a bandwidth grant from the bandwidth scheduler.")) }).describe("Version 1 of [`BandwidthRequest`].") }).strict().describe("A list of shard's bandwidth requests.\nDescribes how much the shard would like to send to other shards."), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "chunk_hash": z.string(), "congestion_info": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "allowed_shard": z.number().int().gte(0).lte(65535), "buffered_receipts_gas": z.string(), "delayed_receipts_gas": z.string(), "receipt_bytes": z.number().int().gte(0) }).describe("Stores the congestion level of a shard. More info about congestion [here](https://near.github.io/nearcore/architecture/how/receipt-congestion.html?highlight=congestion#receipt-congestion)"), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "encoded_length": z.number().int().gte(0), "encoded_merkle_root": z.string(), "gas_limit": z.number().int().gte(0), "gas_used": z.number().int().gte(0), "height_created": z.number().int().gte(0), "height_included": z.number().int().gte(0), "outcome_root": z.string(), "outgoing_receipts_root": z.string(), "prev_block_hash": z.string(), "prev_state_root": z.string(), "rent_paid": z.string().describe("TODO(2271): deprecated.").default("0"), "shard_id": z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias."), "signature": z.string(), "tx_root": z.string(), "validator_proposals": z.array(z.object({ "validator_stake_struct_version": z.literal("V1") }).and(z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string(), "stake": z.string() }))), "validator_reward": z.string().describe("TODO(2271): deprecated.").default("0") }).describe("Contains main info about the chunk.")
export type ChunkHeaderView = z.infer<typeof ChunkHeaderView>


export const CloudArchivalWriterConfig = z.object({ "archive_block_data": z.boolean().describe("Determines whether block-related data should be written to cloud storage.").default(false), "polling_interval": z.object({ "nanos": z.number().int(), "secs": z.number().int() }).describe("Interval at which the system checks for new blocks or chunks to archive.").default({"nanos":0,"secs":1}) }).describe("Configuration for a cloud-based archival writer. If this config is present, the writer is enabled and\nwrites chunk-related data based on the tracked shards. This config also controls additional archival\nbehavior such as block data and polling interval.")
export type CloudArchivalWriterConfig = z.infer<typeof CloudArchivalWriterConfig>


export const CompilationError = z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "PrepareError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Serialization").describe("Error happened while serializing the module."), z.literal("Deserialization").describe("Error happened while deserializing the module."), z.literal("InternalMemoryDeclared").describe("Internal memory declaration has been found in the module."), z.literal("GasInstrumentation").describe("Gas instrumentation failed.\n\nThis most likely indicates the module isn't valid."), z.literal("StackHeightInstrumentation").describe("Stack instrumentation failed.\n\nThis  most likely indicates the module isn't valid."), z.literal("Instantiate").describe("Error happened during instantiation.\n\nThis might indicate that `start` function trapped, or module isn't\ninstantiable and/or un-linkable."), z.literal("Memory").describe("Error creating memory."), z.literal("TooManyFunctions").describe("Contract contains too many functions."), z.literal("TooManyLocals").describe("Contract contains too many locals."), z.literal("TooManyTables").describe("Contract contains too many tables."), z.literal("TooManyTableElements").describe("Contract contains too many table elements.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error that can occur while preparing or executing Wasm smart-contract.") }).strict(), z.object({ "WasmerCompileError": z.object({ "msg": z.string() }) }).strict().describe("This is for defense in depth.\nWe expect our runtime-independent preparation code to fully catch all invalid wasms,\nbut, if it ever misses something we’ll emit this error")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })
export type CompilationError = z.infer<typeof CompilationError>


export const CongestionControlConfigView = z.object({ "allowed_shard_outgoing_gas": z.number().int().gte(0).describe("How much gas the chosen allowed shard can send to a 100% congested shard.\n\nSee [`CongestionControlConfig`] for more details."), "max_congestion_incoming_gas": z.number().int().gte(0).describe("How much gas in delayed receipts of a shard is 100% incoming congestion.\n\nSee [`CongestionControlConfig`] for more details."), "max_congestion_memory_consumption": z.number().int().gte(0).describe("How much memory space of all delayed and buffered receipts in a shard is\nconsidered 100% congested.\n\nSee [`CongestionControlConfig`] for more details."), "max_congestion_missed_chunks": z.number().int().gte(0).describe("How many missed chunks in a row in a shard is considered 100% congested."), "max_congestion_outgoing_gas": z.number().int().gte(0).describe("How much gas in outgoing buffered receipts of a shard is 100% congested.\n\nOutgoing congestion contributes to overall congestion, which reduces how\nmuch other shards are allowed to forward to this shard."), "max_outgoing_gas": z.number().int().gte(0).describe("The maximum amount of gas attached to receipts a shard can forward to\nanother shard per chunk.\n\nSee [`CongestionControlConfig`] for more details."), "max_tx_gas": z.number().int().gte(0).describe("The maximum amount of gas in a chunk spent on converting new transactions to\nreceipts.\n\nSee [`CongestionControlConfig`] for more details."), "min_outgoing_gas": z.number().int().gte(0).describe("The minimum gas each shard can send to a shard that is not fully congested.\n\nSee [`CongestionControlConfig`] for more details."), "min_tx_gas": z.number().int().gte(0).describe("The minimum amount of gas in a chunk spent on converting new transactions\nto receipts, as long as the receiving shard is not congested.\n\nSee [`CongestionControlConfig`] for more details."), "outgoing_receipts_big_size_limit": z.number().int().gte(0).describe("Large size limit for outgoing receipts to a shard, used when it's safe\nto send a lot of receipts without making the state witness too large.\nIt limits the total sum of outgoing receipts, not individual receipts."), "outgoing_receipts_usual_size_limit": z.number().int().gte(0).describe("The standard size limit for outgoing receipts aimed at a single shard.\nThis limit is pretty small to keep the size of source_receipt_proofs under control.\nIt limits the total sum of outgoing receipts, not individual receipts."), "reject_tx_congestion_threshold": z.number().describe("How much congestion a shard can tolerate before it stops all shards from\naccepting new transactions with the receiver set to the congested shard.") }).describe("The configuration for congestion control. More info about congestion [here](https://near.github.io/nearcore/architecture/how/receipt-congestion.html?highlight=congestion#receipt-congestion)")
export type CongestionControlConfigView = z.infer<typeof CongestionControlConfigView>


export const CongestionInfoView = z.object({ "allowed_shard": z.number().int().gte(0).lte(65535), "buffered_receipts_gas": z.string(), "delayed_receipts_gas": z.string(), "receipt_bytes": z.number().int().gte(0) }).describe("Stores the congestion level of a shard. More info about congestion [here](https://near.github.io/nearcore/architecture/how/receipt-congestion.html?highlight=congestion#receipt-congestion)")
export type CongestionInfoView = z.infer<typeof CongestionInfoView>


export const ContractCodeView = z.object({ "code_base64": z.string(), "hash": z.string() }).describe("A view of the contract code.")
export type ContractCodeView = z.infer<typeof ContractCodeView>


export const CostGasUsed = z.object({ "cost": z.string(), "cost_category": z.string().describe("Either ACTION_COST or WASM_HOST_COST."), "gas_used": z.string() }).describe("Shows gas profile. More info [here](https://near.github.io/nearcore/architecture/gas/gas_profile.html?highlight=WASM_HOST_COST#example-transaction-gas-profile).")
export type CostGasUsed = z.infer<typeof CostGasUsed>


export const CreateAccountAction = z.record(z.any()).describe("Create account action")
export type CreateAccountAction = z.infer<typeof CreateAccountAction>


export const CryptoHash = z.string()
export type CryptoHash = z.infer<typeof CryptoHash>


export const CurrentEpochValidatorInfo = z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "is_slashed": z.boolean(), "num_expected_blocks": z.number().int().gte(0), "num_expected_chunks": z.number().int().gte(0).default(0), "num_expected_chunks_per_shard": z.array(z.number().int().gte(0)).describe("Number of chunks this validator was expected to produce in each shard.\nEach entry in the array corresponds to the shard in the `shards_produced` array.").default([]), "num_expected_endorsements": z.number().int().gte(0).default(0), "num_expected_endorsements_per_shard": z.array(z.number().int().gte(0)).describe("Number of chunks this validator was expected to validate and endorse in each shard.\nEach entry in the array corresponds to the shard in the `shards_endorsed` array.").default([]), "num_produced_blocks": z.number().int().gte(0), "num_produced_chunks": z.number().int().gte(0).default(0), "num_produced_chunks_per_shard": z.array(z.number().int().gte(0)).default([]), "num_produced_endorsements": z.number().int().gte(0).default(0), "num_produced_endorsements_per_shard": z.array(z.number().int().gte(0)).default([]), "public_key": z.string(), "shards": z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")).describe("Shards this validator is assigned to as chunk producer in the current epoch."), "shards_endorsed": z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")).describe("Shards this validator is assigned to as chunk validator in the current epoch.").default([]), "stake": z.string() }).describe("Describes information about the current epoch validator")
export type CurrentEpochValidatorInfo = z.infer<typeof CurrentEpochValidatorInfo>


export const DataReceiptCreationConfigView = z.object({ "base_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of creating a data receipt.\nBoth `send` and `exec` costs are burned when a new receipt has input dependencies. The gas\nis charged for each input dependency. The dependencies are specified when a receipt is\ncreated using `promise_then` and `promise_batch_then`.\nNOTE: Any receipt with output dependencies will produce data receipts. Even if it fails.\nEven if the last action is not a function call (in case of success it will return empty\nvalue)."), "cost_per_byte": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Additional cost per byte sent.\nBoth `send` and `exec` costs are burned when a function call finishes execution and returns\n`N` bytes of data to every output dependency. For each output dependency the cost is\n`(send(sir) + exec()) * N`.") }).describe("The fees settings for a data receipt creation")
export type DataReceiptCreationConfigView = z.infer<typeof DataReceiptCreationConfigView>


export const DataReceiverView = z.object({ "data_id": z.string(), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") })
export type DataReceiverView = z.infer<typeof DataReceiverView>


export const DelegateAction = z.object({ "actions": z.array(z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CreateAccount": z.record(z.any()).describe("Create account action") }).strict().describe("Create an (sub)account using a transaction `receiver_id` as an ID for\na new account ID must pass validation rules described here\n<https://nomicon.io/DataStructures/Account>."), z.object({ "DeployContract": z.object({ "code": z.string().describe("WebAssembly binary") }).describe("Deploy contract action") }).strict().describe("Sets a Wasm code to a receiver_id"), z.object({ "FunctionCall": z.object({ "args": z.string(), "deposit": z.string(), "gas": z.number().int().gte(0), "method_name": z.string() }) }).strict(), z.object({ "Transfer": z.object({ "deposit": z.string() }) }).strict(), z.object({ "Stake": z.object({ "public_key": z.string().describe("Validator key which will be used to sign transactions on behalf of signer_id"), "stake": z.string().describe("Amount of tokens to stake.") }).describe("An action which stakes signer_id tokens and setup's validator public key") }).strict(), z.object({ "AddKey": z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0).describe("Nonce for this access key, used for tx nonce generation. When access key is created, nonce\nis set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\nSee <https://github.com/near/nearcore/issues/3779> for more details."), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Allowance is a balance limit to use by this access key to pay for function call gas and\ntransaction fees. When this access key is used, both account balance and the allowance is\ndecreased by the same value.\n`None` means unlimited allowance.\nNOTE: To change or increase the allowance, the old access key needs to be deleted and a new\naccess key should be created.").optional(), "method_names": z.array(z.string()).describe("A list of method names that can be used. The access key only allows transactions with the\nfunction call of one of the given method names.\nEmpty list means any method name can be used."), "receiver_id": z.string().describe("The access key only allows transactions with the given receiver's account id.") }).describe("Grants limited permission to make transactions with FunctionCallActions\nThe permission can limit the allowed balance to be spent on the prepaid gas.\nIt also restrict the account ID of the receiver for this function call.\nIt also can restrict the method name for the allowed function calls.") }).strict(), z.literal("FullAccess").describe("Grants full access to the account.\nNOTE: It's used to replace account-level public keys.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Defines permissions for AccessKey").describe("Defines permissions for this access key.") }).describe("Access key provides limited access to an account. Each access key belongs to some account and\nis identified by a unique (within the account) public key. One account may have large number of\naccess keys. Access keys allow to act on behalf of the account by restricting transactions\nthat can be issued.\n`account_id,public_key` is a key in the state").describe("An access key with the permission"), "public_key": z.string().describe("A public key which will be associated with an access_key") }).describe("An action that adds key with public key associated") }).strict(), z.object({ "DeleteKey": z.object({ "public_key": z.string().describe("A public key associated with the access_key to be deleted.") }) }).strict(), z.object({ "DeleteAccount": z.object({ "beneficiary_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeployGlobalContract": z.object({ "code": z.string().describe("WebAssembly binary"), "deploy_mode": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("CodeHash").describe("Contract is deployed under its code hash.\nUsers will be able reference it by that hash.\nThis effectively makes the contract immutable."), z.literal("AccountId").describe("Contract is deployed under the owner account id.\nUsers will be able reference it by that account id.\nThis allows the owner to update the contract for all its users.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Deploy global contract action") }).strict(), z.object({ "UseGlobalContract": z.object({ "contract_identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Use global contract action") }).strict(), z.object({ "DeterministicStateInit": z.object({ "deposit": z.string(), "state_init": z.object({ "V1": z.object({ "code": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "data": z.record(z.string()) }) }).strict() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An Action that can be included in a transaction or receipt, excluding delegate actions. This type represents all possible action types except DelegateAction to prevent infinite recursion in meta-transactions.")).describe("List of actions to be executed.\n\nWith the meta transactions MVP defined in NEP-366, nested\nDelegateActions are not allowed. A separate type is used to enforce it."), "max_block_height": z.number().int().gte(0).describe("The maximal height of the block in the blockchain below which the given DelegateAction is valid."), "nonce": z.number().int().gte(0).describe("Nonce to ensure that the same delegate action is not sent twice by a\nrelayer and should match for given account's `public_key`.\nAfter this action is processed it will increment."), "public_key": z.string().describe("Public key used to sign this delegated action."), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("Receiver of the delegated actions."), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("Signer of the delegated actions") }).describe("This action allows to execute the inner actions behalf of the defined sender.")
export type DelegateAction = z.infer<typeof DelegateAction>


export const DeleteAccountAction = z.object({ "beneficiary_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") })
export type DeleteAccountAction = z.infer<typeof DeleteAccountAction>


export const DeleteKeyAction = z.object({ "public_key": z.string().describe("A public key associated with the access_key to be deleted.") })
export type DeleteKeyAction = z.infer<typeof DeleteKeyAction>


export const DeployContractAction = z.object({ "code": z.string().describe("WebAssembly binary") }).describe("Deploy contract action")
export type DeployContractAction = z.infer<typeof DeployContractAction>


export const DeployGlobalContractAction = z.object({ "code": z.string().describe("WebAssembly binary"), "deploy_mode": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("CodeHash").describe("Contract is deployed under its code hash.\nUsers will be able reference it by that hash.\nThis effectively makes the contract immutable."), z.literal("AccountId").describe("Contract is deployed under the owner account id.\nUsers will be able reference it by that account id.\nThis allows the owner to update the contract for all its users.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Deploy global contract action")
export type DeployGlobalContractAction = z.infer<typeof DeployGlobalContractAction>


export const DetailedDebugStatus = z.object({ "block_production_delay_millis": z.number().int().gte(0), "catchup_status": z.array(z.object({ "blocks_to_catchup": z.array(z.object({ "hash": z.string(), "height": z.number().int().gte(0) }).describe("Height and hash of a block")), "shard_sync_status": z.record(z.union([z.string(), z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^\\d+$"))) {
evaluated = true
const result = z.string().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}), "sync_block_hash": z.string(), "sync_block_height": z.number().int().gte(0) }).describe("Status of the [catchup](https://near.github.io/nearcore/architecture/how/sync.html#catchup) process")), "current_head_status": z.object({ "hash": z.string(), "height": z.number().int().gte(0) }).describe("Height and hash of a block"), "current_header_head_status": z.object({ "hash": z.string(), "height": z.number().int().gte(0) }).describe("Height and hash of a block"), "network_info": z.object({ "connected_peers": z.array(z.object({ "account_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "addr": z.string(), "archival": z.boolean(), "block_hash": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "connection_established_time_millis": z.number().int().gte(0), "height": z.union([z.number().int().gte(0), z.null()]).optional(), "is_highest_block_invalid": z.boolean(), "is_outbound_peer": z.boolean(), "last_time_peer_requested_millis": z.number().int().gte(0), "last_time_received_message_millis": z.number().int().gte(0), "nonce": z.number().int().gte(0).describe("Connection nonce."), "peer_id": z.string(), "received_bytes_per_sec": z.number().int().gte(0), "sent_bytes_per_sec": z.number().int().gte(0), "tracked_shards": z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")) })), "known_producers": z.array(z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "next_hops": z.union([z.array(z.string()), z.null()]).optional(), "peer_id": z.string() }).describe("Information about a Producer: its account name, peer_id and a list of connected peers that\nthe node can use to send message for this producer.")), "num_connected_peers": z.number().int().gte(0), "peer_max_count": z.number().int().gte(0), "tier1_accounts_data": z.array(z.object({ "account_key": z.string().describe("Account key of the validator signing this AccountData."), "peer_id": z.string().describe("ID of the node that handles the account key (aka validator key)."), "proxies": z.array(z.object({ "addr": z.string(), "peer_id": z.string() })).describe("Proxy nodes that are directly connected to the validator node\n(this list may include the validator node itself).\nTIER1 nodes should connect to one of the proxies to sent TIER1\nmessages to the validator."), "timestamp": z.string().describe("UTC timestamp of when the AccountData has been signed.") }).describe("AccountData is a piece of global state that a validator\nsigns and broadcasts to the network.\n\nIt is essentially the data that a validator wants to share with the network.\nAll the nodes in the network are collecting the account data\nbroadcasted by the validators.\nSince the number of the validators is bounded and their\nidentity is known (and the maximal size of allowed AccountData is bounded)\nthe global state that is distributed in the form of AccountData is bounded\nas well.\nFind more information in the docs [here](https://github.com/near/nearcore/blob/560f7fc8f4b3106e0d5d46050688610b1f104ac6/chain/client/src/client.rs#L2232)")), "tier1_accounts_keys": z.array(z.string()), "tier1_connections": z.array(z.object({ "account_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "addr": z.string(), "archival": z.boolean(), "block_hash": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "connection_established_time_millis": z.number().int().gte(0), "height": z.union([z.number().int().gte(0), z.null()]).optional(), "is_highest_block_invalid": z.boolean(), "is_outbound_peer": z.boolean(), "last_time_peer_requested_millis": z.number().int().gte(0), "last_time_received_message_millis": z.number().int().gte(0), "nonce": z.number().int().gte(0).describe("Connection nonce."), "peer_id": z.string(), "received_bytes_per_sec": z.number().int().gte(0), "sent_bytes_per_sec": z.number().int().gte(0), "tracked_shards": z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")) })) }), "sync_status": z.string() })
export type DetailedDebugStatus = z.infer<typeof DetailedDebugStatus>


export const DeterministicAccountStateInit = z.object({ "V1": z.object({ "code": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "data": z.record(z.string()) }) }).strict()
export type DeterministicAccountStateInit = z.infer<typeof DeterministicAccountStateInit>


export const DeterministicAccountStateInitV1 = z.object({ "code": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "data": z.record(z.string()) })
export type DeterministicAccountStateInitV1 = z.infer<typeof DeterministicAccountStateInitV1>


export const DeterministicStateInitAction = z.object({ "deposit": z.string(), "state_init": z.object({ "V1": z.object({ "code": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "data": z.record(z.string()) }) }).strict() })
export type DeterministicStateInitAction = z.infer<typeof DeterministicStateInitAction>


export const Direction = z.enum(["Left","Right"])
export type Direction = z.infer<typeof Direction>


export const DumpConfig = z.object({ "credentials_file": z.union([z.string().describe("Location of a json file with credentials allowing access to the bucket."), z.null().describe("Location of a json file with credentials allowing access to the bucket.")]).describe("Location of a json file with credentials allowing access to the bucket.").optional(), "iteration_delay": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "nanos": z.number().int(), "secs": z.number().int() }), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("How often to check if a new epoch has started.\nFeel free to set to `None`, defaults are sensible.").optional(), "location": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "S3": z.object({ "bucket": z.string().describe("Location on S3."), "region": z.string().describe("Data may only be available in certain locations.") }) }).strict(), z.object({ "Filesystem": z.object({ "root_dir": z.string() }) }).strict().describe("Local filesystem root for storing data."), z.object({ "GCS": z.object({ "bucket": z.string() }) }).strict().describe("Google Cloud Storage bucket name.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Supported external storage backends and their minimal config.").describe("Specifies where to write the obtained state parts."), "restart_dump_for_shards": z.union([z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")).describe("Use in case a node that dumps state to the external storage\ngets in trouble."), z.null().describe("Use in case a node that dumps state to the external storage\ngets in trouble.")]).describe("Use in case a node that dumps state to the external storage\ngets in trouble.").optional() }).describe("Configures how to dump state to external storage.")
export type DumpConfig = z.infer<typeof DumpConfig>


export const DurationAsStdSchemaProvider = z.object({ "nanos": z.number().int(), "secs": z.number().int() })
export type DurationAsStdSchemaProvider = z.infer<typeof DurationAsStdSchemaProvider>


export const EpochId = z.string().describe("Epoch identifier -- wrapped hash, to make it easier to distinguish.\nEpochId of epoch T is the hash of last block in T-2\nEpochId of first two epochs is 0")
export type EpochId = z.infer<typeof EpochId>


export const EpochSyncConfig = z.object({ "disable_epoch_sync_for_bootstrapping": z.boolean().describe("If true, even if the node started from genesis, it will not perform epoch sync.\nThere should be no reason to set this flag in production, because on both mainnet\nand testnet it would be infeasible to catch up from genesis without epoch sync.").default(false), "epoch_sync_horizon": z.number().int().gte(0).describe("This serves as two purposes: (1) the node will not epoch sync and instead resort to\nheader sync, if the genesis block is within this many blocks from the current block;\n(2) the node will reject an epoch sync proof if the provided proof is for an epoch\nthat is more than this many blocks behind the current block."), "ignore_epoch_sync_network_requests": z.boolean().describe("If true, the node will ignore epoch sync requests from the network. It is strongly\nrecommended not to set this flag, because it will prevent other nodes from\nbootstrapping. This flag is only included as a kill-switch and may be removed in a\nfuture release. Please note that epoch sync requests are heavily rate limited and\ncached, and therefore should not affect the performance of the node or introduce\nany non-negligible increase in network traffic.").default(false), "timeout_for_epoch_sync": z.object({ "nanos": z.number().int(), "secs": z.number().int() }).describe("Timeout for epoch sync requests. The node will continue retrying indefinitely even\nif this timeout is exceeded.") })
export type EpochSyncConfig = z.infer<typeof EpochSyncConfig>


export const ExecutionMetadataView = z.object({ "gas_profile": z.union([z.array(z.object({ "cost": z.string(), "cost_category": z.string().describe("Either ACTION_COST or WASM_HOST_COST."), "gas_used": z.string() }).describe("Shows gas profile. More info [here](https://near.github.io/nearcore/architecture/gas/gas_profile.html?highlight=WASM_HOST_COST#example-transaction-gas-profile).")), z.null()]).optional(), "version": z.number().int().gte(0) })
export type ExecutionMetadataView = z.infer<typeof ExecutionMetadataView>


export const ExecutionOutcomeView = z.object({ "executor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("The id of the account on which the execution happens. For transaction this is signer_id,\nfor receipt this is receiver_id."), "gas_burnt": z.number().int().gte(0).describe("The amount of the gas burnt by the given transaction or receipt."), "logs": z.array(z.string()).describe("Logs from this transaction or receipt."), "metadata": z.object({ "gas_profile": z.union([z.array(z.object({ "cost": z.string(), "cost_category": z.string().describe("Either ACTION_COST or WASM_HOST_COST."), "gas_used": z.string() }).describe("Shows gas profile. More info [here](https://near.github.io/nearcore/architecture/gas/gas_profile.html?highlight=WASM_HOST_COST#example-transaction-gas-profile).")), z.null()]).optional(), "version": z.number().int().gte(0) }).describe("Execution metadata, versioned").default({"gas_profile":null,"version":1}), "receipt_ids": z.array(z.string()).describe("Receipt IDs generated by this transaction or receipt."), "status": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unknown").describe("The execution is pending or unknown."), z.object({ "Failure": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "ActionError": z.object({ "index": z.union([z.number().int().gte(0).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`"), z.null().describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`")]).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`").optional(), "kind": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccountAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage"), z.object({ "AccountDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when TX receiver_id doesn't exist (but action is not Action::CreateAccount)"), z.object({ "CreateAccountOnlyByRegistrar": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "registrar_account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A top-level account ID can only be created by registrar."), z.object({ "CreateAccountNotAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A newly created account must be under a namespace of the creator account"), z.object({ "ActorNoPermission": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "actor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\nor the first TX action is a `CreateAccount` action"), z.object({ "DeleteKeyDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("Account tries to remove an access key that doesn't exist"), z.object({ "AddKeyAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The public key is already used for an existing access key"), z.object({ "DeleteAccountStaking": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is staking and can not be deleted"), z.object({ "LackBalanceForState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which needs balance"), "amount": z.string().describe("Balance required to complete an action.") }) }).strict().describe("ActionReceipt can't be completed, because the remaining balance will not be enough to cover storage."), z.object({ "TriesToUnstake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is not yet staked, but tries to unstake"), z.object({ "TriesToStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "balance": z.string(), "locked": z.string(), "stake": z.string() }) }).strict().describe("The account doesn't have enough balance to increase the stake."), z.object({ "InsufficientStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "minimum_stake": z.string(), "stake": z.string() }) }).strict(), z.object({ "FunctionCallError": z.any().superRefine((x, ctx) => {
    const schemas = [z.enum(["WasmUnknownError","_EVMError"]), z.object({ "CompilationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "PrepareError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Serialization").describe("Error happened while serializing the module."), z.literal("Deserialization").describe("Error happened while deserializing the module."), z.literal("InternalMemoryDeclared").describe("Internal memory declaration has been found in the module."), z.literal("GasInstrumentation").describe("Gas instrumentation failed.\n\nThis most likely indicates the module isn't valid."), z.literal("StackHeightInstrumentation").describe("Stack instrumentation failed.\n\nThis  most likely indicates the module isn't valid."), z.literal("Instantiate").describe("Error happened during instantiation.\n\nThis might indicate that `start` function trapped, or module isn't\ninstantiable and/or un-linkable."), z.literal("Memory").describe("Error creating memory."), z.literal("TooManyFunctions").describe("Contract contains too many functions."), z.literal("TooManyLocals").describe("Contract contains too many locals."), z.literal("TooManyTables").describe("Contract contains too many tables."), z.literal("TooManyTableElements").describe("Contract contains too many table elements.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error that can occur while preparing or executing Wasm smart-contract.") }).strict(), z.object({ "WasmerCompileError": z.object({ "msg": z.string() }) }).strict().describe("This is for defense in depth.\nWe expect our runtime-independent preparation code to fully catch all invalid wasms,\nbut, if it ever misses something we’ll emit this error")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Wasm compilation error"), z.object({ "LinkError": z.object({ "msg": z.string() }) }).strict().describe("Wasm binary env link error\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "MethodResolveError": z.enum(["MethodEmptyName","MethodNotFound","MethodInvalidSignature"]) }).strict().describe("Import/export resolve error"), z.object({ "WasmTrap": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unreachable").describe("An `unreachable` opcode was executed."), z.literal("IncorrectCallIndirectSignature").describe("Call indirect incorrect signature trap."), z.literal("MemoryOutOfBounds").describe("Memory out of bounds trap."), z.literal("CallIndirectOOB").describe("Call indirect out of bounds trap."), z.literal("IllegalArithmetic").describe("An arithmetic exception, e.g. divided by zero."), z.literal("MisalignedAtomicAccess").describe("Misaligned atomic access trap."), z.literal("IndirectCallToNull").describe("Indirect call to null."), z.literal("StackOverflow").describe("Stack overflow."), z.literal("GenericTrap").describe("Generic trap.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("A kind of a trap happened during execution of a binary") }).strict().describe("A trap happened during execution of a binary\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "HostError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("BadUTF16").describe("String encoding is bad UTF-16 sequence"), z.literal("BadUTF8").describe("String encoding is bad UTF-8 sequence"), z.literal("GasExceeded").describe("Exceeded the prepaid gas"), z.literal("GasLimitExceeded").describe("Exceeded the maximum amount of gas allowed to burn per contract"), z.literal("BalanceExceeded").describe("Exceeded the account balance"), z.literal("EmptyMethodName").describe("Tried to call an empty method name"), z.object({ "GuestPanic": z.object({ "panic_msg": z.string() }) }).strict().describe("Smart contract panicked"), z.literal("IntegerOverflow").describe("IntegerOverflow happened during a contract execution"), z.object({ "InvalidPromiseIndex": z.object({ "promise_idx": z.number().int().gte(0) }) }).strict().describe("`promise_idx` does not correspond to existing promises"), z.literal("CannotAppendActionToJointPromise").describe("Actions can only be appended to non-joint promise."), z.literal("CannotReturnJointPromise").describe("Returning joint promise is currently prohibited"), z.object({ "InvalidPromiseResultIndex": z.object({ "result_idx": z.number().int().gte(0) }) }).strict().describe("Accessed invalid promise result index"), z.object({ "InvalidRegisterId": z.object({ "register_id": z.number().int().gte(0) }) }).strict().describe("Accessed invalid register id"), z.object({ "IteratorWasInvalidated": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie"), z.literal("MemoryAccessViolation").describe("Accessed memory outside the bounds"), z.object({ "InvalidReceiptIndex": z.object({ "receipt_index": z.number().int().gte(0) }) }).strict().describe("VM Logic returned an invalid receipt index"), z.object({ "InvalidIteratorIndex": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator index `iterator_index` does not exist"), z.literal("InvalidAccountId").describe("VM Logic returned an invalid account id"), z.literal("InvalidMethodName").describe("VM Logic returned an invalid method name"), z.literal("InvalidPublicKey").describe("VM Logic provided an invalid public key"), z.object({ "ProhibitedInView": z.object({ "method_name": z.string() }) }).strict().describe("`method_name` is not allowed in view calls"), z.object({ "NumberOfLogsExceeded": z.object({ "limit": z.number().int().gte(0) }) }).strict().describe("The total number of logs will exceed the limit."), z.object({ "KeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage key length exceeded the limit."), z.object({ "ValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage value length exceeded the limit."), z.object({ "TotalLogLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The total log length exceeded the limit."), z.object({ "NumberPromisesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_promises": z.number().int().gte(0) }) }).strict().describe("The maximum number of promises within a FunctionCall exceeded the limit."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The maximum number of input data dependencies exceeded the limit."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The returned value length exceeded the limit."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The contract size for DeployContract action exceeded the limit."), z.object({ "Deprecated": z.object({ "method_name": z.string() }) }).strict().describe("The host function was deprecated."), z.object({ "ECRecoverError": z.object({ "msg": z.string() }) }).strict().describe("General errors for ECDSA recover."), z.object({ "AltBn128InvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to alt_bn128 family of functions (e.g., point which isn't\non the curve)."), z.object({ "Ed25519VerifyInvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to ed25519 signature verification function (e.g. signature cannot be\nderived from bytes).")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Note: this is only to deserialize old data, use execution error for new data"), z.object({ "ExecutionError": z.string() }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Serializable version of `near-vm-runner::FunctionCallError`.\n\nMust never reorder/remove elements, can only add new variants at the end (but do that very\ncarefully). It describes stable serialization format, and only used by serialization logic.") }).strict().describe("An error occurred during a `FunctionCall` Action, parameter is debug message."), z.object({ "NewReceiptValidationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidPredecessorId": z.object({ "account_id": z.string() }) }).strict().describe("The `predecessor_id` of a Receipt is not valid."), z.object({ "InvalidReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a Receipt is not valid."), z.object({ "InvalidSignerId": z.object({ "account_id": z.string() }) }).strict().describe("The `signer_id` of an ActionReceipt is not valid."), z.object({ "InvalidDataReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a DataReceiver within an ActionReceipt is not valid."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the returned data exceeded the limit in a DataReceipt."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The number of input data dependencies exceeds the limit in an ActionReceipt."), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of an ActionReceipt."), z.object({ "ReceiptSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("Receipt is bigger than the limit."), z.object({ "InvalidRefundTo": z.object({ "account_id": z.string() }) }).strict().describe("The `refund_to` of an ActionReceipt is not valid.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a receipt.") }).strict().describe("Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\nreceipt validation."), z.object({ "OnlyImplicitAccountCreationAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\nSee NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\nAlso, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\nTODO(#8598): This error is named very poorly. A better name would be\n`OnlyNamedAccountCreationAllowed`."), z.object({ "DeleteAccountWithLargeState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Delete account whose state is large is temporarily banned."), z.literal("DelegateActionInvalidSignature").describe("Signature does not match the provided actions and given signer public key."), z.object({ "DelegateActionSenderDoesNotMatchTxReceiver": z.object({ "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Receiver of the transaction doesn't match Sender of the delegate action"), z.literal("DelegateActionExpired").describe("Delegate action has expired. `max_block_height` is less than actual block height."), z.object({ "DelegateActionAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("The given public key doesn't exist for Sender account"), z.object({ "DelegateActionInvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "delegate_nonce": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce must be greater sender[public_key].nonce"), z.object({ "DelegateActionNonceTooLarge": z.object({ "delegate_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce is larger than the upper bound given by the block height"), z.object({ "GlobalContractDoesNotExist": z.object({ "identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("The kind of ActionError happened") }).describe("An error happened during Action execution") }).strict().describe("An error happened during Action execution"), z.object({ "InvalidTxError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Happens if a wrong AccessKey used or AccessKey has not enough permissions"), z.object({ "InvalidSignerId": z.object({ "signer_id": z.string() }) }).strict().describe("TX signer_id is not a valid [`AccountId`]"), z.object({ "SignerDoesNotExist": z.object({ "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("TX signer_id is not found in a storage"), z.object({ "InvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "tx_nonce": z.number().int().gte(0) }) }).strict().describe("Transaction nonce must be strictly greater than `account[access_key].nonce`."), z.object({ "NonceTooLarge": z.object({ "tx_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("Transaction nonce is larger than the upper bound given by the block height"), z.object({ "InvalidReceiverId": z.object({ "receiver_id": z.string() }) }).strict().describe("TX receiver_id is not a valid AccountId"), z.literal("InvalidSignature").describe("TX signature is not valid"), z.object({ "NotEnoughBalance": z.object({ "balance": z.string(), "cost": z.string(), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account does not have enough balance to cover TX cost"), z.object({ "LackBalanceForState": z.object({ "amount": z.string().describe("Required balance to cover the state."), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which doesn't have enough balance to cover storage.") }) }).strict().describe("Signer account doesn't have enough balance after transaction."), z.literal("CostOverflow").describe("An integer overflow occurred during transaction cost estimation."), z.literal("InvalidChain").describe("Transaction parent block hash doesn't belong to the current chain"), z.literal("Expired").describe("Transaction has expired"), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of a Transaction."), z.object({ "TransactionSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of serialized transaction exceeded the limit."), z.literal("InvalidTransactionVersion").describe("Transaction version is invalid."), z.object({ "StorageError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("StorageInternalError").describe("Key-value db internal failure"), z.object({ "MissingTrieValue": z.object({ "context": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("TrieIterator").describe("Missing trie value when reading from TrieIterator."), z.literal("TriePrefetchingStorage").describe("Missing trie value when reading from TriePrefetchingStorage."), z.literal("TrieMemoryPartialStorage").describe("Missing trie value when reading from TrieMemoryPartialStorage."), z.literal("TrieStorage").describe("Missing trie value when reading from TrieStorage.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Contexts in which `StorageError::MissingTrieValue` error might occur."), "hash": z.string() }) }).strict().describe("Requested trie value by its hash which is missing in storage."), z.literal("UnexpectedTrieValue").describe("Found trie node which shouldn't be part of state. Raised during\nvalidation of state sync parts where incorrect node was passed.\nTODO (#8997): consider including hash of trie node."), z.object({ "StorageInconsistentState": z.string() }).strict().describe("Either invalid state or key-value db is corrupted.\nFor PartialStorage it cannot be corrupted.\nError message is unreliable and for debugging purposes only. It's also probably ok to\npanic in every place that produces this error.\nWe can check if db is corrupted by verifying everything in the state trie."), z.object({ "FlatStorageBlockNotSupported": z.string() }).strict().describe("Flat storage error, meaning that it doesn't support some block anymore.\nWe guarantee that such block cannot become final, thus block processing\nmust resume normally."), z.object({ "MemTrieLoadingError": z.string() }).strict().describe("In-memory trie could not be loaded for some reason.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Errors which may occur during working with trie storages, storing\ntrie values (trie nodes and state values) by their hashes.") }).strict(), z.object({ "ShardCongested": z.object({ "congestion_level": z.number().describe("A value between 0 (no congestion) and 1 (max congestion)."), "shard_id": z.number().int().gte(0).describe("The congested shard.") }) }).strict().describe("The receiver shard of the transaction is too congested to accept new\ntransactions at the moment."), z.object({ "ShardStuck": z.object({ "missed_chunks": z.number().int().gte(0).describe("The number of blocks since the last included chunk of the shard."), "shard_id": z.number().int().gte(0).describe("The shard that fails making progress.") }) }).strict().describe("The receiver shard of the transaction missed several chunks and rejects\nnew transaction until it can make progress again.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An error happened during TX execution") }).strict().describe("An error happened during Transaction execution")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error returned in the ExecutionOutcome in case of failure") }).strict().describe("The execution has failed."), z.object({ "SuccessValue": z.string() }).strict().describe("The final action succeeded and returned some value or an empty vec encoded in base64."), z.object({ "SuccessReceiptId": z.string() }).strict().describe("The final action of the receipt returned a promise or the signed transaction was converted\nto a receipt. Contains the receipt_id of the generated receipt.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Execution status. Contains the result in case of successful execution."), "tokens_burnt": z.string().describe("The amount of tokens burnt corresponding to the burnt gas amount.\nThis value doesn't always equal to the `gas_burnt` multiplied by the gas price, because\nthe prepaid gas price might be lower than the actual gas price and it creates a deficit.\n`tokens_burnt` also contains the penalty subtracted from refunds, while\n`gas_burnt` only contains the gas that we actually burn for the execution.") })
export type ExecutionOutcomeView = z.infer<typeof ExecutionOutcomeView>


export const ExecutionOutcomeWithIdView = z.object({ "block_hash": z.string(), "id": z.string(), "outcome": z.object({ "executor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("The id of the account on which the execution happens. For transaction this is signer_id,\nfor receipt this is receiver_id."), "gas_burnt": z.number().int().gte(0).describe("The amount of the gas burnt by the given transaction or receipt."), "logs": z.array(z.string()).describe("Logs from this transaction or receipt."), "metadata": z.object({ "gas_profile": z.union([z.array(z.object({ "cost": z.string(), "cost_category": z.string().describe("Either ACTION_COST or WASM_HOST_COST."), "gas_used": z.string() }).describe("Shows gas profile. More info [here](https://near.github.io/nearcore/architecture/gas/gas_profile.html?highlight=WASM_HOST_COST#example-transaction-gas-profile).")), z.null()]).optional(), "version": z.number().int().gte(0) }).describe("Execution metadata, versioned").default({"gas_profile":null,"version":1}), "receipt_ids": z.array(z.string()).describe("Receipt IDs generated by this transaction or receipt."), "status": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unknown").describe("The execution is pending or unknown."), z.object({ "Failure": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "ActionError": z.object({ "index": z.union([z.number().int().gte(0).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`"), z.null().describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`")]).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`").optional(), "kind": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccountAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage"), z.object({ "AccountDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when TX receiver_id doesn't exist (but action is not Action::CreateAccount)"), z.object({ "CreateAccountOnlyByRegistrar": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "registrar_account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A top-level account ID can only be created by registrar."), z.object({ "CreateAccountNotAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A newly created account must be under a namespace of the creator account"), z.object({ "ActorNoPermission": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "actor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\nor the first TX action is a `CreateAccount` action"), z.object({ "DeleteKeyDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("Account tries to remove an access key that doesn't exist"), z.object({ "AddKeyAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The public key is already used for an existing access key"), z.object({ "DeleteAccountStaking": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is staking and can not be deleted"), z.object({ "LackBalanceForState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which needs balance"), "amount": z.string().describe("Balance required to complete an action.") }) }).strict().describe("ActionReceipt can't be completed, because the remaining balance will not be enough to cover storage."), z.object({ "TriesToUnstake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is not yet staked, but tries to unstake"), z.object({ "TriesToStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "balance": z.string(), "locked": z.string(), "stake": z.string() }) }).strict().describe("The account doesn't have enough balance to increase the stake."), z.object({ "InsufficientStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "minimum_stake": z.string(), "stake": z.string() }) }).strict(), z.object({ "FunctionCallError": z.any().superRefine((x, ctx) => {
    const schemas = [z.enum(["WasmUnknownError","_EVMError"]), z.object({ "CompilationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "PrepareError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Serialization").describe("Error happened while serializing the module."), z.literal("Deserialization").describe("Error happened while deserializing the module."), z.literal("InternalMemoryDeclared").describe("Internal memory declaration has been found in the module."), z.literal("GasInstrumentation").describe("Gas instrumentation failed.\n\nThis most likely indicates the module isn't valid."), z.literal("StackHeightInstrumentation").describe("Stack instrumentation failed.\n\nThis  most likely indicates the module isn't valid."), z.literal("Instantiate").describe("Error happened during instantiation.\n\nThis might indicate that `start` function trapped, or module isn't\ninstantiable and/or un-linkable."), z.literal("Memory").describe("Error creating memory."), z.literal("TooManyFunctions").describe("Contract contains too many functions."), z.literal("TooManyLocals").describe("Contract contains too many locals."), z.literal("TooManyTables").describe("Contract contains too many tables."), z.literal("TooManyTableElements").describe("Contract contains too many table elements.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error that can occur while preparing or executing Wasm smart-contract.") }).strict(), z.object({ "WasmerCompileError": z.object({ "msg": z.string() }) }).strict().describe("This is for defense in depth.\nWe expect our runtime-independent preparation code to fully catch all invalid wasms,\nbut, if it ever misses something we’ll emit this error")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Wasm compilation error"), z.object({ "LinkError": z.object({ "msg": z.string() }) }).strict().describe("Wasm binary env link error\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "MethodResolveError": z.enum(["MethodEmptyName","MethodNotFound","MethodInvalidSignature"]) }).strict().describe("Import/export resolve error"), z.object({ "WasmTrap": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unreachable").describe("An `unreachable` opcode was executed."), z.literal("IncorrectCallIndirectSignature").describe("Call indirect incorrect signature trap."), z.literal("MemoryOutOfBounds").describe("Memory out of bounds trap."), z.literal("CallIndirectOOB").describe("Call indirect out of bounds trap."), z.literal("IllegalArithmetic").describe("An arithmetic exception, e.g. divided by zero."), z.literal("MisalignedAtomicAccess").describe("Misaligned atomic access trap."), z.literal("IndirectCallToNull").describe("Indirect call to null."), z.literal("StackOverflow").describe("Stack overflow."), z.literal("GenericTrap").describe("Generic trap.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("A kind of a trap happened during execution of a binary") }).strict().describe("A trap happened during execution of a binary\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "HostError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("BadUTF16").describe("String encoding is bad UTF-16 sequence"), z.literal("BadUTF8").describe("String encoding is bad UTF-8 sequence"), z.literal("GasExceeded").describe("Exceeded the prepaid gas"), z.literal("GasLimitExceeded").describe("Exceeded the maximum amount of gas allowed to burn per contract"), z.literal("BalanceExceeded").describe("Exceeded the account balance"), z.literal("EmptyMethodName").describe("Tried to call an empty method name"), z.object({ "GuestPanic": z.object({ "panic_msg": z.string() }) }).strict().describe("Smart contract panicked"), z.literal("IntegerOverflow").describe("IntegerOverflow happened during a contract execution"), z.object({ "InvalidPromiseIndex": z.object({ "promise_idx": z.number().int().gte(0) }) }).strict().describe("`promise_idx` does not correspond to existing promises"), z.literal("CannotAppendActionToJointPromise").describe("Actions can only be appended to non-joint promise."), z.literal("CannotReturnJointPromise").describe("Returning joint promise is currently prohibited"), z.object({ "InvalidPromiseResultIndex": z.object({ "result_idx": z.number().int().gte(0) }) }).strict().describe("Accessed invalid promise result index"), z.object({ "InvalidRegisterId": z.object({ "register_id": z.number().int().gte(0) }) }).strict().describe("Accessed invalid register id"), z.object({ "IteratorWasInvalidated": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie"), z.literal("MemoryAccessViolation").describe("Accessed memory outside the bounds"), z.object({ "InvalidReceiptIndex": z.object({ "receipt_index": z.number().int().gte(0) }) }).strict().describe("VM Logic returned an invalid receipt index"), z.object({ "InvalidIteratorIndex": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator index `iterator_index` does not exist"), z.literal("InvalidAccountId").describe("VM Logic returned an invalid account id"), z.literal("InvalidMethodName").describe("VM Logic returned an invalid method name"), z.literal("InvalidPublicKey").describe("VM Logic provided an invalid public key"), z.object({ "ProhibitedInView": z.object({ "method_name": z.string() }) }).strict().describe("`method_name` is not allowed in view calls"), z.object({ "NumberOfLogsExceeded": z.object({ "limit": z.number().int().gte(0) }) }).strict().describe("The total number of logs will exceed the limit."), z.object({ "KeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage key length exceeded the limit."), z.object({ "ValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage value length exceeded the limit."), z.object({ "TotalLogLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The total log length exceeded the limit."), z.object({ "NumberPromisesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_promises": z.number().int().gte(0) }) }).strict().describe("The maximum number of promises within a FunctionCall exceeded the limit."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The maximum number of input data dependencies exceeded the limit."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The returned value length exceeded the limit."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The contract size for DeployContract action exceeded the limit."), z.object({ "Deprecated": z.object({ "method_name": z.string() }) }).strict().describe("The host function was deprecated."), z.object({ "ECRecoverError": z.object({ "msg": z.string() }) }).strict().describe("General errors for ECDSA recover."), z.object({ "AltBn128InvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to alt_bn128 family of functions (e.g., point which isn't\non the curve)."), z.object({ "Ed25519VerifyInvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to ed25519 signature verification function (e.g. signature cannot be\nderived from bytes).")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Note: this is only to deserialize old data, use execution error for new data"), z.object({ "ExecutionError": z.string() }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Serializable version of `near-vm-runner::FunctionCallError`.\n\nMust never reorder/remove elements, can only add new variants at the end (but do that very\ncarefully). It describes stable serialization format, and only used by serialization logic.") }).strict().describe("An error occurred during a `FunctionCall` Action, parameter is debug message."), z.object({ "NewReceiptValidationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidPredecessorId": z.object({ "account_id": z.string() }) }).strict().describe("The `predecessor_id` of a Receipt is not valid."), z.object({ "InvalidReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a Receipt is not valid."), z.object({ "InvalidSignerId": z.object({ "account_id": z.string() }) }).strict().describe("The `signer_id` of an ActionReceipt is not valid."), z.object({ "InvalidDataReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a DataReceiver within an ActionReceipt is not valid."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the returned data exceeded the limit in a DataReceipt."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The number of input data dependencies exceeds the limit in an ActionReceipt."), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of an ActionReceipt."), z.object({ "ReceiptSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("Receipt is bigger than the limit."), z.object({ "InvalidRefundTo": z.object({ "account_id": z.string() }) }).strict().describe("The `refund_to` of an ActionReceipt is not valid.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a receipt.") }).strict().describe("Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\nreceipt validation."), z.object({ "OnlyImplicitAccountCreationAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\nSee NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\nAlso, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\nTODO(#8598): This error is named very poorly. A better name would be\n`OnlyNamedAccountCreationAllowed`."), z.object({ "DeleteAccountWithLargeState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Delete account whose state is large is temporarily banned."), z.literal("DelegateActionInvalidSignature").describe("Signature does not match the provided actions and given signer public key."), z.object({ "DelegateActionSenderDoesNotMatchTxReceiver": z.object({ "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Receiver of the transaction doesn't match Sender of the delegate action"), z.literal("DelegateActionExpired").describe("Delegate action has expired. `max_block_height` is less than actual block height."), z.object({ "DelegateActionAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("The given public key doesn't exist for Sender account"), z.object({ "DelegateActionInvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "delegate_nonce": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce must be greater sender[public_key].nonce"), z.object({ "DelegateActionNonceTooLarge": z.object({ "delegate_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce is larger than the upper bound given by the block height"), z.object({ "GlobalContractDoesNotExist": z.object({ "identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("The kind of ActionError happened") }).describe("An error happened during Action execution") }).strict().describe("An error happened during Action execution"), z.object({ "InvalidTxError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Happens if a wrong AccessKey used or AccessKey has not enough permissions"), z.object({ "InvalidSignerId": z.object({ "signer_id": z.string() }) }).strict().describe("TX signer_id is not a valid [`AccountId`]"), z.object({ "SignerDoesNotExist": z.object({ "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("TX signer_id is not found in a storage"), z.object({ "InvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "tx_nonce": z.number().int().gte(0) }) }).strict().describe("Transaction nonce must be strictly greater than `account[access_key].nonce`."), z.object({ "NonceTooLarge": z.object({ "tx_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("Transaction nonce is larger than the upper bound given by the block height"), z.object({ "InvalidReceiverId": z.object({ "receiver_id": z.string() }) }).strict().describe("TX receiver_id is not a valid AccountId"), z.literal("InvalidSignature").describe("TX signature is not valid"), z.object({ "NotEnoughBalance": z.object({ "balance": z.string(), "cost": z.string(), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account does not have enough balance to cover TX cost"), z.object({ "LackBalanceForState": z.object({ "amount": z.string().describe("Required balance to cover the state."), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which doesn't have enough balance to cover storage.") }) }).strict().describe("Signer account doesn't have enough balance after transaction."), z.literal("CostOverflow").describe("An integer overflow occurred during transaction cost estimation."), z.literal("InvalidChain").describe("Transaction parent block hash doesn't belong to the current chain"), z.literal("Expired").describe("Transaction has expired"), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of a Transaction."), z.object({ "TransactionSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of serialized transaction exceeded the limit."), z.literal("InvalidTransactionVersion").describe("Transaction version is invalid."), z.object({ "StorageError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("StorageInternalError").describe("Key-value db internal failure"), z.object({ "MissingTrieValue": z.object({ "context": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("TrieIterator").describe("Missing trie value when reading from TrieIterator."), z.literal("TriePrefetchingStorage").describe("Missing trie value when reading from TriePrefetchingStorage."), z.literal("TrieMemoryPartialStorage").describe("Missing trie value when reading from TrieMemoryPartialStorage."), z.literal("TrieStorage").describe("Missing trie value when reading from TrieStorage.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Contexts in which `StorageError::MissingTrieValue` error might occur."), "hash": z.string() }) }).strict().describe("Requested trie value by its hash which is missing in storage."), z.literal("UnexpectedTrieValue").describe("Found trie node which shouldn't be part of state. Raised during\nvalidation of state sync parts where incorrect node was passed.\nTODO (#8997): consider including hash of trie node."), z.object({ "StorageInconsistentState": z.string() }).strict().describe("Either invalid state or key-value db is corrupted.\nFor PartialStorage it cannot be corrupted.\nError message is unreliable and for debugging purposes only. It's also probably ok to\npanic in every place that produces this error.\nWe can check if db is corrupted by verifying everything in the state trie."), z.object({ "FlatStorageBlockNotSupported": z.string() }).strict().describe("Flat storage error, meaning that it doesn't support some block anymore.\nWe guarantee that such block cannot become final, thus block processing\nmust resume normally."), z.object({ "MemTrieLoadingError": z.string() }).strict().describe("In-memory trie could not be loaded for some reason.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Errors which may occur during working with trie storages, storing\ntrie values (trie nodes and state values) by their hashes.") }).strict(), z.object({ "ShardCongested": z.object({ "congestion_level": z.number().describe("A value between 0 (no congestion) and 1 (max congestion)."), "shard_id": z.number().int().gte(0).describe("The congested shard.") }) }).strict().describe("The receiver shard of the transaction is too congested to accept new\ntransactions at the moment."), z.object({ "ShardStuck": z.object({ "missed_chunks": z.number().int().gte(0).describe("The number of blocks since the last included chunk of the shard."), "shard_id": z.number().int().gte(0).describe("The shard that fails making progress.") }) }).strict().describe("The receiver shard of the transaction missed several chunks and rejects\nnew transaction until it can make progress again.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An error happened during TX execution") }).strict().describe("An error happened during Transaction execution")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error returned in the ExecutionOutcome in case of failure") }).strict().describe("The execution has failed."), z.object({ "SuccessValue": z.string() }).strict().describe("The final action succeeded and returned some value or an empty vec encoded in base64."), z.object({ "SuccessReceiptId": z.string() }).strict().describe("The final action of the receipt returned a promise or the signed transaction was converted\nto a receipt. Contains the receipt_id of the generated receipt.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Execution status. Contains the result in case of successful execution."), "tokens_burnt": z.string().describe("The amount of tokens burnt corresponding to the burnt gas amount.\nThis value doesn't always equal to the `gas_burnt` multiplied by the gas price, because\nthe prepaid gas price might be lower than the actual gas price and it creates a deficit.\n`tokens_burnt` also contains the penalty subtracted from refunds, while\n`gas_burnt` only contains the gas that we actually burn for the execution.") }), "proof": z.array(z.object({ "direction": z.enum(["Left","Right"]), "hash": z.string() })) })
export type ExecutionOutcomeWithIdView = z.infer<typeof ExecutionOutcomeWithIdView>


export const ExecutionStatusView = z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unknown").describe("The execution is pending or unknown."), z.object({ "Failure": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "ActionError": z.object({ "index": z.union([z.number().int().gte(0).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`"), z.null().describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`")]).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`").optional(), "kind": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccountAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage"), z.object({ "AccountDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when TX receiver_id doesn't exist (but action is not Action::CreateAccount)"), z.object({ "CreateAccountOnlyByRegistrar": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "registrar_account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A top-level account ID can only be created by registrar."), z.object({ "CreateAccountNotAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A newly created account must be under a namespace of the creator account"), z.object({ "ActorNoPermission": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "actor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\nor the first TX action is a `CreateAccount` action"), z.object({ "DeleteKeyDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("Account tries to remove an access key that doesn't exist"), z.object({ "AddKeyAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The public key is already used for an existing access key"), z.object({ "DeleteAccountStaking": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is staking and can not be deleted"), z.object({ "LackBalanceForState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which needs balance"), "amount": z.string().describe("Balance required to complete an action.") }) }).strict().describe("ActionReceipt can't be completed, because the remaining balance will not be enough to cover storage."), z.object({ "TriesToUnstake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is not yet staked, but tries to unstake"), z.object({ "TriesToStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "balance": z.string(), "locked": z.string(), "stake": z.string() }) }).strict().describe("The account doesn't have enough balance to increase the stake."), z.object({ "InsufficientStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "minimum_stake": z.string(), "stake": z.string() }) }).strict(), z.object({ "FunctionCallError": z.any().superRefine((x, ctx) => {
    const schemas = [z.enum(["WasmUnknownError","_EVMError"]), z.object({ "CompilationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "PrepareError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Serialization").describe("Error happened while serializing the module."), z.literal("Deserialization").describe("Error happened while deserializing the module."), z.literal("InternalMemoryDeclared").describe("Internal memory declaration has been found in the module."), z.literal("GasInstrumentation").describe("Gas instrumentation failed.\n\nThis most likely indicates the module isn't valid."), z.literal("StackHeightInstrumentation").describe("Stack instrumentation failed.\n\nThis  most likely indicates the module isn't valid."), z.literal("Instantiate").describe("Error happened during instantiation.\n\nThis might indicate that `start` function trapped, or module isn't\ninstantiable and/or un-linkable."), z.literal("Memory").describe("Error creating memory."), z.literal("TooManyFunctions").describe("Contract contains too many functions."), z.literal("TooManyLocals").describe("Contract contains too many locals."), z.literal("TooManyTables").describe("Contract contains too many tables."), z.literal("TooManyTableElements").describe("Contract contains too many table elements.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error that can occur while preparing or executing Wasm smart-contract.") }).strict(), z.object({ "WasmerCompileError": z.object({ "msg": z.string() }) }).strict().describe("This is for defense in depth.\nWe expect our runtime-independent preparation code to fully catch all invalid wasms,\nbut, if it ever misses something we’ll emit this error")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Wasm compilation error"), z.object({ "LinkError": z.object({ "msg": z.string() }) }).strict().describe("Wasm binary env link error\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "MethodResolveError": z.enum(["MethodEmptyName","MethodNotFound","MethodInvalidSignature"]) }).strict().describe("Import/export resolve error"), z.object({ "WasmTrap": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unreachable").describe("An `unreachable` opcode was executed."), z.literal("IncorrectCallIndirectSignature").describe("Call indirect incorrect signature trap."), z.literal("MemoryOutOfBounds").describe("Memory out of bounds trap."), z.literal("CallIndirectOOB").describe("Call indirect out of bounds trap."), z.literal("IllegalArithmetic").describe("An arithmetic exception, e.g. divided by zero."), z.literal("MisalignedAtomicAccess").describe("Misaligned atomic access trap."), z.literal("IndirectCallToNull").describe("Indirect call to null."), z.literal("StackOverflow").describe("Stack overflow."), z.literal("GenericTrap").describe("Generic trap.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("A kind of a trap happened during execution of a binary") }).strict().describe("A trap happened during execution of a binary\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "HostError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("BadUTF16").describe("String encoding is bad UTF-16 sequence"), z.literal("BadUTF8").describe("String encoding is bad UTF-8 sequence"), z.literal("GasExceeded").describe("Exceeded the prepaid gas"), z.literal("GasLimitExceeded").describe("Exceeded the maximum amount of gas allowed to burn per contract"), z.literal("BalanceExceeded").describe("Exceeded the account balance"), z.literal("EmptyMethodName").describe("Tried to call an empty method name"), z.object({ "GuestPanic": z.object({ "panic_msg": z.string() }) }).strict().describe("Smart contract panicked"), z.literal("IntegerOverflow").describe("IntegerOverflow happened during a contract execution"), z.object({ "InvalidPromiseIndex": z.object({ "promise_idx": z.number().int().gte(0) }) }).strict().describe("`promise_idx` does not correspond to existing promises"), z.literal("CannotAppendActionToJointPromise").describe("Actions can only be appended to non-joint promise."), z.literal("CannotReturnJointPromise").describe("Returning joint promise is currently prohibited"), z.object({ "InvalidPromiseResultIndex": z.object({ "result_idx": z.number().int().gte(0) }) }).strict().describe("Accessed invalid promise result index"), z.object({ "InvalidRegisterId": z.object({ "register_id": z.number().int().gte(0) }) }).strict().describe("Accessed invalid register id"), z.object({ "IteratorWasInvalidated": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie"), z.literal("MemoryAccessViolation").describe("Accessed memory outside the bounds"), z.object({ "InvalidReceiptIndex": z.object({ "receipt_index": z.number().int().gte(0) }) }).strict().describe("VM Logic returned an invalid receipt index"), z.object({ "InvalidIteratorIndex": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator index `iterator_index` does not exist"), z.literal("InvalidAccountId").describe("VM Logic returned an invalid account id"), z.literal("InvalidMethodName").describe("VM Logic returned an invalid method name"), z.literal("InvalidPublicKey").describe("VM Logic provided an invalid public key"), z.object({ "ProhibitedInView": z.object({ "method_name": z.string() }) }).strict().describe("`method_name` is not allowed in view calls"), z.object({ "NumberOfLogsExceeded": z.object({ "limit": z.number().int().gte(0) }) }).strict().describe("The total number of logs will exceed the limit."), z.object({ "KeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage key length exceeded the limit."), z.object({ "ValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage value length exceeded the limit."), z.object({ "TotalLogLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The total log length exceeded the limit."), z.object({ "NumberPromisesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_promises": z.number().int().gte(0) }) }).strict().describe("The maximum number of promises within a FunctionCall exceeded the limit."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The maximum number of input data dependencies exceeded the limit."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The returned value length exceeded the limit."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The contract size for DeployContract action exceeded the limit."), z.object({ "Deprecated": z.object({ "method_name": z.string() }) }).strict().describe("The host function was deprecated."), z.object({ "ECRecoverError": z.object({ "msg": z.string() }) }).strict().describe("General errors for ECDSA recover."), z.object({ "AltBn128InvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to alt_bn128 family of functions (e.g., point which isn't\non the curve)."), z.object({ "Ed25519VerifyInvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to ed25519 signature verification function (e.g. signature cannot be\nderived from bytes).")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Note: this is only to deserialize old data, use execution error for new data"), z.object({ "ExecutionError": z.string() }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Serializable version of `near-vm-runner::FunctionCallError`.\n\nMust never reorder/remove elements, can only add new variants at the end (but do that very\ncarefully). It describes stable serialization format, and only used by serialization logic.") }).strict().describe("An error occurred during a `FunctionCall` Action, parameter is debug message."), z.object({ "NewReceiptValidationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidPredecessorId": z.object({ "account_id": z.string() }) }).strict().describe("The `predecessor_id` of a Receipt is not valid."), z.object({ "InvalidReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a Receipt is not valid."), z.object({ "InvalidSignerId": z.object({ "account_id": z.string() }) }).strict().describe("The `signer_id` of an ActionReceipt is not valid."), z.object({ "InvalidDataReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a DataReceiver within an ActionReceipt is not valid."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the returned data exceeded the limit in a DataReceipt."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The number of input data dependencies exceeds the limit in an ActionReceipt."), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of an ActionReceipt."), z.object({ "ReceiptSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("Receipt is bigger than the limit."), z.object({ "InvalidRefundTo": z.object({ "account_id": z.string() }) }).strict().describe("The `refund_to` of an ActionReceipt is not valid.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a receipt.") }).strict().describe("Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\nreceipt validation."), z.object({ "OnlyImplicitAccountCreationAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\nSee NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\nAlso, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\nTODO(#8598): This error is named very poorly. A better name would be\n`OnlyNamedAccountCreationAllowed`."), z.object({ "DeleteAccountWithLargeState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Delete account whose state is large is temporarily banned."), z.literal("DelegateActionInvalidSignature").describe("Signature does not match the provided actions and given signer public key."), z.object({ "DelegateActionSenderDoesNotMatchTxReceiver": z.object({ "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Receiver of the transaction doesn't match Sender of the delegate action"), z.literal("DelegateActionExpired").describe("Delegate action has expired. `max_block_height` is less than actual block height."), z.object({ "DelegateActionAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("The given public key doesn't exist for Sender account"), z.object({ "DelegateActionInvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "delegate_nonce": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce must be greater sender[public_key].nonce"), z.object({ "DelegateActionNonceTooLarge": z.object({ "delegate_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce is larger than the upper bound given by the block height"), z.object({ "GlobalContractDoesNotExist": z.object({ "identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("The kind of ActionError happened") }).describe("An error happened during Action execution") }).strict().describe("An error happened during Action execution"), z.object({ "InvalidTxError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Happens if a wrong AccessKey used or AccessKey has not enough permissions"), z.object({ "InvalidSignerId": z.object({ "signer_id": z.string() }) }).strict().describe("TX signer_id is not a valid [`AccountId`]"), z.object({ "SignerDoesNotExist": z.object({ "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("TX signer_id is not found in a storage"), z.object({ "InvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "tx_nonce": z.number().int().gte(0) }) }).strict().describe("Transaction nonce must be strictly greater than `account[access_key].nonce`."), z.object({ "NonceTooLarge": z.object({ "tx_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("Transaction nonce is larger than the upper bound given by the block height"), z.object({ "InvalidReceiverId": z.object({ "receiver_id": z.string() }) }).strict().describe("TX receiver_id is not a valid AccountId"), z.literal("InvalidSignature").describe("TX signature is not valid"), z.object({ "NotEnoughBalance": z.object({ "balance": z.string(), "cost": z.string(), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account does not have enough balance to cover TX cost"), z.object({ "LackBalanceForState": z.object({ "amount": z.string().describe("Required balance to cover the state."), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which doesn't have enough balance to cover storage.") }) }).strict().describe("Signer account doesn't have enough balance after transaction."), z.literal("CostOverflow").describe("An integer overflow occurred during transaction cost estimation."), z.literal("InvalidChain").describe("Transaction parent block hash doesn't belong to the current chain"), z.literal("Expired").describe("Transaction has expired"), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of a Transaction."), z.object({ "TransactionSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of serialized transaction exceeded the limit."), z.literal("InvalidTransactionVersion").describe("Transaction version is invalid."), z.object({ "StorageError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("StorageInternalError").describe("Key-value db internal failure"), z.object({ "MissingTrieValue": z.object({ "context": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("TrieIterator").describe("Missing trie value when reading from TrieIterator."), z.literal("TriePrefetchingStorage").describe("Missing trie value when reading from TriePrefetchingStorage."), z.literal("TrieMemoryPartialStorage").describe("Missing trie value when reading from TrieMemoryPartialStorage."), z.literal("TrieStorage").describe("Missing trie value when reading from TrieStorage.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Contexts in which `StorageError::MissingTrieValue` error might occur."), "hash": z.string() }) }).strict().describe("Requested trie value by its hash which is missing in storage."), z.literal("UnexpectedTrieValue").describe("Found trie node which shouldn't be part of state. Raised during\nvalidation of state sync parts where incorrect node was passed.\nTODO (#8997): consider including hash of trie node."), z.object({ "StorageInconsistentState": z.string() }).strict().describe("Either invalid state or key-value db is corrupted.\nFor PartialStorage it cannot be corrupted.\nError message is unreliable and for debugging purposes only. It's also probably ok to\npanic in every place that produces this error.\nWe can check if db is corrupted by verifying everything in the state trie."), z.object({ "FlatStorageBlockNotSupported": z.string() }).strict().describe("Flat storage error, meaning that it doesn't support some block anymore.\nWe guarantee that such block cannot become final, thus block processing\nmust resume normally."), z.object({ "MemTrieLoadingError": z.string() }).strict().describe("In-memory trie could not be loaded for some reason.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Errors which may occur during working with trie storages, storing\ntrie values (trie nodes and state values) by their hashes.") }).strict(), z.object({ "ShardCongested": z.object({ "congestion_level": z.number().describe("A value between 0 (no congestion) and 1 (max congestion)."), "shard_id": z.number().int().gte(0).describe("The congested shard.") }) }).strict().describe("The receiver shard of the transaction is too congested to accept new\ntransactions at the moment."), z.object({ "ShardStuck": z.object({ "missed_chunks": z.number().int().gte(0).describe("The number of blocks since the last included chunk of the shard."), "shard_id": z.number().int().gte(0).describe("The shard that fails making progress.") }) }).strict().describe("The receiver shard of the transaction missed several chunks and rejects\nnew transaction until it can make progress again.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An error happened during TX execution") }).strict().describe("An error happened during Transaction execution")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error returned in the ExecutionOutcome in case of failure") }).strict().describe("The execution has failed."), z.object({ "SuccessValue": z.string() }).strict().describe("The final action succeeded and returned some value or an empty vec encoded in base64."), z.object({ "SuccessReceiptId": z.string() }).strict().describe("The final action of the receipt returned a promise or the signed transaction was converted\nto a receipt. Contains the receipt_id of the generated receipt.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })
export type ExecutionStatusView = z.infer<typeof ExecutionStatusView>


export const ExtCostsConfigView = z.object({ "alt_bn128_g1_multiexp_base": z.number().int().gte(0).describe("Base cost for multiexp"), "alt_bn128_g1_multiexp_element": z.number().int().gte(0).describe("Per element cost for multiexp"), "alt_bn128_g1_sum_base": z.number().int().gte(0).describe("Base cost for sum"), "alt_bn128_g1_sum_element": z.number().int().gte(0).describe("Per element cost for sum"), "alt_bn128_pairing_check_base": z.number().int().gte(0).describe("Base cost for pairing check"), "alt_bn128_pairing_check_element": z.number().int().gte(0).describe("Per element cost for pairing check"), "base": z.number().int().gte(0).describe("Base cost for calling a host function."), "bls12381_g1_multiexp_base": z.number().int().gte(0), "bls12381_g1_multiexp_element": z.number().int().gte(0), "bls12381_g2_multiexp_base": z.number().int().gte(0), "bls12381_g2_multiexp_element": z.number().int().gte(0), "bls12381_map_fp2_to_g2_base": z.number().int().gte(0), "bls12381_map_fp2_to_g2_element": z.number().int().gte(0), "bls12381_map_fp_to_g1_base": z.number().int().gte(0), "bls12381_map_fp_to_g1_element": z.number().int().gte(0), "bls12381_p1_decompress_base": z.number().int().gte(0), "bls12381_p1_decompress_element": z.number().int().gte(0), "bls12381_p1_sum_base": z.number().int().gte(0), "bls12381_p1_sum_element": z.number().int().gte(0), "bls12381_p2_decompress_base": z.number().int().gte(0), "bls12381_p2_decompress_element": z.number().int().gte(0), "bls12381_p2_sum_base": z.number().int().gte(0), "bls12381_p2_sum_element": z.number().int().gte(0), "bls12381_pairing_base": z.number().int().gte(0), "bls12381_pairing_element": z.number().int().gte(0), "contract_compile_base": z.number().int().gte(0), "contract_compile_bytes": z.number().int().gte(0), "contract_loading_base": z.number().int().gte(0).describe("Base cost of loading a pre-compiled contract"), "contract_loading_bytes": z.number().int().gte(0).describe("Cost per byte of loading a pre-compiled contract"), "ecrecover_base": z.number().int().gte(0).describe("Cost of calling ecrecover"), "ed25519_verify_base": z.number().int().gte(0).describe("Cost of getting ed25519 base"), "ed25519_verify_byte": z.number().int().gte(0).describe("Cost of getting ed25519 per byte"), "keccak256_base": z.number().int().gte(0).describe("Cost of getting sha256 base"), "keccak256_byte": z.number().int().gte(0).describe("Cost of getting sha256 per byte"), "keccak512_base": z.number().int().gte(0).describe("Cost of getting sha256 base"), "keccak512_byte": z.number().int().gte(0).describe("Cost of getting sha256 per byte"), "log_base": z.number().int().gte(0).describe("Cost for calling logging."), "log_byte": z.number().int().gte(0).describe("Cost for logging per byte"), "promise_and_base": z.number().int().gte(0).describe("Cost for calling `promise_and`"), "promise_and_per_promise": z.number().int().gte(0).describe("Cost for calling `promise_and` for each promise"), "promise_return": z.number().int().gte(0).describe("Cost for calling `promise_return`"), "read_cached_trie_node": z.number().int().gte(0).describe("Cost for reading trie node from memory"), "read_memory_base": z.number().int().gte(0).describe("Base cost for guest memory read"), "read_memory_byte": z.number().int().gte(0).describe("Cost for guest memory read"), "read_register_base": z.number().int().gte(0).describe("Base cost for reading from register"), "read_register_byte": z.number().int().gte(0).describe("Cost for reading byte from register"), "ripemd160_base": z.number().int().gte(0).describe("Cost of getting ripemd160 base"), "ripemd160_block": z.number().int().gte(0).describe("Cost of getting ripemd160 per message block"), "sha256_base": z.number().int().gte(0).describe("Cost of getting sha256 base"), "sha256_byte": z.number().int().gte(0).describe("Cost of getting sha256 per byte"), "storage_has_key_base": z.number().int().gte(0).describe("Storage trie check for key existence cost base"), "storage_has_key_byte": z.number().int().gte(0).describe("Storage trie check for key existence per key byte"), "storage_iter_create_from_byte": z.number().int().gte(0).describe("Create trie range iterator cost per byte of from key."), "storage_iter_create_prefix_base": z.number().int().gte(0).describe("Create trie prefix iterator cost base"), "storage_iter_create_prefix_byte": z.number().int().gte(0).describe("Create trie prefix iterator cost per byte."), "storage_iter_create_range_base": z.number().int().gte(0).describe("Create trie range iterator cost base"), "storage_iter_create_to_byte": z.number().int().gte(0).describe("Create trie range iterator cost per byte of to key."), "storage_iter_next_base": z.number().int().gte(0).describe("Trie iterator per key base cost"), "storage_iter_next_key_byte": z.number().int().gte(0).describe("Trie iterator next key byte cost"), "storage_iter_next_value_byte": z.number().int().gte(0).describe("Trie iterator next key byte cost"), "storage_large_read_overhead_base": z.number().int().gte(0).describe("Storage trie read key overhead base cost, when doing large reads"), "storage_large_read_overhead_byte": z.number().int().gte(0).describe("Storage trie read key overhead  per-byte cost, when doing large reads"), "storage_read_base": z.number().int().gte(0).describe("Storage trie read key base cost"), "storage_read_key_byte": z.number().int().gte(0).describe("Storage trie read key per byte cost"), "storage_read_value_byte": z.number().int().gte(0).describe("Storage trie read value cost per byte cost"), "storage_remove_base": z.number().int().gte(0).describe("Remove key from trie base cost"), "storage_remove_key_byte": z.number().int().gte(0).describe("Remove key from trie per byte cost"), "storage_remove_ret_value_byte": z.number().int().gte(0).describe("Remove key from trie ret value byte cost"), "storage_write_base": z.number().int().gte(0).describe("Storage trie write key base cost"), "storage_write_evicted_byte": z.number().int().gte(0).describe("Storage trie write cost per byte of evicted value."), "storage_write_key_byte": z.number().int().gte(0).describe("Storage trie write key per byte cost"), "storage_write_value_byte": z.number().int().gte(0).describe("Storage trie write value per byte cost"), "touching_trie_node": z.number().int().gte(0).describe("Cost per reading trie node from DB"), "utf16_decoding_base": z.number().int().gte(0).describe("Base cost of decoding utf16. It's used for `log_utf16`."), "utf16_decoding_byte": z.number().int().gte(0).describe("Cost per byte of decoding utf16. It's used for `log_utf16`."), "utf8_decoding_base": z.number().int().gte(0).describe("Base cost of decoding utf8. It's used for `log_utf8` and `panic_utf8`."), "utf8_decoding_byte": z.number().int().gte(0).describe("Cost per byte of decoding utf8. It's used for `log_utf8` and `panic_utf8`."), "validator_stake_base": z.number().int().gte(0).describe("Cost of calling `validator_stake`."), "validator_total_stake_base": z.number().int().gte(0).describe("Cost of calling `validator_total_stake`."), "write_memory_base": z.number().int().gte(0).describe("Base cost for guest memory write"), "write_memory_byte": z.number().int().gte(0).describe("Cost for guest memory write per byte"), "write_register_base": z.number().int().gte(0).describe("Base cost for writing into register"), "write_register_byte": z.number().int().gte(0).describe("Cost for writing byte into register"), "yield_create_base": z.number().int().gte(0).describe("Base cost for creating a yield promise."), "yield_create_byte": z.number().int().gte(0).describe("Per byte cost of arguments and method name."), "yield_resume_base": z.number().int().gte(0).describe("Base cost for resuming a yield receipt."), "yield_resume_byte": z.number().int().gte(0).describe("Per byte cost of resume payload.") }).describe("Typed view of ExtCostsConfig to preserve JSON output field names in protocol\nconfig RPC output.")
export type ExtCostsConfigView = z.infer<typeof ExtCostsConfigView>


export const ExternalStorageConfig = z.object({ "external_storage_fallback_threshold": z.number().int().gte(0).describe("The number of attempts the node will make to obtain a part from peers in\nthe network before it fetches from external storage.").default(3), "location": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "S3": z.object({ "bucket": z.string().describe("Location on S3."), "region": z.string().describe("Data may only be available in certain locations.") }) }).strict(), z.object({ "Filesystem": z.object({ "root_dir": z.string() }) }).strict().describe("Local filesystem root for storing data."), z.object({ "GCS": z.object({ "bucket": z.string() }) }).strict().describe("Google Cloud Storage bucket name.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Supported external storage backends and their minimal config.").describe("Location of state parts."), "num_concurrent_requests": z.number().int().gte(0).lte(255).describe("When fetching state parts from external storage, throttle fetch requests\nto this many concurrent requests.").default(25), "num_concurrent_requests_during_catchup": z.number().int().gte(0).lte(255).describe("During catchup, the node will use a different number of concurrent requests\nto reduce the performance impact of state sync.").default(5) })
export type ExternalStorageConfig = z.infer<typeof ExternalStorageConfig>


export const ExternalStorageLocation = z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "S3": z.object({ "bucket": z.string().describe("Location on S3."), "region": z.string().describe("Data may only be available in certain locations.") }) }).strict(), z.object({ "Filesystem": z.object({ "root_dir": z.string() }) }).strict().describe("Local filesystem root for storing data."), z.object({ "GCS": z.object({ "bucket": z.string() }) }).strict().describe("Google Cloud Storage bucket name.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Supported external storage backends and their minimal config.")
export type ExternalStorageLocation = z.infer<typeof ExternalStorageLocation>


export const Fee = z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.")
export type Fee = z.infer<typeof Fee>


export const FinalExecutionOutcomeView = z.object({ "receipts_outcome": z.array(z.object({ "block_hash": z.string(), "id": z.string(), "outcome": z.object({ "executor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("The id of the account on which the execution happens. For transaction this is signer_id,\nfor receipt this is receiver_id."), "gas_burnt": z.number().int().gte(0).describe("The amount of the gas burnt by the given transaction or receipt."), "logs": z.array(z.string()).describe("Logs from this transaction or receipt."), "metadata": z.object({ "gas_profile": z.union([z.array(z.object({ "cost": z.string(), "cost_category": z.string().describe("Either ACTION_COST or WASM_HOST_COST."), "gas_used": z.string() }).describe("Shows gas profile. More info [here](https://near.github.io/nearcore/architecture/gas/gas_profile.html?highlight=WASM_HOST_COST#example-transaction-gas-profile).")), z.null()]).optional(), "version": z.number().int().gte(0) }).describe("Execution metadata, versioned").default({"gas_profile":null,"version":1}), "receipt_ids": z.array(z.string()).describe("Receipt IDs generated by this transaction or receipt."), "status": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unknown").describe("The execution is pending or unknown."), z.object({ "Failure": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "ActionError": z.object({ "index": z.union([z.number().int().gte(0).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`"), z.null().describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`")]).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`").optional(), "kind": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccountAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage"), z.object({ "AccountDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when TX receiver_id doesn't exist (but action is not Action::CreateAccount)"), z.object({ "CreateAccountOnlyByRegistrar": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "registrar_account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A top-level account ID can only be created by registrar."), z.object({ "CreateAccountNotAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A newly created account must be under a namespace of the creator account"), z.object({ "ActorNoPermission": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "actor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\nor the first TX action is a `CreateAccount` action"), z.object({ "DeleteKeyDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("Account tries to remove an access key that doesn't exist"), z.object({ "AddKeyAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The public key is already used for an existing access key"), z.object({ "DeleteAccountStaking": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is staking and can not be deleted"), z.object({ "LackBalanceForState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which needs balance"), "amount": z.string().describe("Balance required to complete an action.") }) }).strict().describe("ActionReceipt can't be completed, because the remaining balance will not be enough to cover storage."), z.object({ "TriesToUnstake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is not yet staked, but tries to unstake"), z.object({ "TriesToStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "balance": z.string(), "locked": z.string(), "stake": z.string() }) }).strict().describe("The account doesn't have enough balance to increase the stake."), z.object({ "InsufficientStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "minimum_stake": z.string(), "stake": z.string() }) }).strict(), z.object({ "FunctionCallError": z.any().superRefine((x, ctx) => {
    const schemas = [z.enum(["WasmUnknownError","_EVMError"]), z.object({ "CompilationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "PrepareError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Serialization").describe("Error happened while serializing the module."), z.literal("Deserialization").describe("Error happened while deserializing the module."), z.literal("InternalMemoryDeclared").describe("Internal memory declaration has been found in the module."), z.literal("GasInstrumentation").describe("Gas instrumentation failed.\n\nThis most likely indicates the module isn't valid."), z.literal("StackHeightInstrumentation").describe("Stack instrumentation failed.\n\nThis  most likely indicates the module isn't valid."), z.literal("Instantiate").describe("Error happened during instantiation.\n\nThis might indicate that `start` function trapped, or module isn't\ninstantiable and/or un-linkable."), z.literal("Memory").describe("Error creating memory."), z.literal("TooManyFunctions").describe("Contract contains too many functions."), z.literal("TooManyLocals").describe("Contract contains too many locals."), z.literal("TooManyTables").describe("Contract contains too many tables."), z.literal("TooManyTableElements").describe("Contract contains too many table elements.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error that can occur while preparing or executing Wasm smart-contract.") }).strict(), z.object({ "WasmerCompileError": z.object({ "msg": z.string() }) }).strict().describe("This is for defense in depth.\nWe expect our runtime-independent preparation code to fully catch all invalid wasms,\nbut, if it ever misses something we’ll emit this error")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Wasm compilation error"), z.object({ "LinkError": z.object({ "msg": z.string() }) }).strict().describe("Wasm binary env link error\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "MethodResolveError": z.enum(["MethodEmptyName","MethodNotFound","MethodInvalidSignature"]) }).strict().describe("Import/export resolve error"), z.object({ "WasmTrap": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unreachable").describe("An `unreachable` opcode was executed."), z.literal("IncorrectCallIndirectSignature").describe("Call indirect incorrect signature trap."), z.literal("MemoryOutOfBounds").describe("Memory out of bounds trap."), z.literal("CallIndirectOOB").describe("Call indirect out of bounds trap."), z.literal("IllegalArithmetic").describe("An arithmetic exception, e.g. divided by zero."), z.literal("MisalignedAtomicAccess").describe("Misaligned atomic access trap."), z.literal("IndirectCallToNull").describe("Indirect call to null."), z.literal("StackOverflow").describe("Stack overflow."), z.literal("GenericTrap").describe("Generic trap.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("A kind of a trap happened during execution of a binary") }).strict().describe("A trap happened during execution of a binary\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "HostError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("BadUTF16").describe("String encoding is bad UTF-16 sequence"), z.literal("BadUTF8").describe("String encoding is bad UTF-8 sequence"), z.literal("GasExceeded").describe("Exceeded the prepaid gas"), z.literal("GasLimitExceeded").describe("Exceeded the maximum amount of gas allowed to burn per contract"), z.literal("BalanceExceeded").describe("Exceeded the account balance"), z.literal("EmptyMethodName").describe("Tried to call an empty method name"), z.object({ "GuestPanic": z.object({ "panic_msg": z.string() }) }).strict().describe("Smart contract panicked"), z.literal("IntegerOverflow").describe("IntegerOverflow happened during a contract execution"), z.object({ "InvalidPromiseIndex": z.object({ "promise_idx": z.number().int().gte(0) }) }).strict().describe("`promise_idx` does not correspond to existing promises"), z.literal("CannotAppendActionToJointPromise").describe("Actions can only be appended to non-joint promise."), z.literal("CannotReturnJointPromise").describe("Returning joint promise is currently prohibited"), z.object({ "InvalidPromiseResultIndex": z.object({ "result_idx": z.number().int().gte(0) }) }).strict().describe("Accessed invalid promise result index"), z.object({ "InvalidRegisterId": z.object({ "register_id": z.number().int().gte(0) }) }).strict().describe("Accessed invalid register id"), z.object({ "IteratorWasInvalidated": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie"), z.literal("MemoryAccessViolation").describe("Accessed memory outside the bounds"), z.object({ "InvalidReceiptIndex": z.object({ "receipt_index": z.number().int().gte(0) }) }).strict().describe("VM Logic returned an invalid receipt index"), z.object({ "InvalidIteratorIndex": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator index `iterator_index` does not exist"), z.literal("InvalidAccountId").describe("VM Logic returned an invalid account id"), z.literal("InvalidMethodName").describe("VM Logic returned an invalid method name"), z.literal("InvalidPublicKey").describe("VM Logic provided an invalid public key"), z.object({ "ProhibitedInView": z.object({ "method_name": z.string() }) }).strict().describe("`method_name` is not allowed in view calls"), z.object({ "NumberOfLogsExceeded": z.object({ "limit": z.number().int().gte(0) }) }).strict().describe("The total number of logs will exceed the limit."), z.object({ "KeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage key length exceeded the limit."), z.object({ "ValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage value length exceeded the limit."), z.object({ "TotalLogLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The total log length exceeded the limit."), z.object({ "NumberPromisesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_promises": z.number().int().gte(0) }) }).strict().describe("The maximum number of promises within a FunctionCall exceeded the limit."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The maximum number of input data dependencies exceeded the limit."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The returned value length exceeded the limit."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The contract size for DeployContract action exceeded the limit."), z.object({ "Deprecated": z.object({ "method_name": z.string() }) }).strict().describe("The host function was deprecated."), z.object({ "ECRecoverError": z.object({ "msg": z.string() }) }).strict().describe("General errors for ECDSA recover."), z.object({ "AltBn128InvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to alt_bn128 family of functions (e.g., point which isn't\non the curve)."), z.object({ "Ed25519VerifyInvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to ed25519 signature verification function (e.g. signature cannot be\nderived from bytes).")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Note: this is only to deserialize old data, use execution error for new data"), z.object({ "ExecutionError": z.string() }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Serializable version of `near-vm-runner::FunctionCallError`.\n\nMust never reorder/remove elements, can only add new variants at the end (but do that very\ncarefully). It describes stable serialization format, and only used by serialization logic.") }).strict().describe("An error occurred during a `FunctionCall` Action, parameter is debug message."), z.object({ "NewReceiptValidationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidPredecessorId": z.object({ "account_id": z.string() }) }).strict().describe("The `predecessor_id` of a Receipt is not valid."), z.object({ "InvalidReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a Receipt is not valid."), z.object({ "InvalidSignerId": z.object({ "account_id": z.string() }) }).strict().describe("The `signer_id` of an ActionReceipt is not valid."), z.object({ "InvalidDataReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a DataReceiver within an ActionReceipt is not valid."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the returned data exceeded the limit in a DataReceipt."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The number of input data dependencies exceeds the limit in an ActionReceipt."), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of an ActionReceipt."), z.object({ "ReceiptSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("Receipt is bigger than the limit."), z.object({ "InvalidRefundTo": z.object({ "account_id": z.string() }) }).strict().describe("The `refund_to` of an ActionReceipt is not valid.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a receipt.") }).strict().describe("Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\nreceipt validation."), z.object({ "OnlyImplicitAccountCreationAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\nSee NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\nAlso, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\nTODO(#8598): This error is named very poorly. A better name would be\n`OnlyNamedAccountCreationAllowed`."), z.object({ "DeleteAccountWithLargeState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Delete account whose state is large is temporarily banned."), z.literal("DelegateActionInvalidSignature").describe("Signature does not match the provided actions and given signer public key."), z.object({ "DelegateActionSenderDoesNotMatchTxReceiver": z.object({ "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Receiver of the transaction doesn't match Sender of the delegate action"), z.literal("DelegateActionExpired").describe("Delegate action has expired. `max_block_height` is less than actual block height."), z.object({ "DelegateActionAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("The given public key doesn't exist for Sender account"), z.object({ "DelegateActionInvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "delegate_nonce": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce must be greater sender[public_key].nonce"), z.object({ "DelegateActionNonceTooLarge": z.object({ "delegate_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce is larger than the upper bound given by the block height"), z.object({ "GlobalContractDoesNotExist": z.object({ "identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("The kind of ActionError happened") }).describe("An error happened during Action execution") }).strict().describe("An error happened during Action execution"), z.object({ "InvalidTxError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Happens if a wrong AccessKey used or AccessKey has not enough permissions"), z.object({ "InvalidSignerId": z.object({ "signer_id": z.string() }) }).strict().describe("TX signer_id is not a valid [`AccountId`]"), z.object({ "SignerDoesNotExist": z.object({ "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("TX signer_id is not found in a storage"), z.object({ "InvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "tx_nonce": z.number().int().gte(0) }) }).strict().describe("Transaction nonce must be strictly greater than `account[access_key].nonce`."), z.object({ "NonceTooLarge": z.object({ "tx_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("Transaction nonce is larger than the upper bound given by the block height"), z.object({ "InvalidReceiverId": z.object({ "receiver_id": z.string() }) }).strict().describe("TX receiver_id is not a valid AccountId"), z.literal("InvalidSignature").describe("TX signature is not valid"), z.object({ "NotEnoughBalance": z.object({ "balance": z.string(), "cost": z.string(), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account does not have enough balance to cover TX cost"), z.object({ "LackBalanceForState": z.object({ "amount": z.string().describe("Required balance to cover the state."), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which doesn't have enough balance to cover storage.") }) }).strict().describe("Signer account doesn't have enough balance after transaction."), z.literal("CostOverflow").describe("An integer overflow occurred during transaction cost estimation."), z.literal("InvalidChain").describe("Transaction parent block hash doesn't belong to the current chain"), z.literal("Expired").describe("Transaction has expired"), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of a Transaction."), z.object({ "TransactionSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of serialized transaction exceeded the limit."), z.literal("InvalidTransactionVersion").describe("Transaction version is invalid."), z.object({ "StorageError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("StorageInternalError").describe("Key-value db internal failure"), z.object({ "MissingTrieValue": z.object({ "context": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("TrieIterator").describe("Missing trie value when reading from TrieIterator."), z.literal("TriePrefetchingStorage").describe("Missing trie value when reading from TriePrefetchingStorage."), z.literal("TrieMemoryPartialStorage").describe("Missing trie value when reading from TrieMemoryPartialStorage."), z.literal("TrieStorage").describe("Missing trie value when reading from TrieStorage.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Contexts in which `StorageError::MissingTrieValue` error might occur."), "hash": z.string() }) }).strict().describe("Requested trie value by its hash which is missing in storage."), z.literal("UnexpectedTrieValue").describe("Found trie node which shouldn't be part of state. Raised during\nvalidation of state sync parts where incorrect node was passed.\nTODO (#8997): consider including hash of trie node."), z.object({ "StorageInconsistentState": z.string() }).strict().describe("Either invalid state or key-value db is corrupted.\nFor PartialStorage it cannot be corrupted.\nError message is unreliable and for debugging purposes only. It's also probably ok to\npanic in every place that produces this error.\nWe can check if db is corrupted by verifying everything in the state trie."), z.object({ "FlatStorageBlockNotSupported": z.string() }).strict().describe("Flat storage error, meaning that it doesn't support some block anymore.\nWe guarantee that such block cannot become final, thus block processing\nmust resume normally."), z.object({ "MemTrieLoadingError": z.string() }).strict().describe("In-memory trie could not be loaded for some reason.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Errors which may occur during working with trie storages, storing\ntrie values (trie nodes and state values) by their hashes.") }).strict(), z.object({ "ShardCongested": z.object({ "congestion_level": z.number().describe("A value between 0 (no congestion) and 1 (max congestion)."), "shard_id": z.number().int().gte(0).describe("The congested shard.") }) }).strict().describe("The receiver shard of the transaction is too congested to accept new\ntransactions at the moment."), z.object({ "ShardStuck": z.object({ "missed_chunks": z.number().int().gte(0).describe("The number of blocks since the last included chunk of the shard."), "shard_id": z.number().int().gte(0).describe("The shard that fails making progress.") }) }).strict().describe("The receiver shard of the transaction missed several chunks and rejects\nnew transaction until it can make progress again.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An error happened during TX execution") }).strict().describe("An error happened during Transaction execution")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error returned in the ExecutionOutcome in case of failure") }).strict().describe("The execution has failed."), z.object({ "SuccessValue": z.string() }).strict().describe("The final action succeeded and returned some value or an empty vec encoded in base64."), z.object({ "SuccessReceiptId": z.string() }).strict().describe("The final action of the receipt returned a promise or the signed transaction was converted\nto a receipt. Contains the receipt_id of the generated receipt.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Execution status. Contains the result in case of successful execution."), "tokens_burnt": z.string().describe("The amount of tokens burnt corresponding to the burnt gas amount.\nThis value doesn't always equal to the `gas_burnt` multiplied by the gas price, because\nthe prepaid gas price might be lower than the actual gas price and it creates a deficit.\n`tokens_burnt` also contains the penalty subtracted from refunds, while\n`gas_burnt` only contains the gas that we actually burn for the execution.") }), "proof": z.array(z.object({ "direction": z.enum(["Left","Right"]), "hash": z.string() })) })).describe("The execution outcome of receipts."), "status": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("NotStarted").describe("The execution has not yet started."), z.literal("Started").describe("The execution has started and still going."), z.object({ "Failure": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "ActionError": z.object({ "index": z.union([z.number().int().gte(0).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`"), z.null().describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`")]).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`").optional(), "kind": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccountAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage"), z.object({ "AccountDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when TX receiver_id doesn't exist (but action is not Action::CreateAccount)"), z.object({ "CreateAccountOnlyByRegistrar": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "registrar_account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A top-level account ID can only be created by registrar."), z.object({ "CreateAccountNotAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A newly created account must be under a namespace of the creator account"), z.object({ "ActorNoPermission": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "actor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\nor the first TX action is a `CreateAccount` action"), z.object({ "DeleteKeyDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("Account tries to remove an access key that doesn't exist"), z.object({ "AddKeyAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The public key is already used for an existing access key"), z.object({ "DeleteAccountStaking": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is staking and can not be deleted"), z.object({ "LackBalanceForState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which needs balance"), "amount": z.string().describe("Balance required to complete an action.") }) }).strict().describe("ActionReceipt can't be completed, because the remaining balance will not be enough to cover storage."), z.object({ "TriesToUnstake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is not yet staked, but tries to unstake"), z.object({ "TriesToStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "balance": z.string(), "locked": z.string(), "stake": z.string() }) }).strict().describe("The account doesn't have enough balance to increase the stake."), z.object({ "InsufficientStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "minimum_stake": z.string(), "stake": z.string() }) }).strict(), z.object({ "FunctionCallError": z.any().superRefine((x, ctx) => {
    const schemas = [z.enum(["WasmUnknownError","_EVMError"]), z.object({ "CompilationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "PrepareError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Serialization").describe("Error happened while serializing the module."), z.literal("Deserialization").describe("Error happened while deserializing the module."), z.literal("InternalMemoryDeclared").describe("Internal memory declaration has been found in the module."), z.literal("GasInstrumentation").describe("Gas instrumentation failed.\n\nThis most likely indicates the module isn't valid."), z.literal("StackHeightInstrumentation").describe("Stack instrumentation failed.\n\nThis  most likely indicates the module isn't valid."), z.literal("Instantiate").describe("Error happened during instantiation.\n\nThis might indicate that `start` function trapped, or module isn't\ninstantiable and/or un-linkable."), z.literal("Memory").describe("Error creating memory."), z.literal("TooManyFunctions").describe("Contract contains too many functions."), z.literal("TooManyLocals").describe("Contract contains too many locals."), z.literal("TooManyTables").describe("Contract contains too many tables."), z.literal("TooManyTableElements").describe("Contract contains too many table elements.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error that can occur while preparing or executing Wasm smart-contract.") }).strict(), z.object({ "WasmerCompileError": z.object({ "msg": z.string() }) }).strict().describe("This is for defense in depth.\nWe expect our runtime-independent preparation code to fully catch all invalid wasms,\nbut, if it ever misses something we’ll emit this error")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Wasm compilation error"), z.object({ "LinkError": z.object({ "msg": z.string() }) }).strict().describe("Wasm binary env link error\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "MethodResolveError": z.enum(["MethodEmptyName","MethodNotFound","MethodInvalidSignature"]) }).strict().describe("Import/export resolve error"), z.object({ "WasmTrap": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unreachable").describe("An `unreachable` opcode was executed."), z.literal("IncorrectCallIndirectSignature").describe("Call indirect incorrect signature trap."), z.literal("MemoryOutOfBounds").describe("Memory out of bounds trap."), z.literal("CallIndirectOOB").describe("Call indirect out of bounds trap."), z.literal("IllegalArithmetic").describe("An arithmetic exception, e.g. divided by zero."), z.literal("MisalignedAtomicAccess").describe("Misaligned atomic access trap."), z.literal("IndirectCallToNull").describe("Indirect call to null."), z.literal("StackOverflow").describe("Stack overflow."), z.literal("GenericTrap").describe("Generic trap.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("A kind of a trap happened during execution of a binary") }).strict().describe("A trap happened during execution of a binary\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "HostError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("BadUTF16").describe("String encoding is bad UTF-16 sequence"), z.literal("BadUTF8").describe("String encoding is bad UTF-8 sequence"), z.literal("GasExceeded").describe("Exceeded the prepaid gas"), z.literal("GasLimitExceeded").describe("Exceeded the maximum amount of gas allowed to burn per contract"), z.literal("BalanceExceeded").describe("Exceeded the account balance"), z.literal("EmptyMethodName").describe("Tried to call an empty method name"), z.object({ "GuestPanic": z.object({ "panic_msg": z.string() }) }).strict().describe("Smart contract panicked"), z.literal("IntegerOverflow").describe("IntegerOverflow happened during a contract execution"), z.object({ "InvalidPromiseIndex": z.object({ "promise_idx": z.number().int().gte(0) }) }).strict().describe("`promise_idx` does not correspond to existing promises"), z.literal("CannotAppendActionToJointPromise").describe("Actions can only be appended to non-joint promise."), z.literal("CannotReturnJointPromise").describe("Returning joint promise is currently prohibited"), z.object({ "InvalidPromiseResultIndex": z.object({ "result_idx": z.number().int().gte(0) }) }).strict().describe("Accessed invalid promise result index"), z.object({ "InvalidRegisterId": z.object({ "register_id": z.number().int().gte(0) }) }).strict().describe("Accessed invalid register id"), z.object({ "IteratorWasInvalidated": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie"), z.literal("MemoryAccessViolation").describe("Accessed memory outside the bounds"), z.object({ "InvalidReceiptIndex": z.object({ "receipt_index": z.number().int().gte(0) }) }).strict().describe("VM Logic returned an invalid receipt index"), z.object({ "InvalidIteratorIndex": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator index `iterator_index` does not exist"), z.literal("InvalidAccountId").describe("VM Logic returned an invalid account id"), z.literal("InvalidMethodName").describe("VM Logic returned an invalid method name"), z.literal("InvalidPublicKey").describe("VM Logic provided an invalid public key"), z.object({ "ProhibitedInView": z.object({ "method_name": z.string() }) }).strict().describe("`method_name` is not allowed in view calls"), z.object({ "NumberOfLogsExceeded": z.object({ "limit": z.number().int().gte(0) }) }).strict().describe("The total number of logs will exceed the limit."), z.object({ "KeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage key length exceeded the limit."), z.object({ "ValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage value length exceeded the limit."), z.object({ "TotalLogLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The total log length exceeded the limit."), z.object({ "NumberPromisesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_promises": z.number().int().gte(0) }) }).strict().describe("The maximum number of promises within a FunctionCall exceeded the limit."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The maximum number of input data dependencies exceeded the limit."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The returned value length exceeded the limit."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The contract size for DeployContract action exceeded the limit."), z.object({ "Deprecated": z.object({ "method_name": z.string() }) }).strict().describe("The host function was deprecated."), z.object({ "ECRecoverError": z.object({ "msg": z.string() }) }).strict().describe("General errors for ECDSA recover."), z.object({ "AltBn128InvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to alt_bn128 family of functions (e.g., point which isn't\non the curve)."), z.object({ "Ed25519VerifyInvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to ed25519 signature verification function (e.g. signature cannot be\nderived from bytes).")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Note: this is only to deserialize old data, use execution error for new data"), z.object({ "ExecutionError": z.string() }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Serializable version of `near-vm-runner::FunctionCallError`.\n\nMust never reorder/remove elements, can only add new variants at the end (but do that very\ncarefully). It describes stable serialization format, and only used by serialization logic.") }).strict().describe("An error occurred during a `FunctionCall` Action, parameter is debug message."), z.object({ "NewReceiptValidationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidPredecessorId": z.object({ "account_id": z.string() }) }).strict().describe("The `predecessor_id` of a Receipt is not valid."), z.object({ "InvalidReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a Receipt is not valid."), z.object({ "InvalidSignerId": z.object({ "account_id": z.string() }) }).strict().describe("The `signer_id` of an ActionReceipt is not valid."), z.object({ "InvalidDataReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a DataReceiver within an ActionReceipt is not valid."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the returned data exceeded the limit in a DataReceipt."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The number of input data dependencies exceeds the limit in an ActionReceipt."), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of an ActionReceipt."), z.object({ "ReceiptSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("Receipt is bigger than the limit."), z.object({ "InvalidRefundTo": z.object({ "account_id": z.string() }) }).strict().describe("The `refund_to` of an ActionReceipt is not valid.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a receipt.") }).strict().describe("Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\nreceipt validation."), z.object({ "OnlyImplicitAccountCreationAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\nSee NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\nAlso, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\nTODO(#8598): This error is named very poorly. A better name would be\n`OnlyNamedAccountCreationAllowed`."), z.object({ "DeleteAccountWithLargeState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Delete account whose state is large is temporarily banned."), z.literal("DelegateActionInvalidSignature").describe("Signature does not match the provided actions and given signer public key."), z.object({ "DelegateActionSenderDoesNotMatchTxReceiver": z.object({ "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Receiver of the transaction doesn't match Sender of the delegate action"), z.literal("DelegateActionExpired").describe("Delegate action has expired. `max_block_height` is less than actual block height."), z.object({ "DelegateActionAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("The given public key doesn't exist for Sender account"), z.object({ "DelegateActionInvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "delegate_nonce": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce must be greater sender[public_key].nonce"), z.object({ "DelegateActionNonceTooLarge": z.object({ "delegate_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce is larger than the upper bound given by the block height"), z.object({ "GlobalContractDoesNotExist": z.object({ "identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("The kind of ActionError happened") }).describe("An error happened during Action execution") }).strict().describe("An error happened during Action execution"), z.object({ "InvalidTxError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Happens if a wrong AccessKey used or AccessKey has not enough permissions"), z.object({ "InvalidSignerId": z.object({ "signer_id": z.string() }) }).strict().describe("TX signer_id is not a valid [`AccountId`]"), z.object({ "SignerDoesNotExist": z.object({ "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("TX signer_id is not found in a storage"), z.object({ "InvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "tx_nonce": z.number().int().gte(0) }) }).strict().describe("Transaction nonce must be strictly greater than `account[access_key].nonce`."), z.object({ "NonceTooLarge": z.object({ "tx_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("Transaction nonce is larger than the upper bound given by the block height"), z.object({ "InvalidReceiverId": z.object({ "receiver_id": z.string() }) }).strict().describe("TX receiver_id is not a valid AccountId"), z.literal("InvalidSignature").describe("TX signature is not valid"), z.object({ "NotEnoughBalance": z.object({ "balance": z.string(), "cost": z.string(), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account does not have enough balance to cover TX cost"), z.object({ "LackBalanceForState": z.object({ "amount": z.string().describe("Required balance to cover the state."), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which doesn't have enough balance to cover storage.") }) }).strict().describe("Signer account doesn't have enough balance after transaction."), z.literal("CostOverflow").describe("An integer overflow occurred during transaction cost estimation."), z.literal("InvalidChain").describe("Transaction parent block hash doesn't belong to the current chain"), z.literal("Expired").describe("Transaction has expired"), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of a Transaction."), z.object({ "TransactionSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of serialized transaction exceeded the limit."), z.literal("InvalidTransactionVersion").describe("Transaction version is invalid."), z.object({ "StorageError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("StorageInternalError").describe("Key-value db internal failure"), z.object({ "MissingTrieValue": z.object({ "context": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("TrieIterator").describe("Missing trie value when reading from TrieIterator."), z.literal("TriePrefetchingStorage").describe("Missing trie value when reading from TriePrefetchingStorage."), z.literal("TrieMemoryPartialStorage").describe("Missing trie value when reading from TrieMemoryPartialStorage."), z.literal("TrieStorage").describe("Missing trie value when reading from TrieStorage.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Contexts in which `StorageError::MissingTrieValue` error might occur."), "hash": z.string() }) }).strict().describe("Requested trie value by its hash which is missing in storage."), z.literal("UnexpectedTrieValue").describe("Found trie node which shouldn't be part of state. Raised during\nvalidation of state sync parts where incorrect node was passed.\nTODO (#8997): consider including hash of trie node."), z.object({ "StorageInconsistentState": z.string() }).strict().describe("Either invalid state or key-value db is corrupted.\nFor PartialStorage it cannot be corrupted.\nError message is unreliable and for debugging purposes only. It's also probably ok to\npanic in every place that produces this error.\nWe can check if db is corrupted by verifying everything in the state trie."), z.object({ "FlatStorageBlockNotSupported": z.string() }).strict().describe("Flat storage error, meaning that it doesn't support some block anymore.\nWe guarantee that such block cannot become final, thus block processing\nmust resume normally."), z.object({ "MemTrieLoadingError": z.string() }).strict().describe("In-memory trie could not be loaded for some reason.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Errors which may occur during working with trie storages, storing\ntrie values (trie nodes and state values) by their hashes.") }).strict(), z.object({ "ShardCongested": z.object({ "congestion_level": z.number().describe("A value between 0 (no congestion) and 1 (max congestion)."), "shard_id": z.number().int().gte(0).describe("The congested shard.") }) }).strict().describe("The receiver shard of the transaction is too congested to accept new\ntransactions at the moment."), z.object({ "ShardStuck": z.object({ "missed_chunks": z.number().int().gte(0).describe("The number of blocks since the last included chunk of the shard."), "shard_id": z.number().int().gte(0).describe("The shard that fails making progress.") }) }).strict().describe("The receiver shard of the transaction missed several chunks and rejects\nnew transaction until it can make progress again.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An error happened during TX execution") }).strict().describe("An error happened during Transaction execution")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error returned in the ExecutionOutcome in case of failure") }).strict().describe("The execution has failed with the given error."), z.object({ "SuccessValue": z.string() }).strict().describe("The execution has succeeded and returned some value or an empty vec encoded in base64.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Execution status defined by chain.rs:get_final_transaction_result\nFinalExecutionStatus::NotStarted - the tx is not converted to the receipt yet\nFinalExecutionStatus::Started - we have at least 1 receipt, but the first leaf receipt_id (using dfs) hasn't finished the execution\nFinalExecutionStatus::Failure - the result of the first leaf receipt_id\nFinalExecutionStatus::SuccessValue - the result of the first leaf receipt_id"), "transaction": z.object({ "actions": z.array(z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("CreateAccount"), z.object({ "DeployContract": z.object({ "code": z.string() }) }).strict(), z.object({ "FunctionCall": z.object({ "args": z.string().describe("This type is used to mark function arguments.\n\nNOTE: The main reason for this to exist (except the type-safety) is that the value is\ntransparently serialized and deserialized as a base64-encoded string when serde is used\n(serde_json)."), "deposit": z.string(), "gas": z.number().int().gte(0), "method_name": z.string() }) }).strict(), z.object({ "Transfer": z.object({ "deposit": z.string() }) }).strict(), z.object({ "Stake": z.object({ "public_key": z.string(), "stake": z.string() }) }).strict(), z.object({ "AddKey": z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("FullAccess"), z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "method_names": z.array(z.string()), "receiver_id": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the permission scope for an access key. Whether it is a function call or a full access key.") }).describe("Describes access key permission scope and nonce."), "public_key": z.string() }) }).strict(), z.object({ "DeleteKey": z.object({ "public_key": z.string() }) }).strict(), z.object({ "DeleteAccount": z.object({ "beneficiary_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "Delegate": z.object({ "delegate_action": z.object({ "actions": z.array(z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CreateAccount": z.record(z.any()).describe("Create account action") }).strict().describe("Create an (sub)account using a transaction `receiver_id` as an ID for\na new account ID must pass validation rules described here\n<https://nomicon.io/DataStructures/Account>."), z.object({ "DeployContract": z.object({ "code": z.string().describe("WebAssembly binary") }).describe("Deploy contract action") }).strict().describe("Sets a Wasm code to a receiver_id"), z.object({ "FunctionCall": z.object({ "args": z.string(), "deposit": z.string(), "gas": z.number().int().gte(0), "method_name": z.string() }) }).strict(), z.object({ "Transfer": z.object({ "deposit": z.string() }) }).strict(), z.object({ "Stake": z.object({ "public_key": z.string().describe("Validator key which will be used to sign transactions on behalf of signer_id"), "stake": z.string().describe("Amount of tokens to stake.") }).describe("An action which stakes signer_id tokens and setup's validator public key") }).strict(), z.object({ "AddKey": z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0).describe("Nonce for this access key, used for tx nonce generation. When access key is created, nonce\nis set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\nSee <https://github.com/near/nearcore/issues/3779> for more details."), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Allowance is a balance limit to use by this access key to pay for function call gas and\ntransaction fees. When this access key is used, both account balance and the allowance is\ndecreased by the same value.\n`None` means unlimited allowance.\nNOTE: To change or increase the allowance, the old access key needs to be deleted and a new\naccess key should be created.").optional(), "method_names": z.array(z.string()).describe("A list of method names that can be used. The access key only allows transactions with the\nfunction call of one of the given method names.\nEmpty list means any method name can be used."), "receiver_id": z.string().describe("The access key only allows transactions with the given receiver's account id.") }).describe("Grants limited permission to make transactions with FunctionCallActions\nThe permission can limit the allowed balance to be spent on the prepaid gas.\nIt also restrict the account ID of the receiver for this function call.\nIt also can restrict the method name for the allowed function calls.") }).strict(), z.literal("FullAccess").describe("Grants full access to the account.\nNOTE: It's used to replace account-level public keys.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Defines permissions for AccessKey").describe("Defines permissions for this access key.") }).describe("Access key provides limited access to an account. Each access key belongs to some account and\nis identified by a unique (within the account) public key. One account may have large number of\naccess keys. Access keys allow to act on behalf of the account by restricting transactions\nthat can be issued.\n`account_id,public_key` is a key in the state").describe("An access key with the permission"), "public_key": z.string().describe("A public key which will be associated with an access_key") }).describe("An action that adds key with public key associated") }).strict(), z.object({ "DeleteKey": z.object({ "public_key": z.string().describe("A public key associated with the access_key to be deleted.") }) }).strict(), z.object({ "DeleteAccount": z.object({ "beneficiary_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeployGlobalContract": z.object({ "code": z.string().describe("WebAssembly binary"), "deploy_mode": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("CodeHash").describe("Contract is deployed under its code hash.\nUsers will be able reference it by that hash.\nThis effectively makes the contract immutable."), z.literal("AccountId").describe("Contract is deployed under the owner account id.\nUsers will be able reference it by that account id.\nThis allows the owner to update the contract for all its users.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Deploy global contract action") }).strict(), z.object({ "UseGlobalContract": z.object({ "contract_identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Use global contract action") }).strict(), z.object({ "DeterministicStateInit": z.object({ "deposit": z.string(), "state_init": z.object({ "V1": z.object({ "code": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "data": z.record(z.string()) }) }).strict() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An Action that can be included in a transaction or receipt, excluding delegate actions. This type represents all possible action types except DelegateAction to prevent infinite recursion in meta-transactions.")).describe("List of actions to be executed.\n\nWith the meta transactions MVP defined in NEP-366, nested\nDelegateActions are not allowed. A separate type is used to enforce it."), "max_block_height": z.number().int().gte(0).describe("The maximal height of the block in the blockchain below which the given DelegateAction is valid."), "nonce": z.number().int().gte(0).describe("Nonce to ensure that the same delegate action is not sent twice by a\nrelayer and should match for given account's `public_key`.\nAfter this action is processed it will increment."), "public_key": z.string().describe("Public key used to sign this delegated action."), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("Receiver of the delegated actions."), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("Signer of the delegated actions") }).describe("This action allows to execute the inner actions behalf of the defined sender."), "signature": z.string() }) }).strict(), z.object({ "DeployGlobalContract": z.object({ "code": z.string() }) }).strict(), z.object({ "DeployGlobalContractByAccountId": z.object({ "code": z.string() }) }).strict(), z.object({ "UseGlobalContract": z.object({ "code_hash": z.string() }) }).strict(), z.object({ "UseGlobalContractByAccountId": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInit": z.object({ "code": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "hash": z.string() }).strict(), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "data": z.record(z.string()), "deposit": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })), "hash": z.string(), "nonce": z.number().int().gte(0), "priority_fee": z.number().int().gte(0).default(0), "public_key": z.string(), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "signature": z.string(), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).describe("Signed Transaction"), "transaction_outcome": z.object({ "block_hash": z.string(), "id": z.string(), "outcome": z.object({ "executor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("The id of the account on which the execution happens. For transaction this is signer_id,\nfor receipt this is receiver_id."), "gas_burnt": z.number().int().gte(0).describe("The amount of the gas burnt by the given transaction or receipt."), "logs": z.array(z.string()).describe("Logs from this transaction or receipt."), "metadata": z.object({ "gas_profile": z.union([z.array(z.object({ "cost": z.string(), "cost_category": z.string().describe("Either ACTION_COST or WASM_HOST_COST."), "gas_used": z.string() }).describe("Shows gas profile. More info [here](https://near.github.io/nearcore/architecture/gas/gas_profile.html?highlight=WASM_HOST_COST#example-transaction-gas-profile).")), z.null()]).optional(), "version": z.number().int().gte(0) }).describe("Execution metadata, versioned").default({"gas_profile":null,"version":1}), "receipt_ids": z.array(z.string()).describe("Receipt IDs generated by this transaction or receipt."), "status": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unknown").describe("The execution is pending or unknown."), z.object({ "Failure": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "ActionError": z.object({ "index": z.union([z.number().int().gte(0).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`"), z.null().describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`")]).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`").optional(), "kind": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccountAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage"), z.object({ "AccountDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when TX receiver_id doesn't exist (but action is not Action::CreateAccount)"), z.object({ "CreateAccountOnlyByRegistrar": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "registrar_account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A top-level account ID can only be created by registrar."), z.object({ "CreateAccountNotAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A newly created account must be under a namespace of the creator account"), z.object({ "ActorNoPermission": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "actor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\nor the first TX action is a `CreateAccount` action"), z.object({ "DeleteKeyDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("Account tries to remove an access key that doesn't exist"), z.object({ "AddKeyAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The public key is already used for an existing access key"), z.object({ "DeleteAccountStaking": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is staking and can not be deleted"), z.object({ "LackBalanceForState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which needs balance"), "amount": z.string().describe("Balance required to complete an action.") }) }).strict().describe("ActionReceipt can't be completed, because the remaining balance will not be enough to cover storage."), z.object({ "TriesToUnstake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is not yet staked, but tries to unstake"), z.object({ "TriesToStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "balance": z.string(), "locked": z.string(), "stake": z.string() }) }).strict().describe("The account doesn't have enough balance to increase the stake."), z.object({ "InsufficientStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "minimum_stake": z.string(), "stake": z.string() }) }).strict(), z.object({ "FunctionCallError": z.any().superRefine((x, ctx) => {
    const schemas = [z.enum(["WasmUnknownError","_EVMError"]), z.object({ "CompilationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "PrepareError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Serialization").describe("Error happened while serializing the module."), z.literal("Deserialization").describe("Error happened while deserializing the module."), z.literal("InternalMemoryDeclared").describe("Internal memory declaration has been found in the module."), z.literal("GasInstrumentation").describe("Gas instrumentation failed.\n\nThis most likely indicates the module isn't valid."), z.literal("StackHeightInstrumentation").describe("Stack instrumentation failed.\n\nThis  most likely indicates the module isn't valid."), z.literal("Instantiate").describe("Error happened during instantiation.\n\nThis might indicate that `start` function trapped, or module isn't\ninstantiable and/or un-linkable."), z.literal("Memory").describe("Error creating memory."), z.literal("TooManyFunctions").describe("Contract contains too many functions."), z.literal("TooManyLocals").describe("Contract contains too many locals."), z.literal("TooManyTables").describe("Contract contains too many tables."), z.literal("TooManyTableElements").describe("Contract contains too many table elements.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error that can occur while preparing or executing Wasm smart-contract.") }).strict(), z.object({ "WasmerCompileError": z.object({ "msg": z.string() }) }).strict().describe("This is for defense in depth.\nWe expect our runtime-independent preparation code to fully catch all invalid wasms,\nbut, if it ever misses something we’ll emit this error")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Wasm compilation error"), z.object({ "LinkError": z.object({ "msg": z.string() }) }).strict().describe("Wasm binary env link error\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "MethodResolveError": z.enum(["MethodEmptyName","MethodNotFound","MethodInvalidSignature"]) }).strict().describe("Import/export resolve error"), z.object({ "WasmTrap": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unreachable").describe("An `unreachable` opcode was executed."), z.literal("IncorrectCallIndirectSignature").describe("Call indirect incorrect signature trap."), z.literal("MemoryOutOfBounds").describe("Memory out of bounds trap."), z.literal("CallIndirectOOB").describe("Call indirect out of bounds trap."), z.literal("IllegalArithmetic").describe("An arithmetic exception, e.g. divided by zero."), z.literal("MisalignedAtomicAccess").describe("Misaligned atomic access trap."), z.literal("IndirectCallToNull").describe("Indirect call to null."), z.literal("StackOverflow").describe("Stack overflow."), z.literal("GenericTrap").describe("Generic trap.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("A kind of a trap happened during execution of a binary") }).strict().describe("A trap happened during execution of a binary\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "HostError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("BadUTF16").describe("String encoding is bad UTF-16 sequence"), z.literal("BadUTF8").describe("String encoding is bad UTF-8 sequence"), z.literal("GasExceeded").describe("Exceeded the prepaid gas"), z.literal("GasLimitExceeded").describe("Exceeded the maximum amount of gas allowed to burn per contract"), z.literal("BalanceExceeded").describe("Exceeded the account balance"), z.literal("EmptyMethodName").describe("Tried to call an empty method name"), z.object({ "GuestPanic": z.object({ "panic_msg": z.string() }) }).strict().describe("Smart contract panicked"), z.literal("IntegerOverflow").describe("IntegerOverflow happened during a contract execution"), z.object({ "InvalidPromiseIndex": z.object({ "promise_idx": z.number().int().gte(0) }) }).strict().describe("`promise_idx` does not correspond to existing promises"), z.literal("CannotAppendActionToJointPromise").describe("Actions can only be appended to non-joint promise."), z.literal("CannotReturnJointPromise").describe("Returning joint promise is currently prohibited"), z.object({ "InvalidPromiseResultIndex": z.object({ "result_idx": z.number().int().gte(0) }) }).strict().describe("Accessed invalid promise result index"), z.object({ "InvalidRegisterId": z.object({ "register_id": z.number().int().gte(0) }) }).strict().describe("Accessed invalid register id"), z.object({ "IteratorWasInvalidated": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie"), z.literal("MemoryAccessViolation").describe("Accessed memory outside the bounds"), z.object({ "InvalidReceiptIndex": z.object({ "receipt_index": z.number().int().gte(0) }) }).strict().describe("VM Logic returned an invalid receipt index"), z.object({ "InvalidIteratorIndex": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator index `iterator_index` does not exist"), z.literal("InvalidAccountId").describe("VM Logic returned an invalid account id"), z.literal("InvalidMethodName").describe("VM Logic returned an invalid method name"), z.literal("InvalidPublicKey").describe("VM Logic provided an invalid public key"), z.object({ "ProhibitedInView": z.object({ "method_name": z.string() }) }).strict().describe("`method_name` is not allowed in view calls"), z.object({ "NumberOfLogsExceeded": z.object({ "limit": z.number().int().gte(0) }) }).strict().describe("The total number of logs will exceed the limit."), z.object({ "KeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage key length exceeded the limit."), z.object({ "ValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage value length exceeded the limit."), z.object({ "TotalLogLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The total log length exceeded the limit."), z.object({ "NumberPromisesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_promises": z.number().int().gte(0) }) }).strict().describe("The maximum number of promises within a FunctionCall exceeded the limit."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The maximum number of input data dependencies exceeded the limit."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The returned value length exceeded the limit."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The contract size for DeployContract action exceeded the limit."), z.object({ "Deprecated": z.object({ "method_name": z.string() }) }).strict().describe("The host function was deprecated."), z.object({ "ECRecoverError": z.object({ "msg": z.string() }) }).strict().describe("General errors for ECDSA recover."), z.object({ "AltBn128InvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to alt_bn128 family of functions (e.g., point which isn't\non the curve)."), z.object({ "Ed25519VerifyInvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to ed25519 signature verification function (e.g. signature cannot be\nderived from bytes).")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Note: this is only to deserialize old data, use execution error for new data"), z.object({ "ExecutionError": z.string() }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Serializable version of `near-vm-runner::FunctionCallError`.\n\nMust never reorder/remove elements, can only add new variants at the end (but do that very\ncarefully). It describes stable serialization format, and only used by serialization logic.") }).strict().describe("An error occurred during a `FunctionCall` Action, parameter is debug message."), z.object({ "NewReceiptValidationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidPredecessorId": z.object({ "account_id": z.string() }) }).strict().describe("The `predecessor_id` of a Receipt is not valid."), z.object({ "InvalidReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a Receipt is not valid."), z.object({ "InvalidSignerId": z.object({ "account_id": z.string() }) }).strict().describe("The `signer_id` of an ActionReceipt is not valid."), z.object({ "InvalidDataReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a DataReceiver within an ActionReceipt is not valid."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the returned data exceeded the limit in a DataReceipt."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The number of input data dependencies exceeds the limit in an ActionReceipt."), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of an ActionReceipt."), z.object({ "ReceiptSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("Receipt is bigger than the limit."), z.object({ "InvalidRefundTo": z.object({ "account_id": z.string() }) }).strict().describe("The `refund_to` of an ActionReceipt is not valid.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a receipt.") }).strict().describe("Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\nreceipt validation."), z.object({ "OnlyImplicitAccountCreationAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\nSee NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\nAlso, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\nTODO(#8598): This error is named very poorly. A better name would be\n`OnlyNamedAccountCreationAllowed`."), z.object({ "DeleteAccountWithLargeState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Delete account whose state is large is temporarily banned."), z.literal("DelegateActionInvalidSignature").describe("Signature does not match the provided actions and given signer public key."), z.object({ "DelegateActionSenderDoesNotMatchTxReceiver": z.object({ "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Receiver of the transaction doesn't match Sender of the delegate action"), z.literal("DelegateActionExpired").describe("Delegate action has expired. `max_block_height` is less than actual block height."), z.object({ "DelegateActionAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("The given public key doesn't exist for Sender account"), z.object({ "DelegateActionInvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "delegate_nonce": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce must be greater sender[public_key].nonce"), z.object({ "DelegateActionNonceTooLarge": z.object({ "delegate_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce is larger than the upper bound given by the block height"), z.object({ "GlobalContractDoesNotExist": z.object({ "identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("The kind of ActionError happened") }).describe("An error happened during Action execution") }).strict().describe("An error happened during Action execution"), z.object({ "InvalidTxError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Happens if a wrong AccessKey used or AccessKey has not enough permissions"), z.object({ "InvalidSignerId": z.object({ "signer_id": z.string() }) }).strict().describe("TX signer_id is not a valid [`AccountId`]"), z.object({ "SignerDoesNotExist": z.object({ "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("TX signer_id is not found in a storage"), z.object({ "InvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "tx_nonce": z.number().int().gte(0) }) }).strict().describe("Transaction nonce must be strictly greater than `account[access_key].nonce`."), z.object({ "NonceTooLarge": z.object({ "tx_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("Transaction nonce is larger than the upper bound given by the block height"), z.object({ "InvalidReceiverId": z.object({ "receiver_id": z.string() }) }).strict().describe("TX receiver_id is not a valid AccountId"), z.literal("InvalidSignature").describe("TX signature is not valid"), z.object({ "NotEnoughBalance": z.object({ "balance": z.string(), "cost": z.string(), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account does not have enough balance to cover TX cost"), z.object({ "LackBalanceForState": z.object({ "amount": z.string().describe("Required balance to cover the state."), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which doesn't have enough balance to cover storage.") }) }).strict().describe("Signer account doesn't have enough balance after transaction."), z.literal("CostOverflow").describe("An integer overflow occurred during transaction cost estimation."), z.literal("InvalidChain").describe("Transaction parent block hash doesn't belong to the current chain"), z.literal("Expired").describe("Transaction has expired"), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of a Transaction."), z.object({ "TransactionSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of serialized transaction exceeded the limit."), z.literal("InvalidTransactionVersion").describe("Transaction version is invalid."), z.object({ "StorageError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("StorageInternalError").describe("Key-value db internal failure"), z.object({ "MissingTrieValue": z.object({ "context": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("TrieIterator").describe("Missing trie value when reading from TrieIterator."), z.literal("TriePrefetchingStorage").describe("Missing trie value when reading from TriePrefetchingStorage."), z.literal("TrieMemoryPartialStorage").describe("Missing trie value when reading from TrieMemoryPartialStorage."), z.literal("TrieStorage").describe("Missing trie value when reading from TrieStorage.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Contexts in which `StorageError::MissingTrieValue` error might occur."), "hash": z.string() }) }).strict().describe("Requested trie value by its hash which is missing in storage."), z.literal("UnexpectedTrieValue").describe("Found trie node which shouldn't be part of state. Raised during\nvalidation of state sync parts where incorrect node was passed.\nTODO (#8997): consider including hash of trie node."), z.object({ "StorageInconsistentState": z.string() }).strict().describe("Either invalid state or key-value db is corrupted.\nFor PartialStorage it cannot be corrupted.\nError message is unreliable and for debugging purposes only. It's also probably ok to\npanic in every place that produces this error.\nWe can check if db is corrupted by verifying everything in the state trie."), z.object({ "FlatStorageBlockNotSupported": z.string() }).strict().describe("Flat storage error, meaning that it doesn't support some block anymore.\nWe guarantee that such block cannot become final, thus block processing\nmust resume normally."), z.object({ "MemTrieLoadingError": z.string() }).strict().describe("In-memory trie could not be loaded for some reason.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Errors which may occur during working with trie storages, storing\ntrie values (trie nodes and state values) by their hashes.") }).strict(), z.object({ "ShardCongested": z.object({ "congestion_level": z.number().describe("A value between 0 (no congestion) and 1 (max congestion)."), "shard_id": z.number().int().gte(0).describe("The congested shard.") }) }).strict().describe("The receiver shard of the transaction is too congested to accept new\ntransactions at the moment."), z.object({ "ShardStuck": z.object({ "missed_chunks": z.number().int().gte(0).describe("The number of blocks since the last included chunk of the shard."), "shard_id": z.number().int().gte(0).describe("The shard that fails making progress.") }) }).strict().describe("The receiver shard of the transaction missed several chunks and rejects\nnew transaction until it can make progress again.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An error happened during TX execution") }).strict().describe("An error happened during Transaction execution")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error returned in the ExecutionOutcome in case of failure") }).strict().describe("The execution has failed."), z.object({ "SuccessValue": z.string() }).strict().describe("The final action succeeded and returned some value or an empty vec encoded in base64."), z.object({ "SuccessReceiptId": z.string() }).strict().describe("The final action of the receipt returned a promise or the signed transaction was converted\nto a receipt. Contains the receipt_id of the generated receipt.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Execution status. Contains the result in case of successful execution."), "tokens_burnt": z.string().describe("The amount of tokens burnt corresponding to the burnt gas amount.\nThis value doesn't always equal to the `gas_burnt` multiplied by the gas price, because\nthe prepaid gas price might be lower than the actual gas price and it creates a deficit.\n`tokens_burnt` also contains the penalty subtracted from refunds, while\n`gas_burnt` only contains the gas that we actually burn for the execution.") }), "proof": z.array(z.object({ "direction": z.enum(["Left","Right"]), "hash": z.string() })) }).describe("The execution outcome of the signed transaction.") }).describe("Execution outcome of the transaction and all the subsequent receipts.\nCould be not finalized yet")
export type FinalExecutionOutcomeView = z.infer<typeof FinalExecutionOutcomeView>


export const FinalExecutionOutcomeWithReceiptView = z.object({ "receipts": z.array(z.object({ "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "priority": z.number().int().gte(0).default(0), "receipt": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "Action": z.object({ "actions": z.array(z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("CreateAccount"), z.object({ "DeployContract": z.object({ "code": z.string() }) }).strict(), z.object({ "FunctionCall": z.object({ "args": z.string().describe("This type is used to mark function arguments.\n\nNOTE: The main reason for this to exist (except the type-safety) is that the value is\ntransparently serialized and deserialized as a base64-encoded string when serde is used\n(serde_json)."), "deposit": z.string(), "gas": z.number().int().gte(0), "method_name": z.string() }) }).strict(), z.object({ "Transfer": z.object({ "deposit": z.string() }) }).strict(), z.object({ "Stake": z.object({ "public_key": z.string(), "stake": z.string() }) }).strict(), z.object({ "AddKey": z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("FullAccess"), z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "method_names": z.array(z.string()), "receiver_id": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the permission scope for an access key. Whether it is a function call or a full access key.") }).describe("Describes access key permission scope and nonce."), "public_key": z.string() }) }).strict(), z.object({ "DeleteKey": z.object({ "public_key": z.string() }) }).strict(), z.object({ "DeleteAccount": z.object({ "beneficiary_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "Delegate": z.object({ "delegate_action": z.object({ "actions": z.array(z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CreateAccount": z.record(z.any()).describe("Create account action") }).strict().describe("Create an (sub)account using a transaction `receiver_id` as an ID for\na new account ID must pass validation rules described here\n<https://nomicon.io/DataStructures/Account>."), z.object({ "DeployContract": z.object({ "code": z.string().describe("WebAssembly binary") }).describe("Deploy contract action") }).strict().describe("Sets a Wasm code to a receiver_id"), z.object({ "FunctionCall": z.object({ "args": z.string(), "deposit": z.string(), "gas": z.number().int().gte(0), "method_name": z.string() }) }).strict(), z.object({ "Transfer": z.object({ "deposit": z.string() }) }).strict(), z.object({ "Stake": z.object({ "public_key": z.string().describe("Validator key which will be used to sign transactions on behalf of signer_id"), "stake": z.string().describe("Amount of tokens to stake.") }).describe("An action which stakes signer_id tokens and setup's validator public key") }).strict(), z.object({ "AddKey": z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0).describe("Nonce for this access key, used for tx nonce generation. When access key is created, nonce\nis set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\nSee <https://github.com/near/nearcore/issues/3779> for more details."), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Allowance is a balance limit to use by this access key to pay for function call gas and\ntransaction fees. When this access key is used, both account balance and the allowance is\ndecreased by the same value.\n`None` means unlimited allowance.\nNOTE: To change or increase the allowance, the old access key needs to be deleted and a new\naccess key should be created.").optional(), "method_names": z.array(z.string()).describe("A list of method names that can be used. The access key only allows transactions with the\nfunction call of one of the given method names.\nEmpty list means any method name can be used."), "receiver_id": z.string().describe("The access key only allows transactions with the given receiver's account id.") }).describe("Grants limited permission to make transactions with FunctionCallActions\nThe permission can limit the allowed balance to be spent on the prepaid gas.\nIt also restrict the account ID of the receiver for this function call.\nIt also can restrict the method name for the allowed function calls.") }).strict(), z.literal("FullAccess").describe("Grants full access to the account.\nNOTE: It's used to replace account-level public keys.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Defines permissions for AccessKey").describe("Defines permissions for this access key.") }).describe("Access key provides limited access to an account. Each access key belongs to some account and\nis identified by a unique (within the account) public key. One account may have large number of\naccess keys. Access keys allow to act on behalf of the account by restricting transactions\nthat can be issued.\n`account_id,public_key` is a key in the state").describe("An access key with the permission"), "public_key": z.string().describe("A public key which will be associated with an access_key") }).describe("An action that adds key with public key associated") }).strict(), z.object({ "DeleteKey": z.object({ "public_key": z.string().describe("A public key associated with the access_key to be deleted.") }) }).strict(), z.object({ "DeleteAccount": z.object({ "beneficiary_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeployGlobalContract": z.object({ "code": z.string().describe("WebAssembly binary"), "deploy_mode": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("CodeHash").describe("Contract is deployed under its code hash.\nUsers will be able reference it by that hash.\nThis effectively makes the contract immutable."), z.literal("AccountId").describe("Contract is deployed under the owner account id.\nUsers will be able reference it by that account id.\nThis allows the owner to update the contract for all its users.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Deploy global contract action") }).strict(), z.object({ "UseGlobalContract": z.object({ "contract_identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Use global contract action") }).strict(), z.object({ "DeterministicStateInit": z.object({ "deposit": z.string(), "state_init": z.object({ "V1": z.object({ "code": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "data": z.record(z.string()) }) }).strict() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An Action that can be included in a transaction or receipt, excluding delegate actions. This type represents all possible action types except DelegateAction to prevent infinite recursion in meta-transactions.")).describe("List of actions to be executed.\n\nWith the meta transactions MVP defined in NEP-366, nested\nDelegateActions are not allowed. A separate type is used to enforce it."), "max_block_height": z.number().int().gte(0).describe("The maximal height of the block in the blockchain below which the given DelegateAction is valid."), "nonce": z.number().int().gte(0).describe("Nonce to ensure that the same delegate action is not sent twice by a\nrelayer and should match for given account's `public_key`.\nAfter this action is processed it will increment."), "public_key": z.string().describe("Public key used to sign this delegated action."), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("Receiver of the delegated actions."), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("Signer of the delegated actions") }).describe("This action allows to execute the inner actions behalf of the defined sender."), "signature": z.string() }) }).strict(), z.object({ "DeployGlobalContract": z.object({ "code": z.string() }) }).strict(), z.object({ "DeployGlobalContractByAccountId": z.object({ "code": z.string() }) }).strict(), z.object({ "UseGlobalContract": z.object({ "code_hash": z.string() }) }).strict(), z.object({ "UseGlobalContractByAccountId": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInit": z.object({ "code": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "hash": z.string() }).strict(), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "data": z.record(z.string()), "deposit": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })), "gas_price": z.string(), "input_data_ids": z.array(z.string()), "is_promise_yield": z.boolean().default(false), "output_data_receivers": z.array(z.object({ "data_id": z.string(), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") })), "refund_to": z.any().superRefine((x, ctx) => {
    const schemas = [z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "signer_public_key": z.string() }) }).strict(), z.object({ "Data": z.object({ "data": z.union([z.string(), z.null()]).default(null), "data_id": z.string(), "is_promise_resume": z.boolean().default(false) }) }).strict(), z.object({ "GlobalContractDistribution": z.object({ "already_delivered_shards": z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")), "code": z.string(), "id": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "target_shard": z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.") }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "receipt_id": z.string(), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") })).describe("Receipts generated from the transaction"), "receipts_outcome": z.array(z.object({ "block_hash": z.string(), "id": z.string(), "outcome": z.object({ "executor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("The id of the account on which the execution happens. For transaction this is signer_id,\nfor receipt this is receiver_id."), "gas_burnt": z.number().int().gte(0).describe("The amount of the gas burnt by the given transaction or receipt."), "logs": z.array(z.string()).describe("Logs from this transaction or receipt."), "metadata": z.object({ "gas_profile": z.union([z.array(z.object({ "cost": z.string(), "cost_category": z.string().describe("Either ACTION_COST or WASM_HOST_COST."), "gas_used": z.string() }).describe("Shows gas profile. More info [here](https://near.github.io/nearcore/architecture/gas/gas_profile.html?highlight=WASM_HOST_COST#example-transaction-gas-profile).")), z.null()]).optional(), "version": z.number().int().gte(0) }).describe("Execution metadata, versioned").default({"gas_profile":null,"version":1}), "receipt_ids": z.array(z.string()).describe("Receipt IDs generated by this transaction or receipt."), "status": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unknown").describe("The execution is pending or unknown."), z.object({ "Failure": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "ActionError": z.object({ "index": z.union([z.number().int().gte(0).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`"), z.null().describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`")]).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`").optional(), "kind": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccountAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage"), z.object({ "AccountDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when TX receiver_id doesn't exist (but action is not Action::CreateAccount)"), z.object({ "CreateAccountOnlyByRegistrar": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "registrar_account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A top-level account ID can only be created by registrar."), z.object({ "CreateAccountNotAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A newly created account must be under a namespace of the creator account"), z.object({ "ActorNoPermission": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "actor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\nor the first TX action is a `CreateAccount` action"), z.object({ "DeleteKeyDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("Account tries to remove an access key that doesn't exist"), z.object({ "AddKeyAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The public key is already used for an existing access key"), z.object({ "DeleteAccountStaking": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is staking and can not be deleted"), z.object({ "LackBalanceForState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which needs balance"), "amount": z.string().describe("Balance required to complete an action.") }) }).strict().describe("ActionReceipt can't be completed, because the remaining balance will not be enough to cover storage."), z.object({ "TriesToUnstake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is not yet staked, but tries to unstake"), z.object({ "TriesToStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "balance": z.string(), "locked": z.string(), "stake": z.string() }) }).strict().describe("The account doesn't have enough balance to increase the stake."), z.object({ "InsufficientStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "minimum_stake": z.string(), "stake": z.string() }) }).strict(), z.object({ "FunctionCallError": z.any().superRefine((x, ctx) => {
    const schemas = [z.enum(["WasmUnknownError","_EVMError"]), z.object({ "CompilationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "PrepareError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Serialization").describe("Error happened while serializing the module."), z.literal("Deserialization").describe("Error happened while deserializing the module."), z.literal("InternalMemoryDeclared").describe("Internal memory declaration has been found in the module."), z.literal("GasInstrumentation").describe("Gas instrumentation failed.\n\nThis most likely indicates the module isn't valid."), z.literal("StackHeightInstrumentation").describe("Stack instrumentation failed.\n\nThis  most likely indicates the module isn't valid."), z.literal("Instantiate").describe("Error happened during instantiation.\n\nThis might indicate that `start` function trapped, or module isn't\ninstantiable and/or un-linkable."), z.literal("Memory").describe("Error creating memory."), z.literal("TooManyFunctions").describe("Contract contains too many functions."), z.literal("TooManyLocals").describe("Contract contains too many locals."), z.literal("TooManyTables").describe("Contract contains too many tables."), z.literal("TooManyTableElements").describe("Contract contains too many table elements.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error that can occur while preparing or executing Wasm smart-contract.") }).strict(), z.object({ "WasmerCompileError": z.object({ "msg": z.string() }) }).strict().describe("This is for defense in depth.\nWe expect our runtime-independent preparation code to fully catch all invalid wasms,\nbut, if it ever misses something we’ll emit this error")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Wasm compilation error"), z.object({ "LinkError": z.object({ "msg": z.string() }) }).strict().describe("Wasm binary env link error\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "MethodResolveError": z.enum(["MethodEmptyName","MethodNotFound","MethodInvalidSignature"]) }).strict().describe("Import/export resolve error"), z.object({ "WasmTrap": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unreachable").describe("An `unreachable` opcode was executed."), z.literal("IncorrectCallIndirectSignature").describe("Call indirect incorrect signature trap."), z.literal("MemoryOutOfBounds").describe("Memory out of bounds trap."), z.literal("CallIndirectOOB").describe("Call indirect out of bounds trap."), z.literal("IllegalArithmetic").describe("An arithmetic exception, e.g. divided by zero."), z.literal("MisalignedAtomicAccess").describe("Misaligned atomic access trap."), z.literal("IndirectCallToNull").describe("Indirect call to null."), z.literal("StackOverflow").describe("Stack overflow."), z.literal("GenericTrap").describe("Generic trap.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("A kind of a trap happened during execution of a binary") }).strict().describe("A trap happened during execution of a binary\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "HostError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("BadUTF16").describe("String encoding is bad UTF-16 sequence"), z.literal("BadUTF8").describe("String encoding is bad UTF-8 sequence"), z.literal("GasExceeded").describe("Exceeded the prepaid gas"), z.literal("GasLimitExceeded").describe("Exceeded the maximum amount of gas allowed to burn per contract"), z.literal("BalanceExceeded").describe("Exceeded the account balance"), z.literal("EmptyMethodName").describe("Tried to call an empty method name"), z.object({ "GuestPanic": z.object({ "panic_msg": z.string() }) }).strict().describe("Smart contract panicked"), z.literal("IntegerOverflow").describe("IntegerOverflow happened during a contract execution"), z.object({ "InvalidPromiseIndex": z.object({ "promise_idx": z.number().int().gte(0) }) }).strict().describe("`promise_idx` does not correspond to existing promises"), z.literal("CannotAppendActionToJointPromise").describe("Actions can only be appended to non-joint promise."), z.literal("CannotReturnJointPromise").describe("Returning joint promise is currently prohibited"), z.object({ "InvalidPromiseResultIndex": z.object({ "result_idx": z.number().int().gte(0) }) }).strict().describe("Accessed invalid promise result index"), z.object({ "InvalidRegisterId": z.object({ "register_id": z.number().int().gte(0) }) }).strict().describe("Accessed invalid register id"), z.object({ "IteratorWasInvalidated": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie"), z.literal("MemoryAccessViolation").describe("Accessed memory outside the bounds"), z.object({ "InvalidReceiptIndex": z.object({ "receipt_index": z.number().int().gte(0) }) }).strict().describe("VM Logic returned an invalid receipt index"), z.object({ "InvalidIteratorIndex": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator index `iterator_index` does not exist"), z.literal("InvalidAccountId").describe("VM Logic returned an invalid account id"), z.literal("InvalidMethodName").describe("VM Logic returned an invalid method name"), z.literal("InvalidPublicKey").describe("VM Logic provided an invalid public key"), z.object({ "ProhibitedInView": z.object({ "method_name": z.string() }) }).strict().describe("`method_name` is not allowed in view calls"), z.object({ "NumberOfLogsExceeded": z.object({ "limit": z.number().int().gte(0) }) }).strict().describe("The total number of logs will exceed the limit."), z.object({ "KeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage key length exceeded the limit."), z.object({ "ValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage value length exceeded the limit."), z.object({ "TotalLogLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The total log length exceeded the limit."), z.object({ "NumberPromisesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_promises": z.number().int().gte(0) }) }).strict().describe("The maximum number of promises within a FunctionCall exceeded the limit."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The maximum number of input data dependencies exceeded the limit."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The returned value length exceeded the limit."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The contract size for DeployContract action exceeded the limit."), z.object({ "Deprecated": z.object({ "method_name": z.string() }) }).strict().describe("The host function was deprecated."), z.object({ "ECRecoverError": z.object({ "msg": z.string() }) }).strict().describe("General errors for ECDSA recover."), z.object({ "AltBn128InvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to alt_bn128 family of functions (e.g., point which isn't\non the curve)."), z.object({ "Ed25519VerifyInvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to ed25519 signature verification function (e.g. signature cannot be\nderived from bytes).")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Note: this is only to deserialize old data, use execution error for new data"), z.object({ "ExecutionError": z.string() }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Serializable version of `near-vm-runner::FunctionCallError`.\n\nMust never reorder/remove elements, can only add new variants at the end (but do that very\ncarefully). It describes stable serialization format, and only used by serialization logic.") }).strict().describe("An error occurred during a `FunctionCall` Action, parameter is debug message."), z.object({ "NewReceiptValidationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidPredecessorId": z.object({ "account_id": z.string() }) }).strict().describe("The `predecessor_id` of a Receipt is not valid."), z.object({ "InvalidReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a Receipt is not valid."), z.object({ "InvalidSignerId": z.object({ "account_id": z.string() }) }).strict().describe("The `signer_id` of an ActionReceipt is not valid."), z.object({ "InvalidDataReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a DataReceiver within an ActionReceipt is not valid."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the returned data exceeded the limit in a DataReceipt."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The number of input data dependencies exceeds the limit in an ActionReceipt."), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of an ActionReceipt."), z.object({ "ReceiptSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("Receipt is bigger than the limit."), z.object({ "InvalidRefundTo": z.object({ "account_id": z.string() }) }).strict().describe("The `refund_to` of an ActionReceipt is not valid.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a receipt.") }).strict().describe("Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\nreceipt validation."), z.object({ "OnlyImplicitAccountCreationAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\nSee NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\nAlso, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\nTODO(#8598): This error is named very poorly. A better name would be\n`OnlyNamedAccountCreationAllowed`."), z.object({ "DeleteAccountWithLargeState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Delete account whose state is large is temporarily banned."), z.literal("DelegateActionInvalidSignature").describe("Signature does not match the provided actions and given signer public key."), z.object({ "DelegateActionSenderDoesNotMatchTxReceiver": z.object({ "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Receiver of the transaction doesn't match Sender of the delegate action"), z.literal("DelegateActionExpired").describe("Delegate action has expired. `max_block_height` is less than actual block height."), z.object({ "DelegateActionAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("The given public key doesn't exist for Sender account"), z.object({ "DelegateActionInvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "delegate_nonce": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce must be greater sender[public_key].nonce"), z.object({ "DelegateActionNonceTooLarge": z.object({ "delegate_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce is larger than the upper bound given by the block height"), z.object({ "GlobalContractDoesNotExist": z.object({ "identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("The kind of ActionError happened") }).describe("An error happened during Action execution") }).strict().describe("An error happened during Action execution"), z.object({ "InvalidTxError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Happens if a wrong AccessKey used or AccessKey has not enough permissions"), z.object({ "InvalidSignerId": z.object({ "signer_id": z.string() }) }).strict().describe("TX signer_id is not a valid [`AccountId`]"), z.object({ "SignerDoesNotExist": z.object({ "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("TX signer_id is not found in a storage"), z.object({ "InvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "tx_nonce": z.number().int().gte(0) }) }).strict().describe("Transaction nonce must be strictly greater than `account[access_key].nonce`."), z.object({ "NonceTooLarge": z.object({ "tx_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("Transaction nonce is larger than the upper bound given by the block height"), z.object({ "InvalidReceiverId": z.object({ "receiver_id": z.string() }) }).strict().describe("TX receiver_id is not a valid AccountId"), z.literal("InvalidSignature").describe("TX signature is not valid"), z.object({ "NotEnoughBalance": z.object({ "balance": z.string(), "cost": z.string(), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account does not have enough balance to cover TX cost"), z.object({ "LackBalanceForState": z.object({ "amount": z.string().describe("Required balance to cover the state."), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which doesn't have enough balance to cover storage.") }) }).strict().describe("Signer account doesn't have enough balance after transaction."), z.literal("CostOverflow").describe("An integer overflow occurred during transaction cost estimation."), z.literal("InvalidChain").describe("Transaction parent block hash doesn't belong to the current chain"), z.literal("Expired").describe("Transaction has expired"), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of a Transaction."), z.object({ "TransactionSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of serialized transaction exceeded the limit."), z.literal("InvalidTransactionVersion").describe("Transaction version is invalid."), z.object({ "StorageError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("StorageInternalError").describe("Key-value db internal failure"), z.object({ "MissingTrieValue": z.object({ "context": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("TrieIterator").describe("Missing trie value when reading from TrieIterator."), z.literal("TriePrefetchingStorage").describe("Missing trie value when reading from TriePrefetchingStorage."), z.literal("TrieMemoryPartialStorage").describe("Missing trie value when reading from TrieMemoryPartialStorage."), z.literal("TrieStorage").describe("Missing trie value when reading from TrieStorage.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Contexts in which `StorageError::MissingTrieValue` error might occur."), "hash": z.string() }) }).strict().describe("Requested trie value by its hash which is missing in storage."), z.literal("UnexpectedTrieValue").describe("Found trie node which shouldn't be part of state. Raised during\nvalidation of state sync parts where incorrect node was passed.\nTODO (#8997): consider including hash of trie node."), z.object({ "StorageInconsistentState": z.string() }).strict().describe("Either invalid state or key-value db is corrupted.\nFor PartialStorage it cannot be corrupted.\nError message is unreliable and for debugging purposes only. It's also probably ok to\npanic in every place that produces this error.\nWe can check if db is corrupted by verifying everything in the state trie."), z.object({ "FlatStorageBlockNotSupported": z.string() }).strict().describe("Flat storage error, meaning that it doesn't support some block anymore.\nWe guarantee that such block cannot become final, thus block processing\nmust resume normally."), z.object({ "MemTrieLoadingError": z.string() }).strict().describe("In-memory trie could not be loaded for some reason.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Errors which may occur during working with trie storages, storing\ntrie values (trie nodes and state values) by their hashes.") }).strict(), z.object({ "ShardCongested": z.object({ "congestion_level": z.number().describe("A value between 0 (no congestion) and 1 (max congestion)."), "shard_id": z.number().int().gte(0).describe("The congested shard.") }) }).strict().describe("The receiver shard of the transaction is too congested to accept new\ntransactions at the moment."), z.object({ "ShardStuck": z.object({ "missed_chunks": z.number().int().gte(0).describe("The number of blocks since the last included chunk of the shard."), "shard_id": z.number().int().gte(0).describe("The shard that fails making progress.") }) }).strict().describe("The receiver shard of the transaction missed several chunks and rejects\nnew transaction until it can make progress again.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An error happened during TX execution") }).strict().describe("An error happened during Transaction execution")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error returned in the ExecutionOutcome in case of failure") }).strict().describe("The execution has failed."), z.object({ "SuccessValue": z.string() }).strict().describe("The final action succeeded and returned some value or an empty vec encoded in base64."), z.object({ "SuccessReceiptId": z.string() }).strict().describe("The final action of the receipt returned a promise or the signed transaction was converted\nto a receipt. Contains the receipt_id of the generated receipt.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Execution status. Contains the result in case of successful execution."), "tokens_burnt": z.string().describe("The amount of tokens burnt corresponding to the burnt gas amount.\nThis value doesn't always equal to the `gas_burnt` multiplied by the gas price, because\nthe prepaid gas price might be lower than the actual gas price and it creates a deficit.\n`tokens_burnt` also contains the penalty subtracted from refunds, while\n`gas_burnt` only contains the gas that we actually burn for the execution.") }), "proof": z.array(z.object({ "direction": z.enum(["Left","Right"]), "hash": z.string() })) })).describe("The execution outcome of receipts."), "status": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("NotStarted").describe("The execution has not yet started."), z.literal("Started").describe("The execution has started and still going."), z.object({ "Failure": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "ActionError": z.object({ "index": z.union([z.number().int().gte(0).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`"), z.null().describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`")]).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`").optional(), "kind": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccountAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage"), z.object({ "AccountDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when TX receiver_id doesn't exist (but action is not Action::CreateAccount)"), z.object({ "CreateAccountOnlyByRegistrar": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "registrar_account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A top-level account ID can only be created by registrar."), z.object({ "CreateAccountNotAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A newly created account must be under a namespace of the creator account"), z.object({ "ActorNoPermission": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "actor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\nor the first TX action is a `CreateAccount` action"), z.object({ "DeleteKeyDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("Account tries to remove an access key that doesn't exist"), z.object({ "AddKeyAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The public key is already used for an existing access key"), z.object({ "DeleteAccountStaking": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is staking and can not be deleted"), z.object({ "LackBalanceForState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which needs balance"), "amount": z.string().describe("Balance required to complete an action.") }) }).strict().describe("ActionReceipt can't be completed, because the remaining balance will not be enough to cover storage."), z.object({ "TriesToUnstake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is not yet staked, but tries to unstake"), z.object({ "TriesToStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "balance": z.string(), "locked": z.string(), "stake": z.string() }) }).strict().describe("The account doesn't have enough balance to increase the stake."), z.object({ "InsufficientStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "minimum_stake": z.string(), "stake": z.string() }) }).strict(), z.object({ "FunctionCallError": z.any().superRefine((x, ctx) => {
    const schemas = [z.enum(["WasmUnknownError","_EVMError"]), z.object({ "CompilationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "PrepareError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Serialization").describe("Error happened while serializing the module."), z.literal("Deserialization").describe("Error happened while deserializing the module."), z.literal("InternalMemoryDeclared").describe("Internal memory declaration has been found in the module."), z.literal("GasInstrumentation").describe("Gas instrumentation failed.\n\nThis most likely indicates the module isn't valid."), z.literal("StackHeightInstrumentation").describe("Stack instrumentation failed.\n\nThis  most likely indicates the module isn't valid."), z.literal("Instantiate").describe("Error happened during instantiation.\n\nThis might indicate that `start` function trapped, or module isn't\ninstantiable and/or un-linkable."), z.literal("Memory").describe("Error creating memory."), z.literal("TooManyFunctions").describe("Contract contains too many functions."), z.literal("TooManyLocals").describe("Contract contains too many locals."), z.literal("TooManyTables").describe("Contract contains too many tables."), z.literal("TooManyTableElements").describe("Contract contains too many table elements.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error that can occur while preparing or executing Wasm smart-contract.") }).strict(), z.object({ "WasmerCompileError": z.object({ "msg": z.string() }) }).strict().describe("This is for defense in depth.\nWe expect our runtime-independent preparation code to fully catch all invalid wasms,\nbut, if it ever misses something we’ll emit this error")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Wasm compilation error"), z.object({ "LinkError": z.object({ "msg": z.string() }) }).strict().describe("Wasm binary env link error\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "MethodResolveError": z.enum(["MethodEmptyName","MethodNotFound","MethodInvalidSignature"]) }).strict().describe("Import/export resolve error"), z.object({ "WasmTrap": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unreachable").describe("An `unreachable` opcode was executed."), z.literal("IncorrectCallIndirectSignature").describe("Call indirect incorrect signature trap."), z.literal("MemoryOutOfBounds").describe("Memory out of bounds trap."), z.literal("CallIndirectOOB").describe("Call indirect out of bounds trap."), z.literal("IllegalArithmetic").describe("An arithmetic exception, e.g. divided by zero."), z.literal("MisalignedAtomicAccess").describe("Misaligned atomic access trap."), z.literal("IndirectCallToNull").describe("Indirect call to null."), z.literal("StackOverflow").describe("Stack overflow."), z.literal("GenericTrap").describe("Generic trap.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("A kind of a trap happened during execution of a binary") }).strict().describe("A trap happened during execution of a binary\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "HostError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("BadUTF16").describe("String encoding is bad UTF-16 sequence"), z.literal("BadUTF8").describe("String encoding is bad UTF-8 sequence"), z.literal("GasExceeded").describe("Exceeded the prepaid gas"), z.literal("GasLimitExceeded").describe("Exceeded the maximum amount of gas allowed to burn per contract"), z.literal("BalanceExceeded").describe("Exceeded the account balance"), z.literal("EmptyMethodName").describe("Tried to call an empty method name"), z.object({ "GuestPanic": z.object({ "panic_msg": z.string() }) }).strict().describe("Smart contract panicked"), z.literal("IntegerOverflow").describe("IntegerOverflow happened during a contract execution"), z.object({ "InvalidPromiseIndex": z.object({ "promise_idx": z.number().int().gte(0) }) }).strict().describe("`promise_idx` does not correspond to existing promises"), z.literal("CannotAppendActionToJointPromise").describe("Actions can only be appended to non-joint promise."), z.literal("CannotReturnJointPromise").describe("Returning joint promise is currently prohibited"), z.object({ "InvalidPromiseResultIndex": z.object({ "result_idx": z.number().int().gte(0) }) }).strict().describe("Accessed invalid promise result index"), z.object({ "InvalidRegisterId": z.object({ "register_id": z.number().int().gte(0) }) }).strict().describe("Accessed invalid register id"), z.object({ "IteratorWasInvalidated": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie"), z.literal("MemoryAccessViolation").describe("Accessed memory outside the bounds"), z.object({ "InvalidReceiptIndex": z.object({ "receipt_index": z.number().int().gte(0) }) }).strict().describe("VM Logic returned an invalid receipt index"), z.object({ "InvalidIteratorIndex": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator index `iterator_index` does not exist"), z.literal("InvalidAccountId").describe("VM Logic returned an invalid account id"), z.literal("InvalidMethodName").describe("VM Logic returned an invalid method name"), z.literal("InvalidPublicKey").describe("VM Logic provided an invalid public key"), z.object({ "ProhibitedInView": z.object({ "method_name": z.string() }) }).strict().describe("`method_name` is not allowed in view calls"), z.object({ "NumberOfLogsExceeded": z.object({ "limit": z.number().int().gte(0) }) }).strict().describe("The total number of logs will exceed the limit."), z.object({ "KeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage key length exceeded the limit."), z.object({ "ValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage value length exceeded the limit."), z.object({ "TotalLogLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The total log length exceeded the limit."), z.object({ "NumberPromisesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_promises": z.number().int().gte(0) }) }).strict().describe("The maximum number of promises within a FunctionCall exceeded the limit."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The maximum number of input data dependencies exceeded the limit."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The returned value length exceeded the limit."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The contract size for DeployContract action exceeded the limit."), z.object({ "Deprecated": z.object({ "method_name": z.string() }) }).strict().describe("The host function was deprecated."), z.object({ "ECRecoverError": z.object({ "msg": z.string() }) }).strict().describe("General errors for ECDSA recover."), z.object({ "AltBn128InvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to alt_bn128 family of functions (e.g., point which isn't\non the curve)."), z.object({ "Ed25519VerifyInvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to ed25519 signature verification function (e.g. signature cannot be\nderived from bytes).")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Note: this is only to deserialize old data, use execution error for new data"), z.object({ "ExecutionError": z.string() }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Serializable version of `near-vm-runner::FunctionCallError`.\n\nMust never reorder/remove elements, can only add new variants at the end (but do that very\ncarefully). It describes stable serialization format, and only used by serialization logic.") }).strict().describe("An error occurred during a `FunctionCall` Action, parameter is debug message."), z.object({ "NewReceiptValidationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidPredecessorId": z.object({ "account_id": z.string() }) }).strict().describe("The `predecessor_id` of a Receipt is not valid."), z.object({ "InvalidReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a Receipt is not valid."), z.object({ "InvalidSignerId": z.object({ "account_id": z.string() }) }).strict().describe("The `signer_id` of an ActionReceipt is not valid."), z.object({ "InvalidDataReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a DataReceiver within an ActionReceipt is not valid."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the returned data exceeded the limit in a DataReceipt."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The number of input data dependencies exceeds the limit in an ActionReceipt."), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of an ActionReceipt."), z.object({ "ReceiptSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("Receipt is bigger than the limit."), z.object({ "InvalidRefundTo": z.object({ "account_id": z.string() }) }).strict().describe("The `refund_to` of an ActionReceipt is not valid.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a receipt.") }).strict().describe("Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\nreceipt validation."), z.object({ "OnlyImplicitAccountCreationAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\nSee NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\nAlso, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\nTODO(#8598): This error is named very poorly. A better name would be\n`OnlyNamedAccountCreationAllowed`."), z.object({ "DeleteAccountWithLargeState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Delete account whose state is large is temporarily banned."), z.literal("DelegateActionInvalidSignature").describe("Signature does not match the provided actions and given signer public key."), z.object({ "DelegateActionSenderDoesNotMatchTxReceiver": z.object({ "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Receiver of the transaction doesn't match Sender of the delegate action"), z.literal("DelegateActionExpired").describe("Delegate action has expired. `max_block_height` is less than actual block height."), z.object({ "DelegateActionAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("The given public key doesn't exist for Sender account"), z.object({ "DelegateActionInvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "delegate_nonce": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce must be greater sender[public_key].nonce"), z.object({ "DelegateActionNonceTooLarge": z.object({ "delegate_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce is larger than the upper bound given by the block height"), z.object({ "GlobalContractDoesNotExist": z.object({ "identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("The kind of ActionError happened") }).describe("An error happened during Action execution") }).strict().describe("An error happened during Action execution"), z.object({ "InvalidTxError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Happens if a wrong AccessKey used or AccessKey has not enough permissions"), z.object({ "InvalidSignerId": z.object({ "signer_id": z.string() }) }).strict().describe("TX signer_id is not a valid [`AccountId`]"), z.object({ "SignerDoesNotExist": z.object({ "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("TX signer_id is not found in a storage"), z.object({ "InvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "tx_nonce": z.number().int().gte(0) }) }).strict().describe("Transaction nonce must be strictly greater than `account[access_key].nonce`."), z.object({ "NonceTooLarge": z.object({ "tx_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("Transaction nonce is larger than the upper bound given by the block height"), z.object({ "InvalidReceiverId": z.object({ "receiver_id": z.string() }) }).strict().describe("TX receiver_id is not a valid AccountId"), z.literal("InvalidSignature").describe("TX signature is not valid"), z.object({ "NotEnoughBalance": z.object({ "balance": z.string(), "cost": z.string(), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account does not have enough balance to cover TX cost"), z.object({ "LackBalanceForState": z.object({ "amount": z.string().describe("Required balance to cover the state."), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which doesn't have enough balance to cover storage.") }) }).strict().describe("Signer account doesn't have enough balance after transaction."), z.literal("CostOverflow").describe("An integer overflow occurred during transaction cost estimation."), z.literal("InvalidChain").describe("Transaction parent block hash doesn't belong to the current chain"), z.literal("Expired").describe("Transaction has expired"), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of a Transaction."), z.object({ "TransactionSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of serialized transaction exceeded the limit."), z.literal("InvalidTransactionVersion").describe("Transaction version is invalid."), z.object({ "StorageError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("StorageInternalError").describe("Key-value db internal failure"), z.object({ "MissingTrieValue": z.object({ "context": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("TrieIterator").describe("Missing trie value when reading from TrieIterator."), z.literal("TriePrefetchingStorage").describe("Missing trie value when reading from TriePrefetchingStorage."), z.literal("TrieMemoryPartialStorage").describe("Missing trie value when reading from TrieMemoryPartialStorage."), z.literal("TrieStorage").describe("Missing trie value when reading from TrieStorage.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Contexts in which `StorageError::MissingTrieValue` error might occur."), "hash": z.string() }) }).strict().describe("Requested trie value by its hash which is missing in storage."), z.literal("UnexpectedTrieValue").describe("Found trie node which shouldn't be part of state. Raised during\nvalidation of state sync parts where incorrect node was passed.\nTODO (#8997): consider including hash of trie node."), z.object({ "StorageInconsistentState": z.string() }).strict().describe("Either invalid state or key-value db is corrupted.\nFor PartialStorage it cannot be corrupted.\nError message is unreliable and for debugging purposes only. It's also probably ok to\npanic in every place that produces this error.\nWe can check if db is corrupted by verifying everything in the state trie."), z.object({ "FlatStorageBlockNotSupported": z.string() }).strict().describe("Flat storage error, meaning that it doesn't support some block anymore.\nWe guarantee that such block cannot become final, thus block processing\nmust resume normally."), z.object({ "MemTrieLoadingError": z.string() }).strict().describe("In-memory trie could not be loaded for some reason.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Errors which may occur during working with trie storages, storing\ntrie values (trie nodes and state values) by their hashes.") }).strict(), z.object({ "ShardCongested": z.object({ "congestion_level": z.number().describe("A value between 0 (no congestion) and 1 (max congestion)."), "shard_id": z.number().int().gte(0).describe("The congested shard.") }) }).strict().describe("The receiver shard of the transaction is too congested to accept new\ntransactions at the moment."), z.object({ "ShardStuck": z.object({ "missed_chunks": z.number().int().gte(0).describe("The number of blocks since the last included chunk of the shard."), "shard_id": z.number().int().gte(0).describe("The shard that fails making progress.") }) }).strict().describe("The receiver shard of the transaction missed several chunks and rejects\nnew transaction until it can make progress again.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An error happened during TX execution") }).strict().describe("An error happened during Transaction execution")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error returned in the ExecutionOutcome in case of failure") }).strict().describe("The execution has failed with the given error."), z.object({ "SuccessValue": z.string() }).strict().describe("The execution has succeeded and returned some value or an empty vec encoded in base64.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Execution status defined by chain.rs:get_final_transaction_result\nFinalExecutionStatus::NotStarted - the tx is not converted to the receipt yet\nFinalExecutionStatus::Started - we have at least 1 receipt, but the first leaf receipt_id (using dfs) hasn't finished the execution\nFinalExecutionStatus::Failure - the result of the first leaf receipt_id\nFinalExecutionStatus::SuccessValue - the result of the first leaf receipt_id"), "transaction": z.object({ "actions": z.array(z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("CreateAccount"), z.object({ "DeployContract": z.object({ "code": z.string() }) }).strict(), z.object({ "FunctionCall": z.object({ "args": z.string().describe("This type is used to mark function arguments.\n\nNOTE: The main reason for this to exist (except the type-safety) is that the value is\ntransparently serialized and deserialized as a base64-encoded string when serde is used\n(serde_json)."), "deposit": z.string(), "gas": z.number().int().gte(0), "method_name": z.string() }) }).strict(), z.object({ "Transfer": z.object({ "deposit": z.string() }) }).strict(), z.object({ "Stake": z.object({ "public_key": z.string(), "stake": z.string() }) }).strict(), z.object({ "AddKey": z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("FullAccess"), z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "method_names": z.array(z.string()), "receiver_id": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the permission scope for an access key. Whether it is a function call or a full access key.") }).describe("Describes access key permission scope and nonce."), "public_key": z.string() }) }).strict(), z.object({ "DeleteKey": z.object({ "public_key": z.string() }) }).strict(), z.object({ "DeleteAccount": z.object({ "beneficiary_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "Delegate": z.object({ "delegate_action": z.object({ "actions": z.array(z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CreateAccount": z.record(z.any()).describe("Create account action") }).strict().describe("Create an (sub)account using a transaction `receiver_id` as an ID for\na new account ID must pass validation rules described here\n<https://nomicon.io/DataStructures/Account>."), z.object({ "DeployContract": z.object({ "code": z.string().describe("WebAssembly binary") }).describe("Deploy contract action") }).strict().describe("Sets a Wasm code to a receiver_id"), z.object({ "FunctionCall": z.object({ "args": z.string(), "deposit": z.string(), "gas": z.number().int().gte(0), "method_name": z.string() }) }).strict(), z.object({ "Transfer": z.object({ "deposit": z.string() }) }).strict(), z.object({ "Stake": z.object({ "public_key": z.string().describe("Validator key which will be used to sign transactions on behalf of signer_id"), "stake": z.string().describe("Amount of tokens to stake.") }).describe("An action which stakes signer_id tokens and setup's validator public key") }).strict(), z.object({ "AddKey": z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0).describe("Nonce for this access key, used for tx nonce generation. When access key is created, nonce\nis set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\nSee <https://github.com/near/nearcore/issues/3779> for more details."), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Allowance is a balance limit to use by this access key to pay for function call gas and\ntransaction fees. When this access key is used, both account balance and the allowance is\ndecreased by the same value.\n`None` means unlimited allowance.\nNOTE: To change or increase the allowance, the old access key needs to be deleted and a new\naccess key should be created.").optional(), "method_names": z.array(z.string()).describe("A list of method names that can be used. The access key only allows transactions with the\nfunction call of one of the given method names.\nEmpty list means any method name can be used."), "receiver_id": z.string().describe("The access key only allows transactions with the given receiver's account id.") }).describe("Grants limited permission to make transactions with FunctionCallActions\nThe permission can limit the allowed balance to be spent on the prepaid gas.\nIt also restrict the account ID of the receiver for this function call.\nIt also can restrict the method name for the allowed function calls.") }).strict(), z.literal("FullAccess").describe("Grants full access to the account.\nNOTE: It's used to replace account-level public keys.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Defines permissions for AccessKey").describe("Defines permissions for this access key.") }).describe("Access key provides limited access to an account. Each access key belongs to some account and\nis identified by a unique (within the account) public key. One account may have large number of\naccess keys. Access keys allow to act on behalf of the account by restricting transactions\nthat can be issued.\n`account_id,public_key` is a key in the state").describe("An access key with the permission"), "public_key": z.string().describe("A public key which will be associated with an access_key") }).describe("An action that adds key with public key associated") }).strict(), z.object({ "DeleteKey": z.object({ "public_key": z.string().describe("A public key associated with the access_key to be deleted.") }) }).strict(), z.object({ "DeleteAccount": z.object({ "beneficiary_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeployGlobalContract": z.object({ "code": z.string().describe("WebAssembly binary"), "deploy_mode": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("CodeHash").describe("Contract is deployed under its code hash.\nUsers will be able reference it by that hash.\nThis effectively makes the contract immutable."), z.literal("AccountId").describe("Contract is deployed under the owner account id.\nUsers will be able reference it by that account id.\nThis allows the owner to update the contract for all its users.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Deploy global contract action") }).strict(), z.object({ "UseGlobalContract": z.object({ "contract_identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Use global contract action") }).strict(), z.object({ "DeterministicStateInit": z.object({ "deposit": z.string(), "state_init": z.object({ "V1": z.object({ "code": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "data": z.record(z.string()) }) }).strict() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An Action that can be included in a transaction or receipt, excluding delegate actions. This type represents all possible action types except DelegateAction to prevent infinite recursion in meta-transactions.")).describe("List of actions to be executed.\n\nWith the meta transactions MVP defined in NEP-366, nested\nDelegateActions are not allowed. A separate type is used to enforce it."), "max_block_height": z.number().int().gte(0).describe("The maximal height of the block in the blockchain below which the given DelegateAction is valid."), "nonce": z.number().int().gte(0).describe("Nonce to ensure that the same delegate action is not sent twice by a\nrelayer and should match for given account's `public_key`.\nAfter this action is processed it will increment."), "public_key": z.string().describe("Public key used to sign this delegated action."), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("Receiver of the delegated actions."), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("Signer of the delegated actions") }).describe("This action allows to execute the inner actions behalf of the defined sender."), "signature": z.string() }) }).strict(), z.object({ "DeployGlobalContract": z.object({ "code": z.string() }) }).strict(), z.object({ "DeployGlobalContractByAccountId": z.object({ "code": z.string() }) }).strict(), z.object({ "UseGlobalContract": z.object({ "code_hash": z.string() }) }).strict(), z.object({ "UseGlobalContractByAccountId": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInit": z.object({ "code": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "hash": z.string() }).strict(), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "data": z.record(z.string()), "deposit": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })), "hash": z.string(), "nonce": z.number().int().gte(0), "priority_fee": z.number().int().gte(0).default(0), "public_key": z.string(), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "signature": z.string(), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).describe("Signed Transaction"), "transaction_outcome": z.object({ "block_hash": z.string(), "id": z.string(), "outcome": z.object({ "executor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("The id of the account on which the execution happens. For transaction this is signer_id,\nfor receipt this is receiver_id."), "gas_burnt": z.number().int().gte(0).describe("The amount of the gas burnt by the given transaction or receipt."), "logs": z.array(z.string()).describe("Logs from this transaction or receipt."), "metadata": z.object({ "gas_profile": z.union([z.array(z.object({ "cost": z.string(), "cost_category": z.string().describe("Either ACTION_COST or WASM_HOST_COST."), "gas_used": z.string() }).describe("Shows gas profile. More info [here](https://near.github.io/nearcore/architecture/gas/gas_profile.html?highlight=WASM_HOST_COST#example-transaction-gas-profile).")), z.null()]).optional(), "version": z.number().int().gte(0) }).describe("Execution metadata, versioned").default({"gas_profile":null,"version":1}), "receipt_ids": z.array(z.string()).describe("Receipt IDs generated by this transaction or receipt."), "status": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unknown").describe("The execution is pending or unknown."), z.object({ "Failure": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "ActionError": z.object({ "index": z.union([z.number().int().gte(0).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`"), z.null().describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`")]).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`").optional(), "kind": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccountAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage"), z.object({ "AccountDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when TX receiver_id doesn't exist (but action is not Action::CreateAccount)"), z.object({ "CreateAccountOnlyByRegistrar": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "registrar_account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A top-level account ID can only be created by registrar."), z.object({ "CreateAccountNotAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A newly created account must be under a namespace of the creator account"), z.object({ "ActorNoPermission": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "actor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\nor the first TX action is a `CreateAccount` action"), z.object({ "DeleteKeyDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("Account tries to remove an access key that doesn't exist"), z.object({ "AddKeyAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The public key is already used for an existing access key"), z.object({ "DeleteAccountStaking": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is staking and can not be deleted"), z.object({ "LackBalanceForState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which needs balance"), "amount": z.string().describe("Balance required to complete an action.") }) }).strict().describe("ActionReceipt can't be completed, because the remaining balance will not be enough to cover storage."), z.object({ "TriesToUnstake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is not yet staked, but tries to unstake"), z.object({ "TriesToStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "balance": z.string(), "locked": z.string(), "stake": z.string() }) }).strict().describe("The account doesn't have enough balance to increase the stake."), z.object({ "InsufficientStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "minimum_stake": z.string(), "stake": z.string() }) }).strict(), z.object({ "FunctionCallError": z.any().superRefine((x, ctx) => {
    const schemas = [z.enum(["WasmUnknownError","_EVMError"]), z.object({ "CompilationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "PrepareError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Serialization").describe("Error happened while serializing the module."), z.literal("Deserialization").describe("Error happened while deserializing the module."), z.literal("InternalMemoryDeclared").describe("Internal memory declaration has been found in the module."), z.literal("GasInstrumentation").describe("Gas instrumentation failed.\n\nThis most likely indicates the module isn't valid."), z.literal("StackHeightInstrumentation").describe("Stack instrumentation failed.\n\nThis  most likely indicates the module isn't valid."), z.literal("Instantiate").describe("Error happened during instantiation.\n\nThis might indicate that `start` function trapped, or module isn't\ninstantiable and/or un-linkable."), z.literal("Memory").describe("Error creating memory."), z.literal("TooManyFunctions").describe("Contract contains too many functions."), z.literal("TooManyLocals").describe("Contract contains too many locals."), z.literal("TooManyTables").describe("Contract contains too many tables."), z.literal("TooManyTableElements").describe("Contract contains too many table elements.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error that can occur while preparing or executing Wasm smart-contract.") }).strict(), z.object({ "WasmerCompileError": z.object({ "msg": z.string() }) }).strict().describe("This is for defense in depth.\nWe expect our runtime-independent preparation code to fully catch all invalid wasms,\nbut, if it ever misses something we’ll emit this error")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Wasm compilation error"), z.object({ "LinkError": z.object({ "msg": z.string() }) }).strict().describe("Wasm binary env link error\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "MethodResolveError": z.enum(["MethodEmptyName","MethodNotFound","MethodInvalidSignature"]) }).strict().describe("Import/export resolve error"), z.object({ "WasmTrap": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unreachable").describe("An `unreachable` opcode was executed."), z.literal("IncorrectCallIndirectSignature").describe("Call indirect incorrect signature trap."), z.literal("MemoryOutOfBounds").describe("Memory out of bounds trap."), z.literal("CallIndirectOOB").describe("Call indirect out of bounds trap."), z.literal("IllegalArithmetic").describe("An arithmetic exception, e.g. divided by zero."), z.literal("MisalignedAtomicAccess").describe("Misaligned atomic access trap."), z.literal("IndirectCallToNull").describe("Indirect call to null."), z.literal("StackOverflow").describe("Stack overflow."), z.literal("GenericTrap").describe("Generic trap.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("A kind of a trap happened during execution of a binary") }).strict().describe("A trap happened during execution of a binary\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "HostError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("BadUTF16").describe("String encoding is bad UTF-16 sequence"), z.literal("BadUTF8").describe("String encoding is bad UTF-8 sequence"), z.literal("GasExceeded").describe("Exceeded the prepaid gas"), z.literal("GasLimitExceeded").describe("Exceeded the maximum amount of gas allowed to burn per contract"), z.literal("BalanceExceeded").describe("Exceeded the account balance"), z.literal("EmptyMethodName").describe("Tried to call an empty method name"), z.object({ "GuestPanic": z.object({ "panic_msg": z.string() }) }).strict().describe("Smart contract panicked"), z.literal("IntegerOverflow").describe("IntegerOverflow happened during a contract execution"), z.object({ "InvalidPromiseIndex": z.object({ "promise_idx": z.number().int().gte(0) }) }).strict().describe("`promise_idx` does not correspond to existing promises"), z.literal("CannotAppendActionToJointPromise").describe("Actions can only be appended to non-joint promise."), z.literal("CannotReturnJointPromise").describe("Returning joint promise is currently prohibited"), z.object({ "InvalidPromiseResultIndex": z.object({ "result_idx": z.number().int().gte(0) }) }).strict().describe("Accessed invalid promise result index"), z.object({ "InvalidRegisterId": z.object({ "register_id": z.number().int().gte(0) }) }).strict().describe("Accessed invalid register id"), z.object({ "IteratorWasInvalidated": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie"), z.literal("MemoryAccessViolation").describe("Accessed memory outside the bounds"), z.object({ "InvalidReceiptIndex": z.object({ "receipt_index": z.number().int().gte(0) }) }).strict().describe("VM Logic returned an invalid receipt index"), z.object({ "InvalidIteratorIndex": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator index `iterator_index` does not exist"), z.literal("InvalidAccountId").describe("VM Logic returned an invalid account id"), z.literal("InvalidMethodName").describe("VM Logic returned an invalid method name"), z.literal("InvalidPublicKey").describe("VM Logic provided an invalid public key"), z.object({ "ProhibitedInView": z.object({ "method_name": z.string() }) }).strict().describe("`method_name` is not allowed in view calls"), z.object({ "NumberOfLogsExceeded": z.object({ "limit": z.number().int().gte(0) }) }).strict().describe("The total number of logs will exceed the limit."), z.object({ "KeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage key length exceeded the limit."), z.object({ "ValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage value length exceeded the limit."), z.object({ "TotalLogLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The total log length exceeded the limit."), z.object({ "NumberPromisesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_promises": z.number().int().gte(0) }) }).strict().describe("The maximum number of promises within a FunctionCall exceeded the limit."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The maximum number of input data dependencies exceeded the limit."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The returned value length exceeded the limit."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The contract size for DeployContract action exceeded the limit."), z.object({ "Deprecated": z.object({ "method_name": z.string() }) }).strict().describe("The host function was deprecated."), z.object({ "ECRecoverError": z.object({ "msg": z.string() }) }).strict().describe("General errors for ECDSA recover."), z.object({ "AltBn128InvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to alt_bn128 family of functions (e.g., point which isn't\non the curve)."), z.object({ "Ed25519VerifyInvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to ed25519 signature verification function (e.g. signature cannot be\nderived from bytes).")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Note: this is only to deserialize old data, use execution error for new data"), z.object({ "ExecutionError": z.string() }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Serializable version of `near-vm-runner::FunctionCallError`.\n\nMust never reorder/remove elements, can only add new variants at the end (but do that very\ncarefully). It describes stable serialization format, and only used by serialization logic.") }).strict().describe("An error occurred during a `FunctionCall` Action, parameter is debug message."), z.object({ "NewReceiptValidationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidPredecessorId": z.object({ "account_id": z.string() }) }).strict().describe("The `predecessor_id` of a Receipt is not valid."), z.object({ "InvalidReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a Receipt is not valid."), z.object({ "InvalidSignerId": z.object({ "account_id": z.string() }) }).strict().describe("The `signer_id` of an ActionReceipt is not valid."), z.object({ "InvalidDataReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a DataReceiver within an ActionReceipt is not valid."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the returned data exceeded the limit in a DataReceipt."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The number of input data dependencies exceeds the limit in an ActionReceipt."), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of an ActionReceipt."), z.object({ "ReceiptSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("Receipt is bigger than the limit."), z.object({ "InvalidRefundTo": z.object({ "account_id": z.string() }) }).strict().describe("The `refund_to` of an ActionReceipt is not valid.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a receipt.") }).strict().describe("Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\nreceipt validation."), z.object({ "OnlyImplicitAccountCreationAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\nSee NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\nAlso, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\nTODO(#8598): This error is named very poorly. A better name would be\n`OnlyNamedAccountCreationAllowed`."), z.object({ "DeleteAccountWithLargeState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Delete account whose state is large is temporarily banned."), z.literal("DelegateActionInvalidSignature").describe("Signature does not match the provided actions and given signer public key."), z.object({ "DelegateActionSenderDoesNotMatchTxReceiver": z.object({ "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Receiver of the transaction doesn't match Sender of the delegate action"), z.literal("DelegateActionExpired").describe("Delegate action has expired. `max_block_height` is less than actual block height."), z.object({ "DelegateActionAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("The given public key doesn't exist for Sender account"), z.object({ "DelegateActionInvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "delegate_nonce": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce must be greater sender[public_key].nonce"), z.object({ "DelegateActionNonceTooLarge": z.object({ "delegate_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce is larger than the upper bound given by the block height"), z.object({ "GlobalContractDoesNotExist": z.object({ "identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("The kind of ActionError happened") }).describe("An error happened during Action execution") }).strict().describe("An error happened during Action execution"), z.object({ "InvalidTxError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Happens if a wrong AccessKey used or AccessKey has not enough permissions"), z.object({ "InvalidSignerId": z.object({ "signer_id": z.string() }) }).strict().describe("TX signer_id is not a valid [`AccountId`]"), z.object({ "SignerDoesNotExist": z.object({ "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("TX signer_id is not found in a storage"), z.object({ "InvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "tx_nonce": z.number().int().gte(0) }) }).strict().describe("Transaction nonce must be strictly greater than `account[access_key].nonce`."), z.object({ "NonceTooLarge": z.object({ "tx_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("Transaction nonce is larger than the upper bound given by the block height"), z.object({ "InvalidReceiverId": z.object({ "receiver_id": z.string() }) }).strict().describe("TX receiver_id is not a valid AccountId"), z.literal("InvalidSignature").describe("TX signature is not valid"), z.object({ "NotEnoughBalance": z.object({ "balance": z.string(), "cost": z.string(), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account does not have enough balance to cover TX cost"), z.object({ "LackBalanceForState": z.object({ "amount": z.string().describe("Required balance to cover the state."), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which doesn't have enough balance to cover storage.") }) }).strict().describe("Signer account doesn't have enough balance after transaction."), z.literal("CostOverflow").describe("An integer overflow occurred during transaction cost estimation."), z.literal("InvalidChain").describe("Transaction parent block hash doesn't belong to the current chain"), z.literal("Expired").describe("Transaction has expired"), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of a Transaction."), z.object({ "TransactionSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of serialized transaction exceeded the limit."), z.literal("InvalidTransactionVersion").describe("Transaction version is invalid."), z.object({ "StorageError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("StorageInternalError").describe("Key-value db internal failure"), z.object({ "MissingTrieValue": z.object({ "context": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("TrieIterator").describe("Missing trie value when reading from TrieIterator."), z.literal("TriePrefetchingStorage").describe("Missing trie value when reading from TriePrefetchingStorage."), z.literal("TrieMemoryPartialStorage").describe("Missing trie value when reading from TrieMemoryPartialStorage."), z.literal("TrieStorage").describe("Missing trie value when reading from TrieStorage.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Contexts in which `StorageError::MissingTrieValue` error might occur."), "hash": z.string() }) }).strict().describe("Requested trie value by its hash which is missing in storage."), z.literal("UnexpectedTrieValue").describe("Found trie node which shouldn't be part of state. Raised during\nvalidation of state sync parts where incorrect node was passed.\nTODO (#8997): consider including hash of trie node."), z.object({ "StorageInconsistentState": z.string() }).strict().describe("Either invalid state or key-value db is corrupted.\nFor PartialStorage it cannot be corrupted.\nError message is unreliable and for debugging purposes only. It's also probably ok to\npanic in every place that produces this error.\nWe can check if db is corrupted by verifying everything in the state trie."), z.object({ "FlatStorageBlockNotSupported": z.string() }).strict().describe("Flat storage error, meaning that it doesn't support some block anymore.\nWe guarantee that such block cannot become final, thus block processing\nmust resume normally."), z.object({ "MemTrieLoadingError": z.string() }).strict().describe("In-memory trie could not be loaded for some reason.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Errors which may occur during working with trie storages, storing\ntrie values (trie nodes and state values) by their hashes.") }).strict(), z.object({ "ShardCongested": z.object({ "congestion_level": z.number().describe("A value between 0 (no congestion) and 1 (max congestion)."), "shard_id": z.number().int().gte(0).describe("The congested shard.") }) }).strict().describe("The receiver shard of the transaction is too congested to accept new\ntransactions at the moment."), z.object({ "ShardStuck": z.object({ "missed_chunks": z.number().int().gte(0).describe("The number of blocks since the last included chunk of the shard."), "shard_id": z.number().int().gte(0).describe("The shard that fails making progress.") }) }).strict().describe("The receiver shard of the transaction missed several chunks and rejects\nnew transaction until it can make progress again.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An error happened during TX execution") }).strict().describe("An error happened during Transaction execution")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error returned in the ExecutionOutcome in case of failure") }).strict().describe("The execution has failed."), z.object({ "SuccessValue": z.string() }).strict().describe("The final action succeeded and returned some value or an empty vec encoded in base64."), z.object({ "SuccessReceiptId": z.string() }).strict().describe("The final action of the receipt returned a promise or the signed transaction was converted\nto a receipt. Contains the receipt_id of the generated receipt.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Execution status. Contains the result in case of successful execution."), "tokens_burnt": z.string().describe("The amount of tokens burnt corresponding to the burnt gas amount.\nThis value doesn't always equal to the `gas_burnt` multiplied by the gas price, because\nthe prepaid gas price might be lower than the actual gas price and it creates a deficit.\n`tokens_burnt` also contains the penalty subtracted from refunds, while\n`gas_burnt` only contains the gas that we actually burn for the execution.") }), "proof": z.array(z.object({ "direction": z.enum(["Left","Right"]), "hash": z.string() })) }).describe("The execution outcome of the signed transaction.") }).describe("Final execution outcome of the transaction and all of subsequent the receipts. Also includes\nthe generated receipt.")
export type FinalExecutionOutcomeWithReceiptView = z.infer<typeof FinalExecutionOutcomeWithReceiptView>


export const FinalExecutionStatus = z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("NotStarted").describe("The execution has not yet started."), z.literal("Started").describe("The execution has started and still going."), z.object({ "Failure": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "ActionError": z.object({ "index": z.union([z.number().int().gte(0).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`"), z.null().describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`")]).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`").optional(), "kind": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccountAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage"), z.object({ "AccountDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when TX receiver_id doesn't exist (but action is not Action::CreateAccount)"), z.object({ "CreateAccountOnlyByRegistrar": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "registrar_account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A top-level account ID can only be created by registrar."), z.object({ "CreateAccountNotAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A newly created account must be under a namespace of the creator account"), z.object({ "ActorNoPermission": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "actor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\nor the first TX action is a `CreateAccount` action"), z.object({ "DeleteKeyDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("Account tries to remove an access key that doesn't exist"), z.object({ "AddKeyAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The public key is already used for an existing access key"), z.object({ "DeleteAccountStaking": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is staking and can not be deleted"), z.object({ "LackBalanceForState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which needs balance"), "amount": z.string().describe("Balance required to complete an action.") }) }).strict().describe("ActionReceipt can't be completed, because the remaining balance will not be enough to cover storage."), z.object({ "TriesToUnstake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is not yet staked, but tries to unstake"), z.object({ "TriesToStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "balance": z.string(), "locked": z.string(), "stake": z.string() }) }).strict().describe("The account doesn't have enough balance to increase the stake."), z.object({ "InsufficientStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "minimum_stake": z.string(), "stake": z.string() }) }).strict(), z.object({ "FunctionCallError": z.any().superRefine((x, ctx) => {
    const schemas = [z.enum(["WasmUnknownError","_EVMError"]), z.object({ "CompilationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "PrepareError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Serialization").describe("Error happened while serializing the module."), z.literal("Deserialization").describe("Error happened while deserializing the module."), z.literal("InternalMemoryDeclared").describe("Internal memory declaration has been found in the module."), z.literal("GasInstrumentation").describe("Gas instrumentation failed.\n\nThis most likely indicates the module isn't valid."), z.literal("StackHeightInstrumentation").describe("Stack instrumentation failed.\n\nThis  most likely indicates the module isn't valid."), z.literal("Instantiate").describe("Error happened during instantiation.\n\nThis might indicate that `start` function trapped, or module isn't\ninstantiable and/or un-linkable."), z.literal("Memory").describe("Error creating memory."), z.literal("TooManyFunctions").describe("Contract contains too many functions."), z.literal("TooManyLocals").describe("Contract contains too many locals."), z.literal("TooManyTables").describe("Contract contains too many tables."), z.literal("TooManyTableElements").describe("Contract contains too many table elements.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error that can occur while preparing or executing Wasm smart-contract.") }).strict(), z.object({ "WasmerCompileError": z.object({ "msg": z.string() }) }).strict().describe("This is for defense in depth.\nWe expect our runtime-independent preparation code to fully catch all invalid wasms,\nbut, if it ever misses something we’ll emit this error")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Wasm compilation error"), z.object({ "LinkError": z.object({ "msg": z.string() }) }).strict().describe("Wasm binary env link error\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "MethodResolveError": z.enum(["MethodEmptyName","MethodNotFound","MethodInvalidSignature"]) }).strict().describe("Import/export resolve error"), z.object({ "WasmTrap": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unreachable").describe("An `unreachable` opcode was executed."), z.literal("IncorrectCallIndirectSignature").describe("Call indirect incorrect signature trap."), z.literal("MemoryOutOfBounds").describe("Memory out of bounds trap."), z.literal("CallIndirectOOB").describe("Call indirect out of bounds trap."), z.literal("IllegalArithmetic").describe("An arithmetic exception, e.g. divided by zero."), z.literal("MisalignedAtomicAccess").describe("Misaligned atomic access trap."), z.literal("IndirectCallToNull").describe("Indirect call to null."), z.literal("StackOverflow").describe("Stack overflow."), z.literal("GenericTrap").describe("Generic trap.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("A kind of a trap happened during execution of a binary") }).strict().describe("A trap happened during execution of a binary\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "HostError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("BadUTF16").describe("String encoding is bad UTF-16 sequence"), z.literal("BadUTF8").describe("String encoding is bad UTF-8 sequence"), z.literal("GasExceeded").describe("Exceeded the prepaid gas"), z.literal("GasLimitExceeded").describe("Exceeded the maximum amount of gas allowed to burn per contract"), z.literal("BalanceExceeded").describe("Exceeded the account balance"), z.literal("EmptyMethodName").describe("Tried to call an empty method name"), z.object({ "GuestPanic": z.object({ "panic_msg": z.string() }) }).strict().describe("Smart contract panicked"), z.literal("IntegerOverflow").describe("IntegerOverflow happened during a contract execution"), z.object({ "InvalidPromiseIndex": z.object({ "promise_idx": z.number().int().gte(0) }) }).strict().describe("`promise_idx` does not correspond to existing promises"), z.literal("CannotAppendActionToJointPromise").describe("Actions can only be appended to non-joint promise."), z.literal("CannotReturnJointPromise").describe("Returning joint promise is currently prohibited"), z.object({ "InvalidPromiseResultIndex": z.object({ "result_idx": z.number().int().gte(0) }) }).strict().describe("Accessed invalid promise result index"), z.object({ "InvalidRegisterId": z.object({ "register_id": z.number().int().gte(0) }) }).strict().describe("Accessed invalid register id"), z.object({ "IteratorWasInvalidated": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie"), z.literal("MemoryAccessViolation").describe("Accessed memory outside the bounds"), z.object({ "InvalidReceiptIndex": z.object({ "receipt_index": z.number().int().gte(0) }) }).strict().describe("VM Logic returned an invalid receipt index"), z.object({ "InvalidIteratorIndex": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator index `iterator_index` does not exist"), z.literal("InvalidAccountId").describe("VM Logic returned an invalid account id"), z.literal("InvalidMethodName").describe("VM Logic returned an invalid method name"), z.literal("InvalidPublicKey").describe("VM Logic provided an invalid public key"), z.object({ "ProhibitedInView": z.object({ "method_name": z.string() }) }).strict().describe("`method_name` is not allowed in view calls"), z.object({ "NumberOfLogsExceeded": z.object({ "limit": z.number().int().gte(0) }) }).strict().describe("The total number of logs will exceed the limit."), z.object({ "KeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage key length exceeded the limit."), z.object({ "ValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage value length exceeded the limit."), z.object({ "TotalLogLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The total log length exceeded the limit."), z.object({ "NumberPromisesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_promises": z.number().int().gte(0) }) }).strict().describe("The maximum number of promises within a FunctionCall exceeded the limit."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The maximum number of input data dependencies exceeded the limit."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The returned value length exceeded the limit."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The contract size for DeployContract action exceeded the limit."), z.object({ "Deprecated": z.object({ "method_name": z.string() }) }).strict().describe("The host function was deprecated."), z.object({ "ECRecoverError": z.object({ "msg": z.string() }) }).strict().describe("General errors for ECDSA recover."), z.object({ "AltBn128InvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to alt_bn128 family of functions (e.g., point which isn't\non the curve)."), z.object({ "Ed25519VerifyInvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to ed25519 signature verification function (e.g. signature cannot be\nderived from bytes).")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Note: this is only to deserialize old data, use execution error for new data"), z.object({ "ExecutionError": z.string() }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Serializable version of `near-vm-runner::FunctionCallError`.\n\nMust never reorder/remove elements, can only add new variants at the end (but do that very\ncarefully). It describes stable serialization format, and only used by serialization logic.") }).strict().describe("An error occurred during a `FunctionCall` Action, parameter is debug message."), z.object({ "NewReceiptValidationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidPredecessorId": z.object({ "account_id": z.string() }) }).strict().describe("The `predecessor_id` of a Receipt is not valid."), z.object({ "InvalidReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a Receipt is not valid."), z.object({ "InvalidSignerId": z.object({ "account_id": z.string() }) }).strict().describe("The `signer_id` of an ActionReceipt is not valid."), z.object({ "InvalidDataReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a DataReceiver within an ActionReceipt is not valid."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the returned data exceeded the limit in a DataReceipt."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The number of input data dependencies exceeds the limit in an ActionReceipt."), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of an ActionReceipt."), z.object({ "ReceiptSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("Receipt is bigger than the limit."), z.object({ "InvalidRefundTo": z.object({ "account_id": z.string() }) }).strict().describe("The `refund_to` of an ActionReceipt is not valid.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a receipt.") }).strict().describe("Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\nreceipt validation."), z.object({ "OnlyImplicitAccountCreationAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\nSee NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\nAlso, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\nTODO(#8598): This error is named very poorly. A better name would be\n`OnlyNamedAccountCreationAllowed`."), z.object({ "DeleteAccountWithLargeState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Delete account whose state is large is temporarily banned."), z.literal("DelegateActionInvalidSignature").describe("Signature does not match the provided actions and given signer public key."), z.object({ "DelegateActionSenderDoesNotMatchTxReceiver": z.object({ "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Receiver of the transaction doesn't match Sender of the delegate action"), z.literal("DelegateActionExpired").describe("Delegate action has expired. `max_block_height` is less than actual block height."), z.object({ "DelegateActionAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("The given public key doesn't exist for Sender account"), z.object({ "DelegateActionInvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "delegate_nonce": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce must be greater sender[public_key].nonce"), z.object({ "DelegateActionNonceTooLarge": z.object({ "delegate_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce is larger than the upper bound given by the block height"), z.object({ "GlobalContractDoesNotExist": z.object({ "identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("The kind of ActionError happened") }).describe("An error happened during Action execution") }).strict().describe("An error happened during Action execution"), z.object({ "InvalidTxError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Happens if a wrong AccessKey used or AccessKey has not enough permissions"), z.object({ "InvalidSignerId": z.object({ "signer_id": z.string() }) }).strict().describe("TX signer_id is not a valid [`AccountId`]"), z.object({ "SignerDoesNotExist": z.object({ "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("TX signer_id is not found in a storage"), z.object({ "InvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "tx_nonce": z.number().int().gte(0) }) }).strict().describe("Transaction nonce must be strictly greater than `account[access_key].nonce`."), z.object({ "NonceTooLarge": z.object({ "tx_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("Transaction nonce is larger than the upper bound given by the block height"), z.object({ "InvalidReceiverId": z.object({ "receiver_id": z.string() }) }).strict().describe("TX receiver_id is not a valid AccountId"), z.literal("InvalidSignature").describe("TX signature is not valid"), z.object({ "NotEnoughBalance": z.object({ "balance": z.string(), "cost": z.string(), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account does not have enough balance to cover TX cost"), z.object({ "LackBalanceForState": z.object({ "amount": z.string().describe("Required balance to cover the state."), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which doesn't have enough balance to cover storage.") }) }).strict().describe("Signer account doesn't have enough balance after transaction."), z.literal("CostOverflow").describe("An integer overflow occurred during transaction cost estimation."), z.literal("InvalidChain").describe("Transaction parent block hash doesn't belong to the current chain"), z.literal("Expired").describe("Transaction has expired"), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of a Transaction."), z.object({ "TransactionSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of serialized transaction exceeded the limit."), z.literal("InvalidTransactionVersion").describe("Transaction version is invalid."), z.object({ "StorageError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("StorageInternalError").describe("Key-value db internal failure"), z.object({ "MissingTrieValue": z.object({ "context": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("TrieIterator").describe("Missing trie value when reading from TrieIterator."), z.literal("TriePrefetchingStorage").describe("Missing trie value when reading from TriePrefetchingStorage."), z.literal("TrieMemoryPartialStorage").describe("Missing trie value when reading from TrieMemoryPartialStorage."), z.literal("TrieStorage").describe("Missing trie value when reading from TrieStorage.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Contexts in which `StorageError::MissingTrieValue` error might occur."), "hash": z.string() }) }).strict().describe("Requested trie value by its hash which is missing in storage."), z.literal("UnexpectedTrieValue").describe("Found trie node which shouldn't be part of state. Raised during\nvalidation of state sync parts where incorrect node was passed.\nTODO (#8997): consider including hash of trie node."), z.object({ "StorageInconsistentState": z.string() }).strict().describe("Either invalid state or key-value db is corrupted.\nFor PartialStorage it cannot be corrupted.\nError message is unreliable and for debugging purposes only. It's also probably ok to\npanic in every place that produces this error.\nWe can check if db is corrupted by verifying everything in the state trie."), z.object({ "FlatStorageBlockNotSupported": z.string() }).strict().describe("Flat storage error, meaning that it doesn't support some block anymore.\nWe guarantee that such block cannot become final, thus block processing\nmust resume normally."), z.object({ "MemTrieLoadingError": z.string() }).strict().describe("In-memory trie could not be loaded for some reason.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Errors which may occur during working with trie storages, storing\ntrie values (trie nodes and state values) by their hashes.") }).strict(), z.object({ "ShardCongested": z.object({ "congestion_level": z.number().describe("A value between 0 (no congestion) and 1 (max congestion)."), "shard_id": z.number().int().gte(0).describe("The congested shard.") }) }).strict().describe("The receiver shard of the transaction is too congested to accept new\ntransactions at the moment."), z.object({ "ShardStuck": z.object({ "missed_chunks": z.number().int().gte(0).describe("The number of blocks since the last included chunk of the shard."), "shard_id": z.number().int().gte(0).describe("The shard that fails making progress.") }) }).strict().describe("The receiver shard of the transaction missed several chunks and rejects\nnew transaction until it can make progress again.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An error happened during TX execution") }).strict().describe("An error happened during Transaction execution")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error returned in the ExecutionOutcome in case of failure") }).strict().describe("The execution has failed with the given error."), z.object({ "SuccessValue": z.string() }).strict().describe("The execution has succeeded and returned some value or an empty vec encoded in base64.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })
export type FinalExecutionStatus = z.infer<typeof FinalExecutionStatus>


export const Finality = z.enum(["optimistic","near-final","final"]).describe("Different types of finality.")
export type Finality = z.infer<typeof Finality>


export const FunctionArgs = z.string().describe("This type is used to mark function arguments.\n\nNOTE: The main reason for this to exist (except the type-safety) is that the value is\ntransparently serialized and deserialized as a base64-encoded string when serde is used\n(serde_json).")
export type FunctionArgs = z.infer<typeof FunctionArgs>


export const FunctionCallAction = z.object({ "args": z.string(), "deposit": z.string(), "gas": z.number().int().gte(0), "method_name": z.string() })
export type FunctionCallAction = z.infer<typeof FunctionCallAction>


export const FunctionCallError = z.any().superRefine((x, ctx) => {
    const schemas = [z.enum(["WasmUnknownError","_EVMError"]), z.object({ "CompilationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "PrepareError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Serialization").describe("Error happened while serializing the module."), z.literal("Deserialization").describe("Error happened while deserializing the module."), z.literal("InternalMemoryDeclared").describe("Internal memory declaration has been found in the module."), z.literal("GasInstrumentation").describe("Gas instrumentation failed.\n\nThis most likely indicates the module isn't valid."), z.literal("StackHeightInstrumentation").describe("Stack instrumentation failed.\n\nThis  most likely indicates the module isn't valid."), z.literal("Instantiate").describe("Error happened during instantiation.\n\nThis might indicate that `start` function trapped, or module isn't\ninstantiable and/or un-linkable."), z.literal("Memory").describe("Error creating memory."), z.literal("TooManyFunctions").describe("Contract contains too many functions."), z.literal("TooManyLocals").describe("Contract contains too many locals."), z.literal("TooManyTables").describe("Contract contains too many tables."), z.literal("TooManyTableElements").describe("Contract contains too many table elements.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error that can occur while preparing or executing Wasm smart-contract.") }).strict(), z.object({ "WasmerCompileError": z.object({ "msg": z.string() }) }).strict().describe("This is for defense in depth.\nWe expect our runtime-independent preparation code to fully catch all invalid wasms,\nbut, if it ever misses something we’ll emit this error")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Wasm compilation error"), z.object({ "LinkError": z.object({ "msg": z.string() }) }).strict().describe("Wasm binary env link error\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "MethodResolveError": z.enum(["MethodEmptyName","MethodNotFound","MethodInvalidSignature"]) }).strict().describe("Import/export resolve error"), z.object({ "WasmTrap": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unreachable").describe("An `unreachable` opcode was executed."), z.literal("IncorrectCallIndirectSignature").describe("Call indirect incorrect signature trap."), z.literal("MemoryOutOfBounds").describe("Memory out of bounds trap."), z.literal("CallIndirectOOB").describe("Call indirect out of bounds trap."), z.literal("IllegalArithmetic").describe("An arithmetic exception, e.g. divided by zero."), z.literal("MisalignedAtomicAccess").describe("Misaligned atomic access trap."), z.literal("IndirectCallToNull").describe("Indirect call to null."), z.literal("StackOverflow").describe("Stack overflow."), z.literal("GenericTrap").describe("Generic trap.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("A kind of a trap happened during execution of a binary") }).strict().describe("A trap happened during execution of a binary\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "HostError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("BadUTF16").describe("String encoding is bad UTF-16 sequence"), z.literal("BadUTF8").describe("String encoding is bad UTF-8 sequence"), z.literal("GasExceeded").describe("Exceeded the prepaid gas"), z.literal("GasLimitExceeded").describe("Exceeded the maximum amount of gas allowed to burn per contract"), z.literal("BalanceExceeded").describe("Exceeded the account balance"), z.literal("EmptyMethodName").describe("Tried to call an empty method name"), z.object({ "GuestPanic": z.object({ "panic_msg": z.string() }) }).strict().describe("Smart contract panicked"), z.literal("IntegerOverflow").describe("IntegerOverflow happened during a contract execution"), z.object({ "InvalidPromiseIndex": z.object({ "promise_idx": z.number().int().gte(0) }) }).strict().describe("`promise_idx` does not correspond to existing promises"), z.literal("CannotAppendActionToJointPromise").describe("Actions can only be appended to non-joint promise."), z.literal("CannotReturnJointPromise").describe("Returning joint promise is currently prohibited"), z.object({ "InvalidPromiseResultIndex": z.object({ "result_idx": z.number().int().gte(0) }) }).strict().describe("Accessed invalid promise result index"), z.object({ "InvalidRegisterId": z.object({ "register_id": z.number().int().gte(0) }) }).strict().describe("Accessed invalid register id"), z.object({ "IteratorWasInvalidated": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie"), z.literal("MemoryAccessViolation").describe("Accessed memory outside the bounds"), z.object({ "InvalidReceiptIndex": z.object({ "receipt_index": z.number().int().gte(0) }) }).strict().describe("VM Logic returned an invalid receipt index"), z.object({ "InvalidIteratorIndex": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator index `iterator_index` does not exist"), z.literal("InvalidAccountId").describe("VM Logic returned an invalid account id"), z.literal("InvalidMethodName").describe("VM Logic returned an invalid method name"), z.literal("InvalidPublicKey").describe("VM Logic provided an invalid public key"), z.object({ "ProhibitedInView": z.object({ "method_name": z.string() }) }).strict().describe("`method_name` is not allowed in view calls"), z.object({ "NumberOfLogsExceeded": z.object({ "limit": z.number().int().gte(0) }) }).strict().describe("The total number of logs will exceed the limit."), z.object({ "KeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage key length exceeded the limit."), z.object({ "ValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage value length exceeded the limit."), z.object({ "TotalLogLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The total log length exceeded the limit."), z.object({ "NumberPromisesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_promises": z.number().int().gte(0) }) }).strict().describe("The maximum number of promises within a FunctionCall exceeded the limit."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The maximum number of input data dependencies exceeded the limit."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The returned value length exceeded the limit."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The contract size for DeployContract action exceeded the limit."), z.object({ "Deprecated": z.object({ "method_name": z.string() }) }).strict().describe("The host function was deprecated."), z.object({ "ECRecoverError": z.object({ "msg": z.string() }) }).strict().describe("General errors for ECDSA recover."), z.object({ "AltBn128InvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to alt_bn128 family of functions (e.g., point which isn't\non the curve)."), z.object({ "Ed25519VerifyInvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to ed25519 signature verification function (e.g. signature cannot be\nderived from bytes).")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Note: this is only to deserialize old data, use execution error for new data"), z.object({ "ExecutionError": z.string() }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Serializable version of `near-vm-runner::FunctionCallError`.\n\nMust never reorder/remove elements, can only add new variants at the end (but do that very\ncarefully). It describes stable serialization format, and only used by serialization logic.")
export type FunctionCallError = z.infer<typeof FunctionCallError>


export const FunctionCallPermission = z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Allowance is a balance limit to use by this access key to pay for function call gas and\ntransaction fees. When this access key is used, both account balance and the allowance is\ndecreased by the same value.\n`None` means unlimited allowance.\nNOTE: To change or increase the allowance, the old access key needs to be deleted and a new\naccess key should be created.").optional(), "method_names": z.array(z.string()).describe("A list of method names that can be used. The access key only allows transactions with the\nfunction call of one of the given method names.\nEmpty list means any method name can be used."), "receiver_id": z.string().describe("The access key only allows transactions with the given receiver's account id.") }).describe("Grants limited permission to make transactions with FunctionCallActions\nThe permission can limit the allowed balance to be spent on the prepaid gas.\nIt also restrict the account ID of the receiver for this function call.\nIt also can restrict the method name for the allowed function calls.")
export type FunctionCallPermission = z.infer<typeof FunctionCallPermission>


export const GCConfig = z.object({ "gc_blocks_limit": z.number().int().gte(0).describe("Maximum number of blocks to garbage collect at every garbage collection\ncall.").default(2), "gc_fork_clean_step": z.number().int().gte(0).describe("Maximum number of height to go through at each garbage collection step\nwhen cleaning forks during garbage collection.").default(100), "gc_num_epochs_to_keep": z.number().int().gte(0).describe("Number of epochs for which we keep store data.").default(5), "gc_step_period": z.object({ "nanos": z.number().int(), "secs": z.number().int() }).describe("How often gc should be run").default({"nanos":500000000,"secs":0}) }).describe("Configuration for garbage collection.")
export type GCConfig = z.infer<typeof GCConfig>


export const GasKeyView = z.object({ "balance": z.string(), "num_nonces": z.number().int().gte(0), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("FullAccess"), z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "method_names": z.array(z.string()), "receiver_id": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the permission scope for an access key. Whether it is a function call or a full access key.") })
export type GasKeyView = z.infer<typeof GasKeyView>


export const GenesisConfig = z.object({ "avg_hidden_validator_seats_per_shard": z.array(z.number().int().gte(0)).describe("Expected number of hidden validators per shard."), "block_producer_kickout_threshold": z.number().int().gte(0).lte(255).describe("Threshold for kicking out block producers, between 0 and 100."), "chain_id": z.string().describe("ID of the blockchain. This must be unique for every blockchain.\nIf your testnet blockchains do not have unique chain IDs, you will have a bad time."), "chunk_producer_assignment_changes_limit": z.number().int().gte(0).describe("Limits the number of shard changes in chunk producer assignments,\nif algorithm is able to choose assignment with better balance of\nnumber of chunk producers for shards.").default(5), "chunk_producer_kickout_threshold": z.number().int().gte(0).lte(255).describe("Threshold for kicking out chunk producers, between 0 and 100."), "chunk_validator_only_kickout_threshold": z.number().int().gte(0).lte(255).describe("Threshold for kicking out nodes which are only chunk validators, between 0 and 100.").default(80), "dynamic_resharding": z.boolean().describe("Enable dynamic re-sharding."), "epoch_length": z.number().int().gte(0).describe("Epoch length counted in block heights."), "fishermen_threshold": z.string().describe("Fishermen stake threshold."), "gas_limit": z.number().int().gte(0).describe("Initial gas limit."), "gas_price_adjustment_rate": z.array(z.number().int()).min(2).max(2).describe("Gas price adjustment rate"), "genesis_height": z.number().int().gte(0).describe("Height of genesis block."), "genesis_time": z.string().datetime({ offset: true }).describe("Official time of blockchain start."), "max_gas_price": z.string(), "max_inflation_rate": z.array(z.number().int()).min(2).max(2).describe("Maximum inflation on the total supply every epoch."), "max_kickout_stake_perc": z.number().int().gte(0).lte(255).describe("Max stake percentage of the validators we will kick out.").default(100), "min_gas_price": z.string().describe("Minimum gas price. It is also the initial gas price."), "minimum_stake_divisor": z.number().int().gte(0).describe("The minimum stake required for staking is last seat price divided by this number.").default(10), "minimum_stake_ratio": z.array(z.number().int()).min(2).max(2).describe("The lowest ratio s/s_total any block producer can have.\nSee <https://github.com/near/NEPs/pull/167> for details").default([1,6250]), "minimum_validators_per_shard": z.number().int().gte(0).describe("The minimum number of validators each shard must have").default(1), "num_block_producer_seats": z.number().int().gte(0).describe("Number of block producer seats at genesis."), "num_block_producer_seats_per_shard": z.array(z.number().int().gte(0)).describe("Defines number of shards and number of block producer seats per each shard at genesis.\nNote: not used with protocol_feature_chunk_only_producers -- replaced by minimum_validators_per_shard\nNote: not used before as all block producers produce chunks for all shards"), "num_blocks_per_year": z.number().int().gte(0).describe("Expected number of blocks per year"), "num_chunk_only_producer_seats": z.number().int().gte(0).describe("Deprecated.").default(300), "num_chunk_producer_seats": z.number().int().gte(0).describe("Number of chunk producers.\nDon't mess it up with chunk-only producers feature which is deprecated.").default(100), "num_chunk_validator_seats": z.number().int().gte(0).default(300), "online_max_threshold": z.array(z.number().int()).min(2).max(2).describe("Online maximum threshold above which validator gets full reward.").default([99,100]), "online_min_threshold": z.array(z.number().int()).min(2).max(2).describe("Online minimum threshold below which validator doesn't receive reward.").default([9,10]), "protocol_reward_rate": z.array(z.number().int()).min(2).max(2).describe("Protocol treasury rate"), "protocol_treasury_account": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("Protocol treasury account"), "protocol_upgrade_stake_threshold": z.array(z.number().int()).min(2).max(2).describe("Threshold of stake that needs to indicate that they ready for upgrade.").default([4,5]), "protocol_version": z.number().int().gte(0).describe("Protocol version that this genesis works with."), "shard_layout": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "V0": z.object({ "num_shards": z.number().int().gte(0).describe("Map accounts evenly across all shards"), "version": z.number().int().gte(0).describe("Version of the shard layout, this is useful for uniquely identify the shard layout") }).describe("A shard layout that maps accounts evenly across all shards -- by calculate the hash of account\nid and mod number of shards. This is added to capture the old `account_id_to_shard_id` algorithm,\nto keep backward compatibility for some existing tests.\n`parent_shards` for `ShardLayoutV1` is always `None`, meaning it can only be the first shard layout\na chain uses.") }).strict(), z.object({ "V1": z.object({ "boundary_accounts": z.array(z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```")).describe("The boundary accounts are the accounts on boundaries between shards.\nEach shard contains a range of accounts from one boundary account to\nanother - or the smallest or largest account possible. The total\nnumber of shards is equal to the number of boundary accounts plus 1."), "shards_split_map": z.union([z.array(z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias."))).describe("Maps shards from the last shard layout to shards that it splits to in this shard layout,\nUseful for constructing states for the shards.\nNone for the genesis shard layout"), z.null().describe("Maps shards from the last shard layout to shards that it splits to in this shard layout,\nUseful for constructing states for the shards.\nNone for the genesis shard layout")]).describe("Maps shards from the last shard layout to shards that it splits to in this shard layout,\nUseful for constructing states for the shards.\nNone for the genesis shard layout").optional(), "to_parent_shard_map": z.union([z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")).describe("Maps shard in this shard layout to their parent shard\nSince shard_ids always range from 0 to num_shards - 1, we use vec instead of a hashmap"), z.null().describe("Maps shard in this shard layout to their parent shard\nSince shard_ids always range from 0 to num_shards - 1, we use vec instead of a hashmap")]).describe("Maps shard in this shard layout to their parent shard\nSince shard_ids always range from 0 to num_shards - 1, we use vec instead of a hashmap").optional(), "version": z.number().int().gte(0).describe("Version of the shard layout, this is useful for uniquely identify the shard layout") }) }).strict(), z.object({ "V2": z.object({ "boundary_accounts": z.array(z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```")), "id_to_index_map": z.record(z.number().int().gte(0)), "index_to_id_map": z.record(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")), "shard_ids": z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")), "shards_parent_map": z.union([z.record(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")), z.null()]).optional(), "shards_split_map": z.union([z.record(z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias."))), z.null()]).optional(), "version": z.number().int().gte(0) }).describe("Counterpart to `ShardLayoutV2` composed of maps with string keys to aid\nserde serialization.") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("A versioned struct that contains all information needed to assign accounts to shards.\n\nBecause of re-sharding, the chain may use different shard layout to split shards at different\ntimes. Currently, `ShardLayout` is stored as part of `EpochConfig`, which is generated each\nepoch given the epoch protocol version. In mainnet/testnet, we use two shard layouts since\nre-sharding has only happened once. It is stored as part of genesis config, see\ndefault_simple_nightshade_shard_layout() Below is an overview for some important\nfunctionalities of ShardLayout interface.").describe("Layout information regarding how to split accounts to shards").default({"V2":{"boundary_accounts":[],"id_to_index_map":{"0":0},"index_to_id_map":{"0":0},"shard_ids":[0],"shards_parent_map":null,"shards_split_map":null,"version":0}}), "shuffle_shard_assignment_for_chunk_producers": z.boolean().describe("If true, shuffle the chunk producers across shards. In other words, if\nthe shard assignments were `[S_0, S_1, S_2, S_3]` where `S_i` represents\nthe set of chunk producers for shard `i`, if this flag were true, the\nshard assignments might become, for example, `[S_2, S_0, S_3, S_1]`.").default(false), "target_validator_mandates_per_shard": z.number().int().gte(0).describe("Number of target chunk validator mandates for each shard.").default(68), "total_supply": z.string().describe("Total supply of tokens at genesis."), "transaction_validity_period": z.number().int().gte(0).describe("Number of blocks for which a given transaction is valid"), "use_production_config": z.boolean().describe("This is only for test purposes. We hard code some configs for mainnet and testnet\nin AllEpochConfig, and we want to have a way to test that code path. This flag is for that.\nIf set to true, the node will use the same config override path as mainnet and testnet.").default(false), "validators": z.array(z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "amount": z.string(), "public_key": z.string() }).describe("Account info for validators")).describe("List of initial validators.") })
export type GenesisConfig = z.infer<typeof GenesisConfig>


export const GenesisConfigRequest = z.record(z.any())
export type GenesisConfigRequest = z.infer<typeof GenesisConfigRequest>


export const GlobalContractDeployMode = z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("CodeHash").describe("Contract is deployed under its code hash.\nUsers will be able reference it by that hash.\nThis effectively makes the contract immutable."), z.literal("AccountId").describe("Contract is deployed under the owner account id.\nUsers will be able reference it by that account id.\nThis allows the owner to update the contract for all its users.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })
export type GlobalContractDeployMode = z.infer<typeof GlobalContractDeployMode>


export const GlobalContractIdentifier = z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })
export type GlobalContractIdentifier = z.infer<typeof GlobalContractIdentifier>


export const GlobalContractIdentifierView = z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "hash": z.string() }).strict(), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })
export type GlobalContractIdentifierView = z.infer<typeof GlobalContractIdentifierView>


export const HostError = z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("BadUTF16").describe("String encoding is bad UTF-16 sequence"), z.literal("BadUTF8").describe("String encoding is bad UTF-8 sequence"), z.literal("GasExceeded").describe("Exceeded the prepaid gas"), z.literal("GasLimitExceeded").describe("Exceeded the maximum amount of gas allowed to burn per contract"), z.literal("BalanceExceeded").describe("Exceeded the account balance"), z.literal("EmptyMethodName").describe("Tried to call an empty method name"), z.object({ "GuestPanic": z.object({ "panic_msg": z.string() }) }).strict().describe("Smart contract panicked"), z.literal("IntegerOverflow").describe("IntegerOverflow happened during a contract execution"), z.object({ "InvalidPromiseIndex": z.object({ "promise_idx": z.number().int().gte(0) }) }).strict().describe("`promise_idx` does not correspond to existing promises"), z.literal("CannotAppendActionToJointPromise").describe("Actions can only be appended to non-joint promise."), z.literal("CannotReturnJointPromise").describe("Returning joint promise is currently prohibited"), z.object({ "InvalidPromiseResultIndex": z.object({ "result_idx": z.number().int().gte(0) }) }).strict().describe("Accessed invalid promise result index"), z.object({ "InvalidRegisterId": z.object({ "register_id": z.number().int().gte(0) }) }).strict().describe("Accessed invalid register id"), z.object({ "IteratorWasInvalidated": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie"), z.literal("MemoryAccessViolation").describe("Accessed memory outside the bounds"), z.object({ "InvalidReceiptIndex": z.object({ "receipt_index": z.number().int().gte(0) }) }).strict().describe("VM Logic returned an invalid receipt index"), z.object({ "InvalidIteratorIndex": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator index `iterator_index` does not exist"), z.literal("InvalidAccountId").describe("VM Logic returned an invalid account id"), z.literal("InvalidMethodName").describe("VM Logic returned an invalid method name"), z.literal("InvalidPublicKey").describe("VM Logic provided an invalid public key"), z.object({ "ProhibitedInView": z.object({ "method_name": z.string() }) }).strict().describe("`method_name` is not allowed in view calls"), z.object({ "NumberOfLogsExceeded": z.object({ "limit": z.number().int().gte(0) }) }).strict().describe("The total number of logs will exceed the limit."), z.object({ "KeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage key length exceeded the limit."), z.object({ "ValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage value length exceeded the limit."), z.object({ "TotalLogLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The total log length exceeded the limit."), z.object({ "NumberPromisesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_promises": z.number().int().gte(0) }) }).strict().describe("The maximum number of promises within a FunctionCall exceeded the limit."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The maximum number of input data dependencies exceeded the limit."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The returned value length exceeded the limit."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The contract size for DeployContract action exceeded the limit."), z.object({ "Deprecated": z.object({ "method_name": z.string() }) }).strict().describe("The host function was deprecated."), z.object({ "ECRecoverError": z.object({ "msg": z.string() }) }).strict().describe("General errors for ECDSA recover."), z.object({ "AltBn128InvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to alt_bn128 family of functions (e.g., point which isn't\non the curve)."), z.object({ "Ed25519VerifyInvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to ed25519 signature verification function (e.g. signature cannot be\nderived from bytes).")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })
export type HostError = z.infer<typeof HostError>


export const InvalidAccessKeyError = z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })
export type InvalidAccessKeyError = z.infer<typeof InvalidAccessKeyError>


export const InvalidTxError = z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Happens if a wrong AccessKey used or AccessKey has not enough permissions"), z.object({ "InvalidSignerId": z.object({ "signer_id": z.string() }) }).strict().describe("TX signer_id is not a valid [`AccountId`]"), z.object({ "SignerDoesNotExist": z.object({ "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("TX signer_id is not found in a storage"), z.object({ "InvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "tx_nonce": z.number().int().gte(0) }) }).strict().describe("Transaction nonce must be strictly greater than `account[access_key].nonce`."), z.object({ "NonceTooLarge": z.object({ "tx_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("Transaction nonce is larger than the upper bound given by the block height"), z.object({ "InvalidReceiverId": z.object({ "receiver_id": z.string() }) }).strict().describe("TX receiver_id is not a valid AccountId"), z.literal("InvalidSignature").describe("TX signature is not valid"), z.object({ "NotEnoughBalance": z.object({ "balance": z.string(), "cost": z.string(), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account does not have enough balance to cover TX cost"), z.object({ "LackBalanceForState": z.object({ "amount": z.string().describe("Required balance to cover the state."), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which doesn't have enough balance to cover storage.") }) }).strict().describe("Signer account doesn't have enough balance after transaction."), z.literal("CostOverflow").describe("An integer overflow occurred during transaction cost estimation."), z.literal("InvalidChain").describe("Transaction parent block hash doesn't belong to the current chain"), z.literal("Expired").describe("Transaction has expired"), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of a Transaction."), z.object({ "TransactionSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of serialized transaction exceeded the limit."), z.literal("InvalidTransactionVersion").describe("Transaction version is invalid."), z.object({ "StorageError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("StorageInternalError").describe("Key-value db internal failure"), z.object({ "MissingTrieValue": z.object({ "context": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("TrieIterator").describe("Missing trie value when reading from TrieIterator."), z.literal("TriePrefetchingStorage").describe("Missing trie value when reading from TriePrefetchingStorage."), z.literal("TrieMemoryPartialStorage").describe("Missing trie value when reading from TrieMemoryPartialStorage."), z.literal("TrieStorage").describe("Missing trie value when reading from TrieStorage.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Contexts in which `StorageError::MissingTrieValue` error might occur."), "hash": z.string() }) }).strict().describe("Requested trie value by its hash which is missing in storage."), z.literal("UnexpectedTrieValue").describe("Found trie node which shouldn't be part of state. Raised during\nvalidation of state sync parts where incorrect node was passed.\nTODO (#8997): consider including hash of trie node."), z.object({ "StorageInconsistentState": z.string() }).strict().describe("Either invalid state or key-value db is corrupted.\nFor PartialStorage it cannot be corrupted.\nError message is unreliable and for debugging purposes only. It's also probably ok to\npanic in every place that produces this error.\nWe can check if db is corrupted by verifying everything in the state trie."), z.object({ "FlatStorageBlockNotSupported": z.string() }).strict().describe("Flat storage error, meaning that it doesn't support some block anymore.\nWe guarantee that such block cannot become final, thus block processing\nmust resume normally."), z.object({ "MemTrieLoadingError": z.string() }).strict().describe("In-memory trie could not be loaded for some reason.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Errors which may occur during working with trie storages, storing\ntrie values (trie nodes and state values) by their hashes.") }).strict(), z.object({ "ShardCongested": z.object({ "congestion_level": z.number().describe("A value between 0 (no congestion) and 1 (max congestion)."), "shard_id": z.number().int().gte(0).describe("The congested shard.") }) }).strict().describe("The receiver shard of the transaction is too congested to accept new\ntransactions at the moment."), z.object({ "ShardStuck": z.object({ "missed_chunks": z.number().int().gte(0).describe("The number of blocks since the last included chunk of the shard."), "shard_id": z.number().int().gte(0).describe("The shard that fails making progress.") }) }).strict().describe("The receiver shard of the transaction missed several chunks and rejects\nnew transaction until it can make progress again.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An error happened during TX execution")
export type InvalidTxError = z.infer<typeof InvalidTxError>


export const KnownProducerView = z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "next_hops": z.union([z.array(z.string()), z.null()]).optional(), "peer_id": z.string() }).describe("Information about a Producer: its account name, peer_id and a list of connected peers that\nthe node can use to send message for this producer.")
export type KnownProducerView = z.infer<typeof KnownProducerView>


export const LightClientBlockLiteView = z.object({ "inner_lite": z.object({ "block_merkle_root": z.string().describe("The merkle root of all the block hashes"), "epoch_id": z.string().describe("The epoch to which the block that is the current known head belongs"), "height": z.number().int().gte(0), "next_bp_hash": z.string().describe("The hash of the block producers set for the next epoch"), "next_epoch_id": z.string().describe("The epoch that will follow the current epoch"), "outcome_root": z.string(), "prev_state_root": z.string(), "timestamp": z.number().int().gte(0).describe("Legacy json number. Should not be used."), "timestamp_nanosec": z.string() }).describe("A part of a state for the current head of a light client. More info [here](https://nomicon.io/ChainSpec/LightClient)."), "inner_rest_hash": z.string(), "prev_block_hash": z.string() })
export type LightClientBlockLiteView = z.infer<typeof LightClientBlockLiteView>


export const LimitConfig = z.object({ "account_id_validity_rules_version": z.number().int().gte(0).lte(255).describe("Whether to enforce account_id well-formed-ness where it wasn't enforced\nhistorically.").default(0), "initial_memory_pages": z.number().int().gte(0).describe("The initial number of memory pages.\nNOTE: It's not a limiter itself, but it's a value we use for initial_memory_pages."), "max_actions_per_receipt": z.number().int().gte(0).describe("Max number of actions per receipt."), "max_arguments_length": z.number().int().gte(0).describe("Max length of arguments in a function call action."), "max_contract_size": z.number().int().gte(0).describe("Max contract size"), "max_elements_per_contract_table": z.union([z.number().int().gte(0).describe("If present, stores max number of elements in a single contract's table"), z.null().describe("If present, stores max number of elements in a single contract's table")]).describe("If present, stores max number of elements in a single contract's table").optional(), "max_functions_number_per_contract": z.union([z.number().int().gte(0).describe("If present, stores max number of functions in one contract"), z.null().describe("If present, stores max number of functions in one contract")]).describe("If present, stores max number of functions in one contract").optional(), "max_gas_burnt": z.number().int().gte(0).describe("Max amount of gas that can be used, excluding gas attached to promises."), "max_length_method_name": z.number().int().gte(0).describe("Max length of any method name (without terminating character)."), "max_length_returned_data": z.number().int().gte(0).describe("Max length of returned data"), "max_length_storage_key": z.number().int().gte(0).describe("Max storage key size"), "max_length_storage_value": z.number().int().gte(0).describe("Max storage value size"), "max_locals_per_contract": z.union([z.number().int().gte(0).describe("If present, stores max number of locals declared globally in one contract"), z.null().describe("If present, stores max number of locals declared globally in one contract")]).describe("If present, stores max number of locals declared globally in one contract").optional(), "max_memory_pages": z.number().int().gte(0).describe("What is the maximal memory pages amount is allowed to have for a contract."), "max_number_bytes_method_names": z.number().int().gte(0).describe("Max total length of all method names (including terminating character) for a function call\npermission access key."), "max_number_input_data_dependencies": z.number().int().gte(0).describe("Max number of input data dependencies"), "max_number_logs": z.number().int().gte(0).describe("Maximum number of log entries."), "max_number_registers": z.number().int().gte(0).describe("Maximum number of registers that can be used simultaneously.\n\nNote that due to an implementation quirk [read: a bug] in VMLogic, if we\nhave this number of registers, no subsequent writes to the registers\nwill succeed even if they replace an existing register."), "max_promises_per_function_call_action": z.number().int().gte(0).describe("Max number of promises that a function call can create"), "max_receipt_size": z.number().int().gte(0).describe("Max receipt size"), "max_register_size": z.number().int().gte(0).describe("Maximum number of bytes that can be stored in a single register."), "max_stack_height": z.number().int().gte(0).describe("How tall the stack is allowed to grow?\n\nSee <https://wiki.parity.io/WebAssembly-StackHeight> to find out how the stack frame cost\nis calculated."), "max_tables_per_contract": z.union([z.number().int().gte(0).describe("If present, stores max number of tables declared globally in one contract"), z.null().describe("If present, stores max number of tables declared globally in one contract")]).describe("If present, stores max number of tables declared globally in one contract").optional(), "max_total_log_length": z.number().int().gte(0).describe("Maximum total length in bytes of all log messages."), "max_total_prepaid_gas": z.number().int().gte(0).describe("Max total prepaid gas for all function call actions per receipt."), "max_transaction_size": z.number().int().gte(0).describe("Max transaction size"), "max_yield_payload_size": z.number().int().gte(0).describe("Maximum number of bytes for payload passed over a yield resume."), "per_receipt_storage_proof_size_limit": z.number().int().gte(0).describe("Hard limit on the size of storage proof generated while executing a single receipt."), "registers_memory_limit": z.number().int().gte(0).describe("Limit of memory used by registers."), "yield_timeout_length_in_blocks": z.number().int().gte(0).describe("Number of blocks after which a yielded promise times out.") }).describe("Describes limits for VM and Runtime.\nTODO #4139: consider switching to strongly-typed wrappers instead of raw quantities")
export type LimitConfig = z.infer<typeof LimitConfig>


export const LogSummaryStyle = z.enum(["plain","colored"])
export type LogSummaryStyle = z.infer<typeof LogSummaryStyle>


export const MerklePathItem = z.object({ "direction": z.enum(["Left","Right"]), "hash": z.string() })
export type MerklePathItem = z.infer<typeof MerklePathItem>


export const MethodResolveError = z.enum(["MethodEmptyName","MethodNotFound","MethodInvalidSignature"])
export type MethodResolveError = z.infer<typeof MethodResolveError>


export const MissingTrieValue = z.object({ "context": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("TrieIterator").describe("Missing trie value when reading from TrieIterator."), z.literal("TriePrefetchingStorage").describe("Missing trie value when reading from TriePrefetchingStorage."), z.literal("TrieMemoryPartialStorage").describe("Missing trie value when reading from TrieMemoryPartialStorage."), z.literal("TrieStorage").describe("Missing trie value when reading from TrieStorage.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Contexts in which `StorageError::MissingTrieValue` error might occur."), "hash": z.string() })
export type MissingTrieValue = z.infer<typeof MissingTrieValue>


export const MissingTrieValueContext = z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("TrieIterator").describe("Missing trie value when reading from TrieIterator."), z.literal("TriePrefetchingStorage").describe("Missing trie value when reading from TriePrefetchingStorage."), z.literal("TrieMemoryPartialStorage").describe("Missing trie value when reading from TrieMemoryPartialStorage."), z.literal("TrieStorage").describe("Missing trie value when reading from TrieStorage.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Contexts in which `StorageError::MissingTrieValue` error might occur.")
export type MissingTrieValueContext = z.infer<typeof MissingTrieValueContext>


export const MutableConfigValue = z.string()
export type MutableConfigValue = z.infer<typeof MutableConfigValue>


export const NearGas = z.number().int().gte(0)
export type NearGas = z.infer<typeof NearGas>


export const NearToken = z.string()
export type NearToken = z.infer<typeof NearToken>


export const NetworkInfoView = z.object({ "connected_peers": z.array(z.object({ "account_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "addr": z.string(), "archival": z.boolean(), "block_hash": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "connection_established_time_millis": z.number().int().gte(0), "height": z.union([z.number().int().gte(0), z.null()]).optional(), "is_highest_block_invalid": z.boolean(), "is_outbound_peer": z.boolean(), "last_time_peer_requested_millis": z.number().int().gte(0), "last_time_received_message_millis": z.number().int().gte(0), "nonce": z.number().int().gte(0).describe("Connection nonce."), "peer_id": z.string(), "received_bytes_per_sec": z.number().int().gte(0), "sent_bytes_per_sec": z.number().int().gte(0), "tracked_shards": z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")) })), "known_producers": z.array(z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "next_hops": z.union([z.array(z.string()), z.null()]).optional(), "peer_id": z.string() }).describe("Information about a Producer: its account name, peer_id and a list of connected peers that\nthe node can use to send message for this producer.")), "num_connected_peers": z.number().int().gte(0), "peer_max_count": z.number().int().gte(0), "tier1_accounts_data": z.array(z.object({ "account_key": z.string().describe("Account key of the validator signing this AccountData."), "peer_id": z.string().describe("ID of the node that handles the account key (aka validator key)."), "proxies": z.array(z.object({ "addr": z.string(), "peer_id": z.string() })).describe("Proxy nodes that are directly connected to the validator node\n(this list may include the validator node itself).\nTIER1 nodes should connect to one of the proxies to sent TIER1\nmessages to the validator."), "timestamp": z.string().describe("UTC timestamp of when the AccountData has been signed.") }).describe("AccountData is a piece of global state that a validator\nsigns and broadcasts to the network.\n\nIt is essentially the data that a validator wants to share with the network.\nAll the nodes in the network are collecting the account data\nbroadcasted by the validators.\nSince the number of the validators is bounded and their\nidentity is known (and the maximal size of allowed AccountData is bounded)\nthe global state that is distributed in the form of AccountData is bounded\nas well.\nFind more information in the docs [here](https://github.com/near/nearcore/blob/560f7fc8f4b3106e0d5d46050688610b1f104ac6/chain/client/src/client.rs#L2232)")), "tier1_accounts_keys": z.array(z.string()), "tier1_connections": z.array(z.object({ "account_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "addr": z.string(), "archival": z.boolean(), "block_hash": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "connection_established_time_millis": z.number().int().gte(0), "height": z.union([z.number().int().gte(0), z.null()]).optional(), "is_highest_block_invalid": z.boolean(), "is_outbound_peer": z.boolean(), "last_time_peer_requested_millis": z.number().int().gte(0), "last_time_received_message_millis": z.number().int().gte(0), "nonce": z.number().int().gte(0).describe("Connection nonce."), "peer_id": z.string(), "received_bytes_per_sec": z.number().int().gte(0), "sent_bytes_per_sec": z.number().int().gte(0), "tracked_shards": z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")) })) })
export type NetworkInfoView = z.infer<typeof NetworkInfoView>


export const NextEpochValidatorInfo = z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string(), "shards": z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")), "stake": z.string() })
export type NextEpochValidatorInfo = z.infer<typeof NextEpochValidatorInfo>


export const NonDelegateAction = z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CreateAccount": z.record(z.any()).describe("Create account action") }).strict().describe("Create an (sub)account using a transaction `receiver_id` as an ID for\na new account ID must pass validation rules described here\n<https://nomicon.io/DataStructures/Account>."), z.object({ "DeployContract": z.object({ "code": z.string().describe("WebAssembly binary") }).describe("Deploy contract action") }).strict().describe("Sets a Wasm code to a receiver_id"), z.object({ "FunctionCall": z.object({ "args": z.string(), "deposit": z.string(), "gas": z.number().int().gte(0), "method_name": z.string() }) }).strict(), z.object({ "Transfer": z.object({ "deposit": z.string() }) }).strict(), z.object({ "Stake": z.object({ "public_key": z.string().describe("Validator key which will be used to sign transactions on behalf of signer_id"), "stake": z.string().describe("Amount of tokens to stake.") }).describe("An action which stakes signer_id tokens and setup's validator public key") }).strict(), z.object({ "AddKey": z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0).describe("Nonce for this access key, used for tx nonce generation. When access key is created, nonce\nis set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\nSee <https://github.com/near/nearcore/issues/3779> for more details."), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Allowance is a balance limit to use by this access key to pay for function call gas and\ntransaction fees. When this access key is used, both account balance and the allowance is\ndecreased by the same value.\n`None` means unlimited allowance.\nNOTE: To change or increase the allowance, the old access key needs to be deleted and a new\naccess key should be created.").optional(), "method_names": z.array(z.string()).describe("A list of method names that can be used. The access key only allows transactions with the\nfunction call of one of the given method names.\nEmpty list means any method name can be used."), "receiver_id": z.string().describe("The access key only allows transactions with the given receiver's account id.") }).describe("Grants limited permission to make transactions with FunctionCallActions\nThe permission can limit the allowed balance to be spent on the prepaid gas.\nIt also restrict the account ID of the receiver for this function call.\nIt also can restrict the method name for the allowed function calls.") }).strict(), z.literal("FullAccess").describe("Grants full access to the account.\nNOTE: It's used to replace account-level public keys.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Defines permissions for AccessKey").describe("Defines permissions for this access key.") }).describe("Access key provides limited access to an account. Each access key belongs to some account and\nis identified by a unique (within the account) public key. One account may have large number of\naccess keys. Access keys allow to act on behalf of the account by restricting transactions\nthat can be issued.\n`account_id,public_key` is a key in the state").describe("An access key with the permission"), "public_key": z.string().describe("A public key which will be associated with an access_key") }).describe("An action that adds key with public key associated") }).strict(), z.object({ "DeleteKey": z.object({ "public_key": z.string().describe("A public key associated with the access_key to be deleted.") }) }).strict(), z.object({ "DeleteAccount": z.object({ "beneficiary_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeployGlobalContract": z.object({ "code": z.string().describe("WebAssembly binary"), "deploy_mode": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("CodeHash").describe("Contract is deployed under its code hash.\nUsers will be able reference it by that hash.\nThis effectively makes the contract immutable."), z.literal("AccountId").describe("Contract is deployed under the owner account id.\nUsers will be able reference it by that account id.\nThis allows the owner to update the contract for all its users.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Deploy global contract action") }).strict(), z.object({ "UseGlobalContract": z.object({ "contract_identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Use global contract action") }).strict(), z.object({ "DeterministicStateInit": z.object({ "deposit": z.string(), "state_init": z.object({ "V1": z.object({ "code": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "data": z.record(z.string()) }) }).strict() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An Action that can be included in a transaction or receipt, excluding delegate actions. This type represents all possible action types except DelegateAction to prevent infinite recursion in meta-transactions.")
export type NonDelegateAction = z.infer<typeof NonDelegateAction>


export const PeerId = z.string().describe("Peer id is the public key.")
export type PeerId = z.infer<typeof PeerId>


export const PeerInfoView = z.object({ "account_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "addr": z.string(), "archival": z.boolean(), "block_hash": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "connection_established_time_millis": z.number().int().gte(0), "height": z.union([z.number().int().gte(0), z.null()]).optional(), "is_highest_block_invalid": z.boolean(), "is_outbound_peer": z.boolean(), "last_time_peer_requested_millis": z.number().int().gte(0), "last_time_received_message_millis": z.number().int().gte(0), "nonce": z.number().int().gte(0).describe("Connection nonce."), "peer_id": z.string(), "received_bytes_per_sec": z.number().int().gte(0), "sent_bytes_per_sec": z.number().int().gte(0), "tracked_shards": z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")) })
export type PeerInfoView = z.infer<typeof PeerInfoView>


export const PrepareError = z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Serialization").describe("Error happened while serializing the module."), z.literal("Deserialization").describe("Error happened while deserializing the module."), z.literal("InternalMemoryDeclared").describe("Internal memory declaration has been found in the module."), z.literal("GasInstrumentation").describe("Gas instrumentation failed.\n\nThis most likely indicates the module isn't valid."), z.literal("StackHeightInstrumentation").describe("Stack instrumentation failed.\n\nThis  most likely indicates the module isn't valid."), z.literal("Instantiate").describe("Error happened during instantiation.\n\nThis might indicate that `start` function trapped, or module isn't\ninstantiable and/or un-linkable."), z.literal("Memory").describe("Error creating memory."), z.literal("TooManyFunctions").describe("Contract contains too many functions."), z.literal("TooManyLocals").describe("Contract contains too many locals."), z.literal("TooManyTables").describe("Contract contains too many tables."), z.literal("TooManyTableElements").describe("Contract contains too many table elements.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error that can occur while preparing or executing Wasm smart-contract.")
export type PrepareError = z.infer<typeof PrepareError>


export const ProtocolVersionCheckConfig = z.enum(["Next","NextNext"]).describe("Configures whether the node checks the next or the next next epoch for network version compatibility.")
export type ProtocolVersionCheckConfig = z.infer<typeof ProtocolVersionCheckConfig>


export const PublicKey = z.string()
export type PublicKey = z.infer<typeof PublicKey>


export const ReceiptEnumView = z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "Action": z.object({ "actions": z.array(z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("CreateAccount"), z.object({ "DeployContract": z.object({ "code": z.string() }) }).strict(), z.object({ "FunctionCall": z.object({ "args": z.string().describe("This type is used to mark function arguments.\n\nNOTE: The main reason for this to exist (except the type-safety) is that the value is\ntransparently serialized and deserialized as a base64-encoded string when serde is used\n(serde_json)."), "deposit": z.string(), "gas": z.number().int().gte(0), "method_name": z.string() }) }).strict(), z.object({ "Transfer": z.object({ "deposit": z.string() }) }).strict(), z.object({ "Stake": z.object({ "public_key": z.string(), "stake": z.string() }) }).strict(), z.object({ "AddKey": z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("FullAccess"), z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "method_names": z.array(z.string()), "receiver_id": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the permission scope for an access key. Whether it is a function call or a full access key.") }).describe("Describes access key permission scope and nonce."), "public_key": z.string() }) }).strict(), z.object({ "DeleteKey": z.object({ "public_key": z.string() }) }).strict(), z.object({ "DeleteAccount": z.object({ "beneficiary_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "Delegate": z.object({ "delegate_action": z.object({ "actions": z.array(z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CreateAccount": z.record(z.any()).describe("Create account action") }).strict().describe("Create an (sub)account using a transaction `receiver_id` as an ID for\na new account ID must pass validation rules described here\n<https://nomicon.io/DataStructures/Account>."), z.object({ "DeployContract": z.object({ "code": z.string().describe("WebAssembly binary") }).describe("Deploy contract action") }).strict().describe("Sets a Wasm code to a receiver_id"), z.object({ "FunctionCall": z.object({ "args": z.string(), "deposit": z.string(), "gas": z.number().int().gte(0), "method_name": z.string() }) }).strict(), z.object({ "Transfer": z.object({ "deposit": z.string() }) }).strict(), z.object({ "Stake": z.object({ "public_key": z.string().describe("Validator key which will be used to sign transactions on behalf of signer_id"), "stake": z.string().describe("Amount of tokens to stake.") }).describe("An action which stakes signer_id tokens and setup's validator public key") }).strict(), z.object({ "AddKey": z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0).describe("Nonce for this access key, used for tx nonce generation. When access key is created, nonce\nis set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\nSee <https://github.com/near/nearcore/issues/3779> for more details."), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Allowance is a balance limit to use by this access key to pay for function call gas and\ntransaction fees. When this access key is used, both account balance and the allowance is\ndecreased by the same value.\n`None` means unlimited allowance.\nNOTE: To change or increase the allowance, the old access key needs to be deleted and a new\naccess key should be created.").optional(), "method_names": z.array(z.string()).describe("A list of method names that can be used. The access key only allows transactions with the\nfunction call of one of the given method names.\nEmpty list means any method name can be used."), "receiver_id": z.string().describe("The access key only allows transactions with the given receiver's account id.") }).describe("Grants limited permission to make transactions with FunctionCallActions\nThe permission can limit the allowed balance to be spent on the prepaid gas.\nIt also restrict the account ID of the receiver for this function call.\nIt also can restrict the method name for the allowed function calls.") }).strict(), z.literal("FullAccess").describe("Grants full access to the account.\nNOTE: It's used to replace account-level public keys.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Defines permissions for AccessKey").describe("Defines permissions for this access key.") }).describe("Access key provides limited access to an account. Each access key belongs to some account and\nis identified by a unique (within the account) public key. One account may have large number of\naccess keys. Access keys allow to act on behalf of the account by restricting transactions\nthat can be issued.\n`account_id,public_key` is a key in the state").describe("An access key with the permission"), "public_key": z.string().describe("A public key which will be associated with an access_key") }).describe("An action that adds key with public key associated") }).strict(), z.object({ "DeleteKey": z.object({ "public_key": z.string().describe("A public key associated with the access_key to be deleted.") }) }).strict(), z.object({ "DeleteAccount": z.object({ "beneficiary_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeployGlobalContract": z.object({ "code": z.string().describe("WebAssembly binary"), "deploy_mode": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("CodeHash").describe("Contract is deployed under its code hash.\nUsers will be able reference it by that hash.\nThis effectively makes the contract immutable."), z.literal("AccountId").describe("Contract is deployed under the owner account id.\nUsers will be able reference it by that account id.\nThis allows the owner to update the contract for all its users.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Deploy global contract action") }).strict(), z.object({ "UseGlobalContract": z.object({ "contract_identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Use global contract action") }).strict(), z.object({ "DeterministicStateInit": z.object({ "deposit": z.string(), "state_init": z.object({ "V1": z.object({ "code": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "data": z.record(z.string()) }) }).strict() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An Action that can be included in a transaction or receipt, excluding delegate actions. This type represents all possible action types except DelegateAction to prevent infinite recursion in meta-transactions.")).describe("List of actions to be executed.\n\nWith the meta transactions MVP defined in NEP-366, nested\nDelegateActions are not allowed. A separate type is used to enforce it."), "max_block_height": z.number().int().gte(0).describe("The maximal height of the block in the blockchain below which the given DelegateAction is valid."), "nonce": z.number().int().gte(0).describe("Nonce to ensure that the same delegate action is not sent twice by a\nrelayer and should match for given account's `public_key`.\nAfter this action is processed it will increment."), "public_key": z.string().describe("Public key used to sign this delegated action."), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("Receiver of the delegated actions."), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("Signer of the delegated actions") }).describe("This action allows to execute the inner actions behalf of the defined sender."), "signature": z.string() }) }).strict(), z.object({ "DeployGlobalContract": z.object({ "code": z.string() }) }).strict(), z.object({ "DeployGlobalContractByAccountId": z.object({ "code": z.string() }) }).strict(), z.object({ "UseGlobalContract": z.object({ "code_hash": z.string() }) }).strict(), z.object({ "UseGlobalContractByAccountId": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInit": z.object({ "code": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "hash": z.string() }).strict(), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "data": z.record(z.string()), "deposit": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })), "gas_price": z.string(), "input_data_ids": z.array(z.string()), "is_promise_yield": z.boolean().default(false), "output_data_receivers": z.array(z.object({ "data_id": z.string(), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") })), "refund_to": z.any().superRefine((x, ctx) => {
    const schemas = [z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "signer_public_key": z.string() }) }).strict(), z.object({ "Data": z.object({ "data": z.union([z.string(), z.null()]).default(null), "data_id": z.string(), "is_promise_resume": z.boolean().default(false) }) }).strict(), z.object({ "GlobalContractDistribution": z.object({ "already_delivered_shards": z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")), "code": z.string(), "id": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "target_shard": z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.") }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })
export type ReceiptEnumView = z.infer<typeof ReceiptEnumView>


export const ReceiptValidationError = z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidPredecessorId": z.object({ "account_id": z.string() }) }).strict().describe("The `predecessor_id` of a Receipt is not valid."), z.object({ "InvalidReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a Receipt is not valid."), z.object({ "InvalidSignerId": z.object({ "account_id": z.string() }) }).strict().describe("The `signer_id` of an ActionReceipt is not valid."), z.object({ "InvalidDataReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a DataReceiver within an ActionReceipt is not valid."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the returned data exceeded the limit in a DataReceipt."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The number of input data dependencies exceeds the limit in an ActionReceipt."), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of an ActionReceipt."), z.object({ "ReceiptSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("Receipt is bigger than the limit."), z.object({ "InvalidRefundTo": z.object({ "account_id": z.string() }) }).strict().describe("The `refund_to` of an ActionReceipt is not valid.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a receipt.")
export type ReceiptValidationError = z.infer<typeof ReceiptValidationError>


export const ReceiptView = z.object({ "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "priority": z.number().int().gte(0).default(0), "receipt": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "Action": z.object({ "actions": z.array(z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("CreateAccount"), z.object({ "DeployContract": z.object({ "code": z.string() }) }).strict(), z.object({ "FunctionCall": z.object({ "args": z.string().describe("This type is used to mark function arguments.\n\nNOTE: The main reason for this to exist (except the type-safety) is that the value is\ntransparently serialized and deserialized as a base64-encoded string when serde is used\n(serde_json)."), "deposit": z.string(), "gas": z.number().int().gte(0), "method_name": z.string() }) }).strict(), z.object({ "Transfer": z.object({ "deposit": z.string() }) }).strict(), z.object({ "Stake": z.object({ "public_key": z.string(), "stake": z.string() }) }).strict(), z.object({ "AddKey": z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("FullAccess"), z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "method_names": z.array(z.string()), "receiver_id": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the permission scope for an access key. Whether it is a function call or a full access key.") }).describe("Describes access key permission scope and nonce."), "public_key": z.string() }) }).strict(), z.object({ "DeleteKey": z.object({ "public_key": z.string() }) }).strict(), z.object({ "DeleteAccount": z.object({ "beneficiary_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "Delegate": z.object({ "delegate_action": z.object({ "actions": z.array(z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CreateAccount": z.record(z.any()).describe("Create account action") }).strict().describe("Create an (sub)account using a transaction `receiver_id` as an ID for\na new account ID must pass validation rules described here\n<https://nomicon.io/DataStructures/Account>."), z.object({ "DeployContract": z.object({ "code": z.string().describe("WebAssembly binary") }).describe("Deploy contract action") }).strict().describe("Sets a Wasm code to a receiver_id"), z.object({ "FunctionCall": z.object({ "args": z.string(), "deposit": z.string(), "gas": z.number().int().gte(0), "method_name": z.string() }) }).strict(), z.object({ "Transfer": z.object({ "deposit": z.string() }) }).strict(), z.object({ "Stake": z.object({ "public_key": z.string().describe("Validator key which will be used to sign transactions on behalf of signer_id"), "stake": z.string().describe("Amount of tokens to stake.") }).describe("An action which stakes signer_id tokens and setup's validator public key") }).strict(), z.object({ "AddKey": z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0).describe("Nonce for this access key, used for tx nonce generation. When access key is created, nonce\nis set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\nSee <https://github.com/near/nearcore/issues/3779> for more details."), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Allowance is a balance limit to use by this access key to pay for function call gas and\ntransaction fees. When this access key is used, both account balance and the allowance is\ndecreased by the same value.\n`None` means unlimited allowance.\nNOTE: To change or increase the allowance, the old access key needs to be deleted and a new\naccess key should be created.").optional(), "method_names": z.array(z.string()).describe("A list of method names that can be used. The access key only allows transactions with the\nfunction call of one of the given method names.\nEmpty list means any method name can be used."), "receiver_id": z.string().describe("The access key only allows transactions with the given receiver's account id.") }).describe("Grants limited permission to make transactions with FunctionCallActions\nThe permission can limit the allowed balance to be spent on the prepaid gas.\nIt also restrict the account ID of the receiver for this function call.\nIt also can restrict the method name for the allowed function calls.") }).strict(), z.literal("FullAccess").describe("Grants full access to the account.\nNOTE: It's used to replace account-level public keys.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Defines permissions for AccessKey").describe("Defines permissions for this access key.") }).describe("Access key provides limited access to an account. Each access key belongs to some account and\nis identified by a unique (within the account) public key. One account may have large number of\naccess keys. Access keys allow to act on behalf of the account by restricting transactions\nthat can be issued.\n`account_id,public_key` is a key in the state").describe("An access key with the permission"), "public_key": z.string().describe("A public key which will be associated with an access_key") }).describe("An action that adds key with public key associated") }).strict(), z.object({ "DeleteKey": z.object({ "public_key": z.string().describe("A public key associated with the access_key to be deleted.") }) }).strict(), z.object({ "DeleteAccount": z.object({ "beneficiary_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeployGlobalContract": z.object({ "code": z.string().describe("WebAssembly binary"), "deploy_mode": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("CodeHash").describe("Contract is deployed under its code hash.\nUsers will be able reference it by that hash.\nThis effectively makes the contract immutable."), z.literal("AccountId").describe("Contract is deployed under the owner account id.\nUsers will be able reference it by that account id.\nThis allows the owner to update the contract for all its users.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Deploy global contract action") }).strict(), z.object({ "UseGlobalContract": z.object({ "contract_identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Use global contract action") }).strict(), z.object({ "DeterministicStateInit": z.object({ "deposit": z.string(), "state_init": z.object({ "V1": z.object({ "code": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "data": z.record(z.string()) }) }).strict() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An Action that can be included in a transaction or receipt, excluding delegate actions. This type represents all possible action types except DelegateAction to prevent infinite recursion in meta-transactions.")).describe("List of actions to be executed.\n\nWith the meta transactions MVP defined in NEP-366, nested\nDelegateActions are not allowed. A separate type is used to enforce it."), "max_block_height": z.number().int().gte(0).describe("The maximal height of the block in the blockchain below which the given DelegateAction is valid."), "nonce": z.number().int().gte(0).describe("Nonce to ensure that the same delegate action is not sent twice by a\nrelayer and should match for given account's `public_key`.\nAfter this action is processed it will increment."), "public_key": z.string().describe("Public key used to sign this delegated action."), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("Receiver of the delegated actions."), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("Signer of the delegated actions") }).describe("This action allows to execute the inner actions behalf of the defined sender."), "signature": z.string() }) }).strict(), z.object({ "DeployGlobalContract": z.object({ "code": z.string() }) }).strict(), z.object({ "DeployGlobalContractByAccountId": z.object({ "code": z.string() }) }).strict(), z.object({ "UseGlobalContract": z.object({ "code_hash": z.string() }) }).strict(), z.object({ "UseGlobalContractByAccountId": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInit": z.object({ "code": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "hash": z.string() }).strict(), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "data": z.record(z.string()), "deposit": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })), "gas_price": z.string(), "input_data_ids": z.array(z.string()), "is_promise_yield": z.boolean().default(false), "output_data_receivers": z.array(z.object({ "data_id": z.string(), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") })), "refund_to": z.any().superRefine((x, ctx) => {
    const schemas = [z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "signer_public_key": z.string() }) }).strict(), z.object({ "Data": z.object({ "data": z.union([z.string(), z.null()]).default(null), "data_id": z.string(), "is_promise_resume": z.boolean().default(false) }) }).strict(), z.object({ "GlobalContractDistribution": z.object({ "already_delivered_shards": z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")), "code": z.string(), "id": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "target_shard": z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.") }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "receipt_id": z.string(), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") })
export type ReceiptView = z.infer<typeof ReceiptView>


export const RpcBlockRequest = z.record(z.any()).and(z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "block_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.number().int().gte(0), z.string()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }), z.object({ "finality": z.enum(["optimistic","near-final","final"]).describe("Different types of finality.") }), z.object({ "sync_checkpoint": z.enum(["genesis","earliest_available"]) })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }))
export type RpcBlockRequest = z.infer<typeof RpcBlockRequest>


export const RpcBlockResponse = z.object({ "author": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("The AccountId of the author of the Block"), "chunks": z.array(z.object({ "balance_burnt": z.string(), "bandwidth_requests": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "V1": z.object({ "requests": z.array(z.object({ "requested_values_bitmap": z.object({ "data": z.array(z.number().int().gte(0).lte(255)).min(5).max(5) }).describe("Bitmap which describes which values from the predefined list are being requested.\nThe nth bit is set to 1 when the nth value from the list is being requested.").describe("Bitmap which describes what values of bandwidth are requested."), "to_shard": z.number().int().gte(0).lte(65535).describe("Requesting bandwidth to this shard.") }).describe("`BandwidthRequest` describes the size of receipts that a shard would like to send to another shard.\nWhen a shard wants to send a lot of receipts to another shard, it needs to create a request and wait\nfor a bandwidth grant from the bandwidth scheduler.")) }).describe("Version 1 of [`BandwidthRequest`].") }).strict().describe("A list of shard's bandwidth requests.\nDescribes how much the shard would like to send to other shards."), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "chunk_hash": z.string(), "congestion_info": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "allowed_shard": z.number().int().gte(0).lte(65535), "buffered_receipts_gas": z.string(), "delayed_receipts_gas": z.string(), "receipt_bytes": z.number().int().gte(0) }).describe("Stores the congestion level of a shard. More info about congestion [here](https://near.github.io/nearcore/architecture/how/receipt-congestion.html?highlight=congestion#receipt-congestion)"), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "encoded_length": z.number().int().gte(0), "encoded_merkle_root": z.string(), "gas_limit": z.number().int().gte(0), "gas_used": z.number().int().gte(0), "height_created": z.number().int().gte(0), "height_included": z.number().int().gte(0), "outcome_root": z.string(), "outgoing_receipts_root": z.string(), "prev_block_hash": z.string(), "prev_state_root": z.string(), "rent_paid": z.string().describe("TODO(2271): deprecated.").default("0"), "shard_id": z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias."), "signature": z.string(), "tx_root": z.string(), "validator_proposals": z.array(z.object({ "validator_stake_struct_version": z.literal("V1") }).and(z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string(), "stake": z.string() }))), "validator_reward": z.string().describe("TODO(2271): deprecated.").default("0") }).describe("Contains main info about the chunk.")), "header": z.object({ "approvals": z.array(z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })), "block_body_hash": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "block_merkle_root": z.string(), "block_ordinal": z.union([z.number().int().gte(0), z.null()]).optional(), "challenges_result": z.array(z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "is_double_sign": z.boolean() })), "challenges_root": z.string(), "chunk_endorsements": z.union([z.array(z.array(z.number().int().gte(0).lte(255))), z.null()]).optional(), "chunk_headers_root": z.string(), "chunk_mask": z.array(z.boolean()), "chunk_receipts_root": z.string(), "chunk_tx_root": z.string(), "chunks_included": z.number().int().gte(0), "epoch_id": z.string(), "epoch_sync_data_hash": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "gas_price": z.string(), "hash": z.string(), "height": z.number().int().gte(0), "last_ds_final_block": z.string(), "last_final_block": z.string(), "latest_protocol_version": z.number().int().gte(0), "next_bp_hash": z.string(), "next_epoch_id": z.string(), "outcome_root": z.string(), "prev_hash": z.string().describe("The hash of the previous Block"), "prev_height": z.union([z.number().int().gte(0), z.null()]).optional(), "prev_state_root": z.string(), "random_value": z.string(), "rent_paid": z.string().describe("TODO(2271): deprecated.").default("0"), "signature": z.string().describe("Signature of the block producer."), "timestamp": z.number().int().gte(0).describe("Legacy json number. Should not be used."), "timestamp_nanosec": z.string(), "total_supply": z.string(), "validator_proposals": z.array(z.object({ "validator_stake_struct_version": z.literal("V1") }).and(z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string(), "stake": z.string() }))), "validator_reward": z.string().describe("TODO(2271): deprecated.").default("0") }).describe("Contains main info about the block.") })
export type RpcBlockResponse = z.infer<typeof RpcBlockResponse>


export const RpcChunkRequest = z.record(z.any()).and(z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "block_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.number().int().gte(0), z.string()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "shard_id": z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.") }), z.object({ "chunk_id": z.string() })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }))
export type RpcChunkRequest = z.infer<typeof RpcChunkRequest>


export const RpcChunkResponse = z.object({ "author": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "header": z.object({ "balance_burnt": z.string(), "bandwidth_requests": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "V1": z.object({ "requests": z.array(z.object({ "requested_values_bitmap": z.object({ "data": z.array(z.number().int().gte(0).lte(255)).min(5).max(5) }).describe("Bitmap which describes which values from the predefined list are being requested.\nThe nth bit is set to 1 when the nth value from the list is being requested.").describe("Bitmap which describes what values of bandwidth are requested."), "to_shard": z.number().int().gte(0).lte(65535).describe("Requesting bandwidth to this shard.") }).describe("`BandwidthRequest` describes the size of receipts that a shard would like to send to another shard.\nWhen a shard wants to send a lot of receipts to another shard, it needs to create a request and wait\nfor a bandwidth grant from the bandwidth scheduler.")) }).describe("Version 1 of [`BandwidthRequest`].") }).strict().describe("A list of shard's bandwidth requests.\nDescribes how much the shard would like to send to other shards."), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "chunk_hash": z.string(), "congestion_info": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "allowed_shard": z.number().int().gte(0).lte(65535), "buffered_receipts_gas": z.string(), "delayed_receipts_gas": z.string(), "receipt_bytes": z.number().int().gte(0) }).describe("Stores the congestion level of a shard. More info about congestion [here](https://near.github.io/nearcore/architecture/how/receipt-congestion.html?highlight=congestion#receipt-congestion)"), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "encoded_length": z.number().int().gte(0), "encoded_merkle_root": z.string(), "gas_limit": z.number().int().gte(0), "gas_used": z.number().int().gte(0), "height_created": z.number().int().gte(0), "height_included": z.number().int().gte(0), "outcome_root": z.string(), "outgoing_receipts_root": z.string(), "prev_block_hash": z.string(), "prev_state_root": z.string(), "rent_paid": z.string().describe("TODO(2271): deprecated.").default("0"), "shard_id": z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias."), "signature": z.string(), "tx_root": z.string(), "validator_proposals": z.array(z.object({ "validator_stake_struct_version": z.literal("V1") }).and(z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string(), "stake": z.string() }))), "validator_reward": z.string().describe("TODO(2271): deprecated.").default("0") }).describe("Contains main info about the chunk."), "receipts": z.array(z.object({ "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "priority": z.number().int().gte(0).default(0), "receipt": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "Action": z.object({ "actions": z.array(z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("CreateAccount"), z.object({ "DeployContract": z.object({ "code": z.string() }) }).strict(), z.object({ "FunctionCall": z.object({ "args": z.string().describe("This type is used to mark function arguments.\n\nNOTE: The main reason for this to exist (except the type-safety) is that the value is\ntransparently serialized and deserialized as a base64-encoded string when serde is used\n(serde_json)."), "deposit": z.string(), "gas": z.number().int().gte(0), "method_name": z.string() }) }).strict(), z.object({ "Transfer": z.object({ "deposit": z.string() }) }).strict(), z.object({ "Stake": z.object({ "public_key": z.string(), "stake": z.string() }) }).strict(), z.object({ "AddKey": z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("FullAccess"), z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "method_names": z.array(z.string()), "receiver_id": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the permission scope for an access key. Whether it is a function call or a full access key.") }).describe("Describes access key permission scope and nonce."), "public_key": z.string() }) }).strict(), z.object({ "DeleteKey": z.object({ "public_key": z.string() }) }).strict(), z.object({ "DeleteAccount": z.object({ "beneficiary_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "Delegate": z.object({ "delegate_action": z.object({ "actions": z.array(z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CreateAccount": z.record(z.any()).describe("Create account action") }).strict().describe("Create an (sub)account using a transaction `receiver_id` as an ID for\na new account ID must pass validation rules described here\n<https://nomicon.io/DataStructures/Account>."), z.object({ "DeployContract": z.object({ "code": z.string().describe("WebAssembly binary") }).describe("Deploy contract action") }).strict().describe("Sets a Wasm code to a receiver_id"), z.object({ "FunctionCall": z.object({ "args": z.string(), "deposit": z.string(), "gas": z.number().int().gte(0), "method_name": z.string() }) }).strict(), z.object({ "Transfer": z.object({ "deposit": z.string() }) }).strict(), z.object({ "Stake": z.object({ "public_key": z.string().describe("Validator key which will be used to sign transactions on behalf of signer_id"), "stake": z.string().describe("Amount of tokens to stake.") }).describe("An action which stakes signer_id tokens and setup's validator public key") }).strict(), z.object({ "AddKey": z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0).describe("Nonce for this access key, used for tx nonce generation. When access key is created, nonce\nis set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\nSee <https://github.com/near/nearcore/issues/3779> for more details."), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Allowance is a balance limit to use by this access key to pay for function call gas and\ntransaction fees. When this access key is used, both account balance and the allowance is\ndecreased by the same value.\n`None` means unlimited allowance.\nNOTE: To change or increase the allowance, the old access key needs to be deleted and a new\naccess key should be created.").optional(), "method_names": z.array(z.string()).describe("A list of method names that can be used. The access key only allows transactions with the\nfunction call of one of the given method names.\nEmpty list means any method name can be used."), "receiver_id": z.string().describe("The access key only allows transactions with the given receiver's account id.") }).describe("Grants limited permission to make transactions with FunctionCallActions\nThe permission can limit the allowed balance to be spent on the prepaid gas.\nIt also restrict the account ID of the receiver for this function call.\nIt also can restrict the method name for the allowed function calls.") }).strict(), z.literal("FullAccess").describe("Grants full access to the account.\nNOTE: It's used to replace account-level public keys.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Defines permissions for AccessKey").describe("Defines permissions for this access key.") }).describe("Access key provides limited access to an account. Each access key belongs to some account and\nis identified by a unique (within the account) public key. One account may have large number of\naccess keys. Access keys allow to act on behalf of the account by restricting transactions\nthat can be issued.\n`account_id,public_key` is a key in the state").describe("An access key with the permission"), "public_key": z.string().describe("A public key which will be associated with an access_key") }).describe("An action that adds key with public key associated") }).strict(), z.object({ "DeleteKey": z.object({ "public_key": z.string().describe("A public key associated with the access_key to be deleted.") }) }).strict(), z.object({ "DeleteAccount": z.object({ "beneficiary_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeployGlobalContract": z.object({ "code": z.string().describe("WebAssembly binary"), "deploy_mode": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("CodeHash").describe("Contract is deployed under its code hash.\nUsers will be able reference it by that hash.\nThis effectively makes the contract immutable."), z.literal("AccountId").describe("Contract is deployed under the owner account id.\nUsers will be able reference it by that account id.\nThis allows the owner to update the contract for all its users.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Deploy global contract action") }).strict(), z.object({ "UseGlobalContract": z.object({ "contract_identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Use global contract action") }).strict(), z.object({ "DeterministicStateInit": z.object({ "deposit": z.string(), "state_init": z.object({ "V1": z.object({ "code": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "data": z.record(z.string()) }) }).strict() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An Action that can be included in a transaction or receipt, excluding delegate actions. This type represents all possible action types except DelegateAction to prevent infinite recursion in meta-transactions.")).describe("List of actions to be executed.\n\nWith the meta transactions MVP defined in NEP-366, nested\nDelegateActions are not allowed. A separate type is used to enforce it."), "max_block_height": z.number().int().gte(0).describe("The maximal height of the block in the blockchain below which the given DelegateAction is valid."), "nonce": z.number().int().gte(0).describe("Nonce to ensure that the same delegate action is not sent twice by a\nrelayer and should match for given account's `public_key`.\nAfter this action is processed it will increment."), "public_key": z.string().describe("Public key used to sign this delegated action."), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("Receiver of the delegated actions."), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("Signer of the delegated actions") }).describe("This action allows to execute the inner actions behalf of the defined sender."), "signature": z.string() }) }).strict(), z.object({ "DeployGlobalContract": z.object({ "code": z.string() }) }).strict(), z.object({ "DeployGlobalContractByAccountId": z.object({ "code": z.string() }) }).strict(), z.object({ "UseGlobalContract": z.object({ "code_hash": z.string() }) }).strict(), z.object({ "UseGlobalContractByAccountId": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInit": z.object({ "code": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "hash": z.string() }).strict(), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "data": z.record(z.string()), "deposit": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })), "gas_price": z.string(), "input_data_ids": z.array(z.string()), "is_promise_yield": z.boolean().default(false), "output_data_receivers": z.array(z.object({ "data_id": z.string(), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") })), "refund_to": z.any().superRefine((x, ctx) => {
    const schemas = [z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "signer_public_key": z.string() }) }).strict(), z.object({ "Data": z.object({ "data": z.union([z.string(), z.null()]).default(null), "data_id": z.string(), "is_promise_resume": z.boolean().default(false) }) }).strict(), z.object({ "GlobalContractDistribution": z.object({ "already_delivered_shards": z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")), "code": z.string(), "id": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "target_shard": z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.") }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "receipt_id": z.string(), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") })), "transactions": z.array(z.object({ "actions": z.array(z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("CreateAccount"), z.object({ "DeployContract": z.object({ "code": z.string() }) }).strict(), z.object({ "FunctionCall": z.object({ "args": z.string().describe("This type is used to mark function arguments.\n\nNOTE: The main reason for this to exist (except the type-safety) is that the value is\ntransparently serialized and deserialized as a base64-encoded string when serde is used\n(serde_json)."), "deposit": z.string(), "gas": z.number().int().gte(0), "method_name": z.string() }) }).strict(), z.object({ "Transfer": z.object({ "deposit": z.string() }) }).strict(), z.object({ "Stake": z.object({ "public_key": z.string(), "stake": z.string() }) }).strict(), z.object({ "AddKey": z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("FullAccess"), z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "method_names": z.array(z.string()), "receiver_id": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the permission scope for an access key. Whether it is a function call or a full access key.") }).describe("Describes access key permission scope and nonce."), "public_key": z.string() }) }).strict(), z.object({ "DeleteKey": z.object({ "public_key": z.string() }) }).strict(), z.object({ "DeleteAccount": z.object({ "beneficiary_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "Delegate": z.object({ "delegate_action": z.object({ "actions": z.array(z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CreateAccount": z.record(z.any()).describe("Create account action") }).strict().describe("Create an (sub)account using a transaction `receiver_id` as an ID for\na new account ID must pass validation rules described here\n<https://nomicon.io/DataStructures/Account>."), z.object({ "DeployContract": z.object({ "code": z.string().describe("WebAssembly binary") }).describe("Deploy contract action") }).strict().describe("Sets a Wasm code to a receiver_id"), z.object({ "FunctionCall": z.object({ "args": z.string(), "deposit": z.string(), "gas": z.number().int().gte(0), "method_name": z.string() }) }).strict(), z.object({ "Transfer": z.object({ "deposit": z.string() }) }).strict(), z.object({ "Stake": z.object({ "public_key": z.string().describe("Validator key which will be used to sign transactions on behalf of signer_id"), "stake": z.string().describe("Amount of tokens to stake.") }).describe("An action which stakes signer_id tokens and setup's validator public key") }).strict(), z.object({ "AddKey": z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0).describe("Nonce for this access key, used for tx nonce generation. When access key is created, nonce\nis set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\nSee <https://github.com/near/nearcore/issues/3779> for more details."), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Allowance is a balance limit to use by this access key to pay for function call gas and\ntransaction fees. When this access key is used, both account balance and the allowance is\ndecreased by the same value.\n`None` means unlimited allowance.\nNOTE: To change or increase the allowance, the old access key needs to be deleted and a new\naccess key should be created.").optional(), "method_names": z.array(z.string()).describe("A list of method names that can be used. The access key only allows transactions with the\nfunction call of one of the given method names.\nEmpty list means any method name can be used."), "receiver_id": z.string().describe("The access key only allows transactions with the given receiver's account id.") }).describe("Grants limited permission to make transactions with FunctionCallActions\nThe permission can limit the allowed balance to be spent on the prepaid gas.\nIt also restrict the account ID of the receiver for this function call.\nIt also can restrict the method name for the allowed function calls.") }).strict(), z.literal("FullAccess").describe("Grants full access to the account.\nNOTE: It's used to replace account-level public keys.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Defines permissions for AccessKey").describe("Defines permissions for this access key.") }).describe("Access key provides limited access to an account. Each access key belongs to some account and\nis identified by a unique (within the account) public key. One account may have large number of\naccess keys. Access keys allow to act on behalf of the account by restricting transactions\nthat can be issued.\n`account_id,public_key` is a key in the state").describe("An access key with the permission"), "public_key": z.string().describe("A public key which will be associated with an access_key") }).describe("An action that adds key with public key associated") }).strict(), z.object({ "DeleteKey": z.object({ "public_key": z.string().describe("A public key associated with the access_key to be deleted.") }) }).strict(), z.object({ "DeleteAccount": z.object({ "beneficiary_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeployGlobalContract": z.object({ "code": z.string().describe("WebAssembly binary"), "deploy_mode": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("CodeHash").describe("Contract is deployed under its code hash.\nUsers will be able reference it by that hash.\nThis effectively makes the contract immutable."), z.literal("AccountId").describe("Contract is deployed under the owner account id.\nUsers will be able reference it by that account id.\nThis allows the owner to update the contract for all its users.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Deploy global contract action") }).strict(), z.object({ "UseGlobalContract": z.object({ "contract_identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Use global contract action") }).strict(), z.object({ "DeterministicStateInit": z.object({ "deposit": z.string(), "state_init": z.object({ "V1": z.object({ "code": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "data": z.record(z.string()) }) }).strict() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An Action that can be included in a transaction or receipt, excluding delegate actions. This type represents all possible action types except DelegateAction to prevent infinite recursion in meta-transactions.")).describe("List of actions to be executed.\n\nWith the meta transactions MVP defined in NEP-366, nested\nDelegateActions are not allowed. A separate type is used to enforce it."), "max_block_height": z.number().int().gte(0).describe("The maximal height of the block in the blockchain below which the given DelegateAction is valid."), "nonce": z.number().int().gte(0).describe("Nonce to ensure that the same delegate action is not sent twice by a\nrelayer and should match for given account's `public_key`.\nAfter this action is processed it will increment."), "public_key": z.string().describe("Public key used to sign this delegated action."), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("Receiver of the delegated actions."), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("Signer of the delegated actions") }).describe("This action allows to execute the inner actions behalf of the defined sender."), "signature": z.string() }) }).strict(), z.object({ "DeployGlobalContract": z.object({ "code": z.string() }) }).strict(), z.object({ "DeployGlobalContractByAccountId": z.object({ "code": z.string() }) }).strict(), z.object({ "UseGlobalContract": z.object({ "code_hash": z.string() }) }).strict(), z.object({ "UseGlobalContractByAccountId": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInit": z.object({ "code": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "hash": z.string() }).strict(), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "data": z.record(z.string()), "deposit": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })), "hash": z.string(), "nonce": z.number().int().gte(0), "priority_fee": z.number().int().gte(0).default(0), "public_key": z.string(), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "signature": z.string(), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") })) })
export type RpcChunkResponse = z.infer<typeof RpcChunkResponse>


export const RpcClientConfigRequest = z.record(z.any())
export type RpcClientConfigRequest = z.infer<typeof RpcClientConfigRequest>


export const RpcClientConfigResponse = z.object({ "archive": z.boolean().describe("Not clear old data, set `true` for archive nodes."), "block_fetch_horizon": z.number().int().gte(0).describe("Horizon at which instead of fetching block, fetch full state."), "block_header_fetch_horizon": z.number().int().gte(0).describe("Behind this horizon header fetch kicks in."), "block_production_tracking_delay": z.array(z.number().int().gte(0)).min(2).max(2).describe("Duration to check for producing / skipping block."), "catchup_step_period": z.array(z.number().int().gte(0)).min(2).max(2).describe("Time between check to perform catchup."), "chain_id": z.string().describe("Chain id for status."), "chunk_distribution_network": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "enabled": z.boolean(), "uris": z.object({ "get": z.string().describe("URI for pulling chunks from the stream."), "set": z.string().describe("URI for publishing chunks to the stream.") }).describe("URIs for the Chunk Distribution Network feature.") }).describe("Config for the Chunk Distribution Network feature.\nThis allows nodes to push and pull chunks from a central stream.\nThe two benefits of this approach are: (1) less request/response traffic\non the peer-to-peer network and (2) lower latency for RPC nodes indexing the chain."), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Optional config for the Chunk Distribution Network feature.\nIf set to `None` then this node does not participate in the Chunk Distribution Network.\nNodes not participating will still function fine, but possibly with higher\nlatency due to the need of requesting chunks over the peer-to-peer network.").optional(), "chunk_request_retry_period": z.array(z.number().int().gte(0)).min(2).max(2).describe("Time between checking to re-request chunks."), "chunk_validation_threads": z.number().int().gte(0).describe("Number of threads for ChunkValidationActor pool."), "chunk_wait_mult": z.array(z.number().int()).min(2).max(2).describe("Multiplier for the wait time for all chunks to be received."), "client_background_migration_threads": z.number().int().gte(0).describe("Number of threads to execute background migration work in client."), "cloud_archival_writer": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "archive_block_data": z.boolean().describe("Determines whether block-related data should be written to cloud storage.").default(false), "polling_interval": z.object({ "nanos": z.number().int(), "secs": z.number().int() }).describe("Interval at which the system checks for new blocks or chunks to archive.").default({"nanos":0,"secs":1}) }).describe("Configuration for a cloud-based archival writer. If this config is present, the writer is enabled and\nwrites chunk-related data based on the tracked shards. This config also controls additional archival\nbehavior such as block data and polling interval."), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Configuration for a cloud-based archival writer. If this config is present, the writer is enabled and\nwrites chunk-related data based on the tracked shards.").optional(), "doomslug_step_period": z.array(z.number().int().gte(0)).min(2).max(2).describe("Time between running doomslug timer."), "dynamic_resharding_dry_run": z.boolean().describe("If true, the runtime will do a dynamic resharding 'dry run' at the last block of each epoch.\nThis means calculating tentative boundary accounts for splitting the tracked shards."), "enable_early_prepare_transactions": z.boolean().describe("If true, transactions for the next chunk will be prepared early, right after the previous chunk's\npost-state is ready. This can help produce chunks faster, for high-throughput chains.\nThe current implementation increases latency on low-load chains, which will be fixed in the future.\nThe default is disabled."), "enable_multiline_logging": z.boolean(), "enable_statistics_export": z.boolean().describe("Re-export storage layer statistics as prometheus metrics."), "epoch_length": z.number().int().gte(0).describe("Epoch length."), "epoch_sync": z.object({ "disable_epoch_sync_for_bootstrapping": z.boolean().describe("If true, even if the node started from genesis, it will not perform epoch sync.\nThere should be no reason to set this flag in production, because on both mainnet\nand testnet it would be infeasible to catch up from genesis without epoch sync.").default(false), "epoch_sync_horizon": z.number().int().gte(0).describe("This serves as two purposes: (1) the node will not epoch sync and instead resort to\nheader sync, if the genesis block is within this many blocks from the current block;\n(2) the node will reject an epoch sync proof if the provided proof is for an epoch\nthat is more than this many blocks behind the current block."), "ignore_epoch_sync_network_requests": z.boolean().describe("If true, the node will ignore epoch sync requests from the network. It is strongly\nrecommended not to set this flag, because it will prevent other nodes from\nbootstrapping. This flag is only included as a kill-switch and may be removed in a\nfuture release. Please note that epoch sync requests are heavily rate limited and\ncached, and therefore should not affect the performance of the node or introduce\nany non-negligible increase in network traffic.").default(false), "timeout_for_epoch_sync": z.object({ "nanos": z.number().int(), "secs": z.number().int() }).describe("Timeout for epoch sync requests. The node will continue retrying indefinitely even\nif this timeout is exceeded.") }).describe("Options for epoch sync."), "expected_shutdown": z.string().describe("Graceful shutdown at expected block height."), "gc": z.object({ "gc_blocks_limit": z.number().int().gte(0).describe("Maximum number of blocks to garbage collect at every garbage collection\ncall.").default(2), "gc_fork_clean_step": z.number().int().gte(0).describe("Maximum number of height to go through at each garbage collection step\nwhen cleaning forks during garbage collection.").default(100), "gc_num_epochs_to_keep": z.number().int().gte(0).describe("Number of epochs for which we keep store data.").default(5), "gc_step_period": z.object({ "nanos": z.number().int(), "secs": z.number().int() }).describe("How often gc should be run").default({"nanos":500000000,"secs":0}) }).describe("Configuration for garbage collection.").describe("Garbage collection configuration."), "header_sync_expected_height_per_second": z.number().int().gte(0).describe("Expected increase of header head height per second during header sync"), "header_sync_initial_timeout": z.array(z.number().int().gte(0)).min(2).max(2).describe("How much time to wait after initial header sync"), "header_sync_progress_timeout": z.array(z.number().int().gte(0)).min(2).max(2).describe("How much time to wait after some progress is made in header sync"), "header_sync_stall_ban_timeout": z.array(z.number().int().gte(0)).min(2).max(2).describe("How much time to wait before banning a peer in header sync if sync is too slow"), "log_summary_period": z.array(z.number().int().gte(0)).min(2).max(2).describe("Period between logging summary information."), "log_summary_style": z.enum(["plain","colored"]).describe("Enable coloring of the logs"), "max_block_production_delay": z.array(z.number().int().gte(0)).min(2).max(2).describe("Maximum wait for approvals before producing block."), "max_block_wait_delay": z.array(z.number().int().gte(0)).min(2).max(2).describe("Maximum duration before skipping given height."), "max_gas_burnt_view": z.any().superRefine((x, ctx) => {
    const schemas = [z.number().int().gte(0), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Max burnt gas per view method.  If present, overrides value stored in\ngenesis file.  The value only affects the RPCs without influencing the\nprotocol thus changing it per-node doesn’t affect the blockchain.").optional(), "min_block_production_delay": z.array(z.number().int().gte(0)).min(2).max(2).describe("Minimum duration before producing block."), "min_num_peers": z.number().int().gte(0).describe("Minimum number of peers to start syncing."), "num_block_producer_seats": z.number().int().gte(0).describe("Number of block producer seats"), "orphan_state_witness_max_size": z.number().int().gte(0).describe("Maximum size of state witnesses in the OrphanStateWitnessPool.\n\nWe keep only orphan witnesses which are smaller than this size.\nThis limits the maximum memory usage of OrphanStateWitnessPool."), "orphan_state_witness_pool_size": z.number().int().gte(0).describe("OrphanStateWitnessPool keeps instances of ChunkStateWitness which can't be processed\nbecause the previous block isn't available. The witnesses wait in the pool until the\nrequired block appears. This variable controls how many witnesses can be stored in the pool."), "produce_chunk_add_transactions_time_limit": z.string().describe("Limit the time of adding transactions to a chunk.\nA node produces a chunk by adding transactions from the transaction pool until\nsome limit is reached. This time limit ensures that adding transactions won't take\nlonger than the specified duration, which helps to produce the chunk quickly."), "produce_empty_blocks": z.boolean().describe("Produce empty blocks, use `false` for testing."), "protocol_version_check": z.enum(["Next","NextNext"]).describe("Configures whether the node checks the next or the next next epoch for network version compatibility.").describe("Determines whether client should exit if the protocol version is not supported\nfor the next or next next epoch."), "resharding_config": z.string(), "rpc_addr": z.union([z.string().describe("Listening rpc port for status."), z.null().describe("Listening rpc port for status.")]).describe("Listening rpc port for status.").optional(), "save_invalid_witnesses": z.boolean().describe("Save observed instances of invalid ChunkStateWitness to the database in DBCol::InvalidChunkStateWitnesses.\nSaving invalid witnesses is useful for analysis and debugging.\nThis option can cause extra load on the database and is not recommended for production use."), "save_latest_witnesses": z.boolean().describe("Save observed instances of ChunkStateWitness to the database in DBCol::LatestChunkStateWitnesses.\nSaving the latest witnesses is useful for analysis and debugging.\nThis option can cause extra load on the database and is not recommended for production use."), "save_trie_changes": z.boolean().describe("save_trie_changes should be set to true iff\n- archive if false - non-archival nodes need trie changes to perform garbage collection\n- archive is true, cold_store is configured and migration to split_storage is finished - node\nworking in split storage mode needs trie changes in order to do garbage collection on hot."), "save_tx_outcomes": z.boolean().describe("Whether to persist transaction outcomes to disk or not."), "save_untracked_partial_chunks_parts": z.boolean().describe("Whether to persist partial chunk parts for untracked shards or not."), "skip_sync_wait": z.boolean().describe("Skip waiting for sync (for testing or single node testnet)."), "state_request_server_threads": z.number().int().gte(0).describe("Number of threads for StateRequestActor pool."), "state_request_throttle_period": z.array(z.number().int().gte(0)).min(2).max(2).describe("Number of seconds between state requests for view client.\nThrottling window for state requests (headers and parts)."), "state_requests_per_throttle_period": z.number().int().gte(0).describe("Maximum number of state requests served per throttle period"), "state_sync": z.object({ "concurrency": z.object({ "apply": z.number().int().gte(0).lte(255).describe("Maximum number of \"apply parts\" tasks that can be performed in parallel.\nThis is a very disk-heavy task and therefore we set this to a low limit,\nor else the rocksdb contention makes the whole server freeze up."), "apply_during_catchup": z.number().int().gte(0).lte(255).describe("Maximum number of \"apply parts\" tasks that can be performed in parallel\nduring catchup. We set this to a very low value to avoid overloading the\nnode while it is still performing normal tasks."), "peer_downloads": z.number().int().gte(0).lte(255).describe("Maximum number of outstanding requests for decentralized state sync."), "per_shard": z.number().int().gte(0).lte(255).describe("The maximum parallelism to use per shard. This is mostly for fairness, because\nthe actual rate limiting is done by the TaskTrackers, but this is useful for\nbalancing the shards a little.") }).optional(), "dump": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "credentials_file": z.union([z.string().describe("Location of a json file with credentials allowing access to the bucket."), z.null().describe("Location of a json file with credentials allowing access to the bucket.")]).describe("Location of a json file with credentials allowing access to the bucket.").optional(), "iteration_delay": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "nanos": z.number().int(), "secs": z.number().int() }), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("How often to check if a new epoch has started.\nFeel free to set to `None`, defaults are sensible.").optional(), "location": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "S3": z.object({ "bucket": z.string().describe("Location on S3."), "region": z.string().describe("Data may only be available in certain locations.") }) }).strict(), z.object({ "Filesystem": z.object({ "root_dir": z.string() }) }).strict().describe("Local filesystem root for storing data."), z.object({ "GCS": z.object({ "bucket": z.string() }) }).strict().describe("Google Cloud Storage bucket name.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Supported external storage backends and their minimal config.").describe("Specifies where to write the obtained state parts."), "restart_dump_for_shards": z.union([z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")).describe("Use in case a node that dumps state to the external storage\ngets in trouble."), z.null().describe("Use in case a node that dumps state to the external storage\ngets in trouble.")]).describe("Use in case a node that dumps state to the external storage\ngets in trouble.").optional() }).describe("Configures how to dump state to external storage."), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("`none` value disables state dump to external storage.").optional(), "parts_compression_lvl": z.number().int().describe("Zstd compression level for state parts.").default(1), "sync": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Peers").describe("Syncs state from the peers without reading anything from external storage."), z.object({ "ExternalStorage": z.object({ "external_storage_fallback_threshold": z.number().int().gte(0).describe("The number of attempts the node will make to obtain a part from peers in\nthe network before it fetches from external storage.").default(3), "location": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "S3": z.object({ "bucket": z.string().describe("Location on S3."), "region": z.string().describe("Data may only be available in certain locations.") }) }).strict(), z.object({ "Filesystem": z.object({ "root_dir": z.string() }) }).strict().describe("Local filesystem root for storing data."), z.object({ "GCS": z.object({ "bucket": z.string() }) }).strict().describe("Google Cloud Storage bucket name.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Supported external storage backends and their minimal config.").describe("Location of state parts."), "num_concurrent_requests": z.number().int().gte(0).lte(255).describe("When fetching state parts from external storage, throttle fetch requests\nto this many concurrent requests.").default(25), "num_concurrent_requests_during_catchup": z.number().int().gte(0).lte(255).describe("During catchup, the node will use a different number of concurrent requests\nto reduce the performance impact of state sync.").default(5) }) }).strict().describe("Expects parts to be available in external storage.\n\nUsually as a fallback after some number of attempts to use peers.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Configures how to fetch state parts during state sync.").optional() }).describe("Options for syncing state."), "state_sync_enabled": z.boolean().describe("Whether to use the State Sync mechanism.\nIf disabled, the node will do Block Sync instead of State Sync."), "state_sync_external_backoff": z.array(z.number().int().gte(0)).min(2).max(2).describe("Additional waiting period after a failed request to external storage"), "state_sync_external_timeout": z.array(z.number().int().gte(0)).min(2).max(2).describe("How long to wait for a response from centralized state sync"), "state_sync_p2p_timeout": z.array(z.number().int().gte(0)).min(2).max(2).describe("How long to wait for a response from p2p state sync"), "state_sync_retry_backoff": z.array(z.number().int().gte(0)).min(2).max(2).describe("How long to wait after a failed state sync request"), "sync_check_period": z.array(z.number().int().gte(0)).min(2).max(2).describe("How often to check that we are not out of sync."), "sync_height_threshold": z.number().int().gte(0).describe("Sync height threshold: below this difference in height don't start syncing."), "sync_max_block_requests": z.number().int().gte(0).describe("Maximum number of block requests to send to peers to sync"), "sync_step_period": z.array(z.number().int().gte(0)).min(2).max(2).describe("While syncing, how long to check for each step."), "tracked_shards_config": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("NoShards").describe("Tracks no shards (light client)."), z.object({ "Shards": z.array(z.object({ "shard_id": z.number().int().gte(0), "version": z.number().int().gte(0) }).describe("`ShardUId` is a unique representation for shards from different shard layouts.\n\nComparing to `ShardId`, which is just an ordinal number ranging from 0 to NUM_SHARDS-1,\n`ShardUId` provides a way to unique identify shards when shard layouts may change across epochs.\nThis is important because we store states indexed by shards in our database, so we need a\nway to unique identify shard even when shards change across epochs.\nAnother difference between `ShardUId` and `ShardId` is that `ShardUId` should only exist in\na node's internal state while `ShardId` can be exposed to outside APIs and used in protocol\nlevel information (for example, `ShardChunkHeader` contains `ShardId` instead of `ShardUId`)")) }).strict().describe("Tracks arbitrary shards."), z.literal("AllShards").describe("Tracks all shards."), z.object({ "ShadowValidator": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict().describe("Tracks shards that are assigned to given validator account."), z.object({ "Schedule": z.array(z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias."))) }).strict().describe("Rotate between these sets of tracked shards.\nUsed to simulate the behavior of chunk only producers without staking tokens."), z.object({ "Accounts": z.array(z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```")) }).strict().describe("Tracks shards that contain one of the given account.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the expected behavior of the node regarding shard tracking.\nIf the node is an active validator, it will also track the shards it is responsible for as a validator."), "transaction_pool_size_limit": z.union([z.number().int().gte(0).describe("Limit of the size of per-shard transaction pool measured in bytes. If not set, the size\nwill be unbounded."), z.null().describe("Limit of the size of per-shard transaction pool measured in bytes. If not set, the size\nwill be unbounded.")]).describe("Limit of the size of per-shard transaction pool measured in bytes. If not set, the size\nwill be unbounded.").optional(), "transaction_request_handler_threads": z.number().int().gte(0), "trie_viewer_state_size_limit": z.union([z.number().int().gte(0).describe("Upper bound of the byte size of contract state that is still viewable. None is no limit"), z.null().describe("Upper bound of the byte size of contract state that is still viewable. None is no limit")]).describe("Upper bound of the byte size of contract state that is still viewable. None is no limit").optional(), "ttl_account_id_router": z.array(z.number().int().gte(0)).min(2).max(2).describe("Time to persist Accounts Id in the router without removing them."), "tx_routing_height_horizon": z.number().int().gte(0).describe("If the node is not a chunk producer within that many blocks, then route\nto upcoming chunk producers."), "version": z.object({ "build": z.string(), "commit": z.string(), "rustc_version": z.string().default(""), "version": z.string() }).describe("Data structure for semver version and github tag or commit.").describe("Version of the binary."), "view_client_threads": z.number().int().gte(0).describe("Number of threads for ViewClientActor pool.") }).describe("ClientConfig where some fields can be updated at runtime.")
export type RpcClientConfigResponse = z.infer<typeof RpcClientConfigResponse>


export const RpcCongestionLevelRequest = z.record(z.any()).and(z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "block_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.number().int().gte(0), z.string()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "shard_id": z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.") }), z.object({ "chunk_id": z.string() })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }))
export type RpcCongestionLevelRequest = z.infer<typeof RpcCongestionLevelRequest>


export const RpcCongestionLevelResponse = z.object({ "congestion_level": z.number() })
export type RpcCongestionLevelResponse = z.infer<typeof RpcCongestionLevelResponse>


export const RpcGasPriceRequest = z.object({ "block_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.any().superRefine((x, ctx) => {
    const schemas = [z.number().int().gte(0), z.string()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional() })
export type RpcGasPriceRequest = z.infer<typeof RpcGasPriceRequest>


export const RpcGasPriceResponse = z.object({ "gas_price": z.string() })
export type RpcGasPriceResponse = z.infer<typeof RpcGasPriceResponse>


export const RpcHealthRequest = z.record(z.any())
export type RpcHealthRequest = z.infer<typeof RpcHealthRequest>


export const RpcHealthResponse = z.null()
export type RpcHealthResponse = z.infer<typeof RpcHealthResponse>


export const RpcKnownProducer = z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "addr": z.union([z.string(), z.null()]).optional(), "peer_id": z.string().describe("Peer id is the public key.") })
export type RpcKnownProducer = z.infer<typeof RpcKnownProducer>


export const RpcLightClientBlockProofRequest = z.object({ "block_hash": z.string(), "light_client_head": z.string() })
export type RpcLightClientBlockProofRequest = z.infer<typeof RpcLightClientBlockProofRequest>


export const RpcLightClientBlockProofResponse = z.object({ "block_header_lite": z.object({ "inner_lite": z.object({ "block_merkle_root": z.string().describe("The merkle root of all the block hashes"), "epoch_id": z.string().describe("The epoch to which the block that is the current known head belongs"), "height": z.number().int().gte(0), "next_bp_hash": z.string().describe("The hash of the block producers set for the next epoch"), "next_epoch_id": z.string().describe("The epoch that will follow the current epoch"), "outcome_root": z.string(), "prev_state_root": z.string(), "timestamp": z.number().int().gte(0).describe("Legacy json number. Should not be used."), "timestamp_nanosec": z.string() }).describe("A part of a state for the current head of a light client. More info [here](https://nomicon.io/ChainSpec/LightClient)."), "inner_rest_hash": z.string(), "prev_block_hash": z.string() }), "block_proof": z.array(z.object({ "direction": z.enum(["Left","Right"]), "hash": z.string() })) })
export type RpcLightClientBlockProofResponse = z.infer<typeof RpcLightClientBlockProofResponse>


export const RpcLightClientExecutionProofRequest = z.record(z.any()).and(z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "light_client_head": z.string(), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "transaction_hash": z.string(), "type": z.literal("transaction") }), z.object({ "light_client_head": z.string(), "receipt_id": z.string(), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "type": z.literal("receipt") })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }))
export type RpcLightClientExecutionProofRequest = z.infer<typeof RpcLightClientExecutionProofRequest>


export const RpcLightClientExecutionProofResponse = z.object({ "block_header_lite": z.object({ "inner_lite": z.object({ "block_merkle_root": z.string().describe("The merkle root of all the block hashes"), "epoch_id": z.string().describe("The epoch to which the block that is the current known head belongs"), "height": z.number().int().gte(0), "next_bp_hash": z.string().describe("The hash of the block producers set for the next epoch"), "next_epoch_id": z.string().describe("The epoch that will follow the current epoch"), "outcome_root": z.string(), "prev_state_root": z.string(), "timestamp": z.number().int().gte(0).describe("Legacy json number. Should not be used."), "timestamp_nanosec": z.string() }).describe("A part of a state for the current head of a light client. More info [here](https://nomicon.io/ChainSpec/LightClient)."), "inner_rest_hash": z.string(), "prev_block_hash": z.string() }), "block_proof": z.array(z.object({ "direction": z.enum(["Left","Right"]), "hash": z.string() })), "outcome_proof": z.object({ "block_hash": z.string(), "id": z.string(), "outcome": z.object({ "executor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("The id of the account on which the execution happens. For transaction this is signer_id,\nfor receipt this is receiver_id."), "gas_burnt": z.number().int().gte(0).describe("The amount of the gas burnt by the given transaction or receipt."), "logs": z.array(z.string()).describe("Logs from this transaction or receipt."), "metadata": z.object({ "gas_profile": z.union([z.array(z.object({ "cost": z.string(), "cost_category": z.string().describe("Either ACTION_COST or WASM_HOST_COST."), "gas_used": z.string() }).describe("Shows gas profile. More info [here](https://near.github.io/nearcore/architecture/gas/gas_profile.html?highlight=WASM_HOST_COST#example-transaction-gas-profile).")), z.null()]).optional(), "version": z.number().int().gte(0) }).describe("Execution metadata, versioned").default({"gas_profile":null,"version":1}), "receipt_ids": z.array(z.string()).describe("Receipt IDs generated by this transaction or receipt."), "status": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unknown").describe("The execution is pending or unknown."), z.object({ "Failure": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "ActionError": z.object({ "index": z.union([z.number().int().gte(0).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`"), z.null().describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`")]).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`").optional(), "kind": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccountAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage"), z.object({ "AccountDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when TX receiver_id doesn't exist (but action is not Action::CreateAccount)"), z.object({ "CreateAccountOnlyByRegistrar": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "registrar_account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A top-level account ID can only be created by registrar."), z.object({ "CreateAccountNotAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A newly created account must be under a namespace of the creator account"), z.object({ "ActorNoPermission": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "actor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\nor the first TX action is a `CreateAccount` action"), z.object({ "DeleteKeyDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("Account tries to remove an access key that doesn't exist"), z.object({ "AddKeyAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The public key is already used for an existing access key"), z.object({ "DeleteAccountStaking": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is staking and can not be deleted"), z.object({ "LackBalanceForState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which needs balance"), "amount": z.string().describe("Balance required to complete an action.") }) }).strict().describe("ActionReceipt can't be completed, because the remaining balance will not be enough to cover storage."), z.object({ "TriesToUnstake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is not yet staked, but tries to unstake"), z.object({ "TriesToStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "balance": z.string(), "locked": z.string(), "stake": z.string() }) }).strict().describe("The account doesn't have enough balance to increase the stake."), z.object({ "InsufficientStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "minimum_stake": z.string(), "stake": z.string() }) }).strict(), z.object({ "FunctionCallError": z.any().superRefine((x, ctx) => {
    const schemas = [z.enum(["WasmUnknownError","_EVMError"]), z.object({ "CompilationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "PrepareError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Serialization").describe("Error happened while serializing the module."), z.literal("Deserialization").describe("Error happened while deserializing the module."), z.literal("InternalMemoryDeclared").describe("Internal memory declaration has been found in the module."), z.literal("GasInstrumentation").describe("Gas instrumentation failed.\n\nThis most likely indicates the module isn't valid."), z.literal("StackHeightInstrumentation").describe("Stack instrumentation failed.\n\nThis  most likely indicates the module isn't valid."), z.literal("Instantiate").describe("Error happened during instantiation.\n\nThis might indicate that `start` function trapped, or module isn't\ninstantiable and/or un-linkable."), z.literal("Memory").describe("Error creating memory."), z.literal("TooManyFunctions").describe("Contract contains too many functions."), z.literal("TooManyLocals").describe("Contract contains too many locals."), z.literal("TooManyTables").describe("Contract contains too many tables."), z.literal("TooManyTableElements").describe("Contract contains too many table elements.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error that can occur while preparing or executing Wasm smart-contract.") }).strict(), z.object({ "WasmerCompileError": z.object({ "msg": z.string() }) }).strict().describe("This is for defense in depth.\nWe expect our runtime-independent preparation code to fully catch all invalid wasms,\nbut, if it ever misses something we’ll emit this error")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Wasm compilation error"), z.object({ "LinkError": z.object({ "msg": z.string() }) }).strict().describe("Wasm binary env link error\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "MethodResolveError": z.enum(["MethodEmptyName","MethodNotFound","MethodInvalidSignature"]) }).strict().describe("Import/export resolve error"), z.object({ "WasmTrap": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unreachable").describe("An `unreachable` opcode was executed."), z.literal("IncorrectCallIndirectSignature").describe("Call indirect incorrect signature trap."), z.literal("MemoryOutOfBounds").describe("Memory out of bounds trap."), z.literal("CallIndirectOOB").describe("Call indirect out of bounds trap."), z.literal("IllegalArithmetic").describe("An arithmetic exception, e.g. divided by zero."), z.literal("MisalignedAtomicAccess").describe("Misaligned atomic access trap."), z.literal("IndirectCallToNull").describe("Indirect call to null."), z.literal("StackOverflow").describe("Stack overflow."), z.literal("GenericTrap").describe("Generic trap.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("A kind of a trap happened during execution of a binary") }).strict().describe("A trap happened during execution of a binary\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "HostError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("BadUTF16").describe("String encoding is bad UTF-16 sequence"), z.literal("BadUTF8").describe("String encoding is bad UTF-8 sequence"), z.literal("GasExceeded").describe("Exceeded the prepaid gas"), z.literal("GasLimitExceeded").describe("Exceeded the maximum amount of gas allowed to burn per contract"), z.literal("BalanceExceeded").describe("Exceeded the account balance"), z.literal("EmptyMethodName").describe("Tried to call an empty method name"), z.object({ "GuestPanic": z.object({ "panic_msg": z.string() }) }).strict().describe("Smart contract panicked"), z.literal("IntegerOverflow").describe("IntegerOverflow happened during a contract execution"), z.object({ "InvalidPromiseIndex": z.object({ "promise_idx": z.number().int().gte(0) }) }).strict().describe("`promise_idx` does not correspond to existing promises"), z.literal("CannotAppendActionToJointPromise").describe("Actions can only be appended to non-joint promise."), z.literal("CannotReturnJointPromise").describe("Returning joint promise is currently prohibited"), z.object({ "InvalidPromiseResultIndex": z.object({ "result_idx": z.number().int().gte(0) }) }).strict().describe("Accessed invalid promise result index"), z.object({ "InvalidRegisterId": z.object({ "register_id": z.number().int().gte(0) }) }).strict().describe("Accessed invalid register id"), z.object({ "IteratorWasInvalidated": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie"), z.literal("MemoryAccessViolation").describe("Accessed memory outside the bounds"), z.object({ "InvalidReceiptIndex": z.object({ "receipt_index": z.number().int().gte(0) }) }).strict().describe("VM Logic returned an invalid receipt index"), z.object({ "InvalidIteratorIndex": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator index `iterator_index` does not exist"), z.literal("InvalidAccountId").describe("VM Logic returned an invalid account id"), z.literal("InvalidMethodName").describe("VM Logic returned an invalid method name"), z.literal("InvalidPublicKey").describe("VM Logic provided an invalid public key"), z.object({ "ProhibitedInView": z.object({ "method_name": z.string() }) }).strict().describe("`method_name` is not allowed in view calls"), z.object({ "NumberOfLogsExceeded": z.object({ "limit": z.number().int().gte(0) }) }).strict().describe("The total number of logs will exceed the limit."), z.object({ "KeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage key length exceeded the limit."), z.object({ "ValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage value length exceeded the limit."), z.object({ "TotalLogLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The total log length exceeded the limit."), z.object({ "NumberPromisesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_promises": z.number().int().gte(0) }) }).strict().describe("The maximum number of promises within a FunctionCall exceeded the limit."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The maximum number of input data dependencies exceeded the limit."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The returned value length exceeded the limit."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The contract size for DeployContract action exceeded the limit."), z.object({ "Deprecated": z.object({ "method_name": z.string() }) }).strict().describe("The host function was deprecated."), z.object({ "ECRecoverError": z.object({ "msg": z.string() }) }).strict().describe("General errors for ECDSA recover."), z.object({ "AltBn128InvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to alt_bn128 family of functions (e.g., point which isn't\non the curve)."), z.object({ "Ed25519VerifyInvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to ed25519 signature verification function (e.g. signature cannot be\nderived from bytes).")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Note: this is only to deserialize old data, use execution error for new data"), z.object({ "ExecutionError": z.string() }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Serializable version of `near-vm-runner::FunctionCallError`.\n\nMust never reorder/remove elements, can only add new variants at the end (but do that very\ncarefully). It describes stable serialization format, and only used by serialization logic.") }).strict().describe("An error occurred during a `FunctionCall` Action, parameter is debug message."), z.object({ "NewReceiptValidationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidPredecessorId": z.object({ "account_id": z.string() }) }).strict().describe("The `predecessor_id` of a Receipt is not valid."), z.object({ "InvalidReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a Receipt is not valid."), z.object({ "InvalidSignerId": z.object({ "account_id": z.string() }) }).strict().describe("The `signer_id` of an ActionReceipt is not valid."), z.object({ "InvalidDataReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a DataReceiver within an ActionReceipt is not valid."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the returned data exceeded the limit in a DataReceipt."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The number of input data dependencies exceeds the limit in an ActionReceipt."), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of an ActionReceipt."), z.object({ "ReceiptSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("Receipt is bigger than the limit."), z.object({ "InvalidRefundTo": z.object({ "account_id": z.string() }) }).strict().describe("The `refund_to` of an ActionReceipt is not valid.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a receipt.") }).strict().describe("Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\nreceipt validation."), z.object({ "OnlyImplicitAccountCreationAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\nSee NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\nAlso, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\nTODO(#8598): This error is named very poorly. A better name would be\n`OnlyNamedAccountCreationAllowed`."), z.object({ "DeleteAccountWithLargeState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Delete account whose state is large is temporarily banned."), z.literal("DelegateActionInvalidSignature").describe("Signature does not match the provided actions and given signer public key."), z.object({ "DelegateActionSenderDoesNotMatchTxReceiver": z.object({ "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Receiver of the transaction doesn't match Sender of the delegate action"), z.literal("DelegateActionExpired").describe("Delegate action has expired. `max_block_height` is less than actual block height."), z.object({ "DelegateActionAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("The given public key doesn't exist for Sender account"), z.object({ "DelegateActionInvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "delegate_nonce": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce must be greater sender[public_key].nonce"), z.object({ "DelegateActionNonceTooLarge": z.object({ "delegate_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce is larger than the upper bound given by the block height"), z.object({ "GlobalContractDoesNotExist": z.object({ "identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("The kind of ActionError happened") }).describe("An error happened during Action execution") }).strict().describe("An error happened during Action execution"), z.object({ "InvalidTxError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Happens if a wrong AccessKey used or AccessKey has not enough permissions"), z.object({ "InvalidSignerId": z.object({ "signer_id": z.string() }) }).strict().describe("TX signer_id is not a valid [`AccountId`]"), z.object({ "SignerDoesNotExist": z.object({ "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("TX signer_id is not found in a storage"), z.object({ "InvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "tx_nonce": z.number().int().gte(0) }) }).strict().describe("Transaction nonce must be strictly greater than `account[access_key].nonce`."), z.object({ "NonceTooLarge": z.object({ "tx_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("Transaction nonce is larger than the upper bound given by the block height"), z.object({ "InvalidReceiverId": z.object({ "receiver_id": z.string() }) }).strict().describe("TX receiver_id is not a valid AccountId"), z.literal("InvalidSignature").describe("TX signature is not valid"), z.object({ "NotEnoughBalance": z.object({ "balance": z.string(), "cost": z.string(), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account does not have enough balance to cover TX cost"), z.object({ "LackBalanceForState": z.object({ "amount": z.string().describe("Required balance to cover the state."), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which doesn't have enough balance to cover storage.") }) }).strict().describe("Signer account doesn't have enough balance after transaction."), z.literal("CostOverflow").describe("An integer overflow occurred during transaction cost estimation."), z.literal("InvalidChain").describe("Transaction parent block hash doesn't belong to the current chain"), z.literal("Expired").describe("Transaction has expired"), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of a Transaction."), z.object({ "TransactionSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of serialized transaction exceeded the limit."), z.literal("InvalidTransactionVersion").describe("Transaction version is invalid."), z.object({ "StorageError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("StorageInternalError").describe("Key-value db internal failure"), z.object({ "MissingTrieValue": z.object({ "context": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("TrieIterator").describe("Missing trie value when reading from TrieIterator."), z.literal("TriePrefetchingStorage").describe("Missing trie value when reading from TriePrefetchingStorage."), z.literal("TrieMemoryPartialStorage").describe("Missing trie value when reading from TrieMemoryPartialStorage."), z.literal("TrieStorage").describe("Missing trie value when reading from TrieStorage.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Contexts in which `StorageError::MissingTrieValue` error might occur."), "hash": z.string() }) }).strict().describe("Requested trie value by its hash which is missing in storage."), z.literal("UnexpectedTrieValue").describe("Found trie node which shouldn't be part of state. Raised during\nvalidation of state sync parts where incorrect node was passed.\nTODO (#8997): consider including hash of trie node."), z.object({ "StorageInconsistentState": z.string() }).strict().describe("Either invalid state or key-value db is corrupted.\nFor PartialStorage it cannot be corrupted.\nError message is unreliable and for debugging purposes only. It's also probably ok to\npanic in every place that produces this error.\nWe can check if db is corrupted by verifying everything in the state trie."), z.object({ "FlatStorageBlockNotSupported": z.string() }).strict().describe("Flat storage error, meaning that it doesn't support some block anymore.\nWe guarantee that such block cannot become final, thus block processing\nmust resume normally."), z.object({ "MemTrieLoadingError": z.string() }).strict().describe("In-memory trie could not be loaded for some reason.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Errors which may occur during working with trie storages, storing\ntrie values (trie nodes and state values) by their hashes.") }).strict(), z.object({ "ShardCongested": z.object({ "congestion_level": z.number().describe("A value between 0 (no congestion) and 1 (max congestion)."), "shard_id": z.number().int().gte(0).describe("The congested shard.") }) }).strict().describe("The receiver shard of the transaction is too congested to accept new\ntransactions at the moment."), z.object({ "ShardStuck": z.object({ "missed_chunks": z.number().int().gte(0).describe("The number of blocks since the last included chunk of the shard."), "shard_id": z.number().int().gte(0).describe("The shard that fails making progress.") }) }).strict().describe("The receiver shard of the transaction missed several chunks and rejects\nnew transaction until it can make progress again.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An error happened during TX execution") }).strict().describe("An error happened during Transaction execution")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error returned in the ExecutionOutcome in case of failure") }).strict().describe("The execution has failed."), z.object({ "SuccessValue": z.string() }).strict().describe("The final action succeeded and returned some value or an empty vec encoded in base64."), z.object({ "SuccessReceiptId": z.string() }).strict().describe("The final action of the receipt returned a promise or the signed transaction was converted\nto a receipt. Contains the receipt_id of the generated receipt.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Execution status. Contains the result in case of successful execution."), "tokens_burnt": z.string().describe("The amount of tokens burnt corresponding to the burnt gas amount.\nThis value doesn't always equal to the `gas_burnt` multiplied by the gas price, because\nthe prepaid gas price might be lower than the actual gas price and it creates a deficit.\n`tokens_burnt` also contains the penalty subtracted from refunds, while\n`gas_burnt` only contains the gas that we actually burn for the execution.") }), "proof": z.array(z.object({ "direction": z.enum(["Left","Right"]), "hash": z.string() })) }), "outcome_root_proof": z.array(z.object({ "direction": z.enum(["Left","Right"]), "hash": z.string() })) })
export type RpcLightClientExecutionProofResponse = z.infer<typeof RpcLightClientExecutionProofResponse>


export const RpcLightClientNextBlockRequest = z.object({ "last_block_hash": z.string() })
export type RpcLightClientNextBlockRequest = z.infer<typeof RpcLightClientNextBlockRequest>


export const RpcLightClientNextBlockResponse = z.object({ "approvals_after_next": z.array(z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })).optional(), "inner_lite": z.object({ "block_merkle_root": z.string().describe("The merkle root of all the block hashes"), "epoch_id": z.string().describe("The epoch to which the block that is the current known head belongs"), "height": z.number().int().gte(0), "next_bp_hash": z.string().describe("The hash of the block producers set for the next epoch"), "next_epoch_id": z.string().describe("The epoch that will follow the current epoch"), "outcome_root": z.string(), "prev_state_root": z.string(), "timestamp": z.number().int().gte(0).describe("Legacy json number. Should not be used."), "timestamp_nanosec": z.string() }).describe("A part of a state for the current head of a light client. More info [here](https://nomicon.io/ChainSpec/LightClient).").describe("Inner part of the block header that gets hashed, split into two parts, one that is sent\n   to light clients, and the rest").optional(), "inner_rest_hash": z.string().optional(), "next_block_inner_hash": z.string().optional(), "next_bps": z.union([z.array(z.object({ "validator_stake_struct_version": z.literal("V1") }).and(z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string(), "stake": z.string() }))), z.null()]).optional(), "prev_block_hash": z.string().optional() }).describe("A state for the current head of a light client. More info [here](https://nomicon.io/ChainSpec/LightClient).")
export type RpcLightClientNextBlockResponse = z.infer<typeof RpcLightClientNextBlockResponse>


export const RpcMaintenanceWindowsRequest = z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") })
export type RpcMaintenanceWindowsRequest = z.infer<typeof RpcMaintenanceWindowsRequest>


export const RpcNetworkInfoRequest = z.record(z.any())
export type RpcNetworkInfoRequest = z.infer<typeof RpcNetworkInfoRequest>


export const RpcNetworkInfoResponse = z.object({ "active_peers": z.array(z.object({ "account_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "addr": z.union([z.string(), z.null()]).optional(), "id": z.string().describe("Peer id is the public key.") })), "known_producers": z.array(z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "addr": z.union([z.string(), z.null()]).optional(), "peer_id": z.string().describe("Peer id is the public key.") })).describe("Accounts of known block and chunk producers from routing table."), "num_active_peers": z.number().int().gte(0), "peer_max_count": z.number().int().gte(0), "received_bytes_per_sec": z.number().int().gte(0), "sent_bytes_per_sec": z.number().int().gte(0) })
export type RpcNetworkInfoResponse = z.infer<typeof RpcNetworkInfoResponse>


export const RpcPeerInfo = z.object({ "account_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "addr": z.union([z.string(), z.null()]).optional(), "id": z.string().describe("Peer id is the public key.") })
export type RpcPeerInfo = z.infer<typeof RpcPeerInfo>


export const RpcProtocolConfigRequest = z.record(z.any()).and(z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "block_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.number().int().gte(0), z.string()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }), z.object({ "finality": z.enum(["optimistic","near-final","final"]).describe("Different types of finality.") }), z.object({ "sync_checkpoint": z.enum(["genesis","earliest_available"]) })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }))
export type RpcProtocolConfigRequest = z.infer<typeof RpcProtocolConfigRequest>


export const RpcProtocolConfigResponse = z.object({ "avg_hidden_validator_seats_per_shard": z.array(z.number().int().gte(0)).describe("Expected number of hidden validators per shard."), "block_producer_kickout_threshold": z.number().int().gte(0).lte(255).describe("Threshold for kicking out block producers, between 0 and 100."), "chain_id": z.string().describe("ID of the blockchain. This must be unique for every blockchain.\nIf your testnet blockchains do not have unique chain IDs, you will have a bad time."), "chunk_producer_kickout_threshold": z.number().int().gte(0).lte(255).describe("Threshold for kicking out chunk producers, between 0 and 100."), "chunk_validator_only_kickout_threshold": z.number().int().gte(0).lte(255).describe("Threshold for kicking out nodes which are only chunk validators, between 0 and 100."), "dynamic_resharding": z.boolean().describe("Enable dynamic re-sharding."), "epoch_length": z.number().int().gte(0).describe("Epoch length counted in block heights."), "fishermen_threshold": z.string().describe("Fishermen stake threshold."), "gas_limit": z.number().int().gte(0).describe("Initial gas limit."), "gas_price_adjustment_rate": z.array(z.number().int()).min(2).max(2).describe("Gas price adjustment rate"), "genesis_height": z.number().int().gte(0).describe("Height of genesis block."), "genesis_time": z.string().datetime({ offset: true }).describe("Official time of blockchain start."), "max_gas_price": z.string().describe("Maximum gas price."), "max_inflation_rate": z.array(z.number().int()).min(2).max(2).describe("Maximum inflation on the total supply every epoch."), "max_kickout_stake_perc": z.number().int().gte(0).lte(255).describe("Max stake percentage of the validators we will kick out."), "min_gas_price": z.string().describe("Minimum gas price. It is also the initial gas price."), "minimum_stake_divisor": z.number().int().gte(0).describe("The minimum stake required for staking is last seat price divided by this number."), "minimum_stake_ratio": z.array(z.number().int()).min(2).max(2).describe("The lowest ratio s/s_total any block producer can have.\nSee <https://github.com/near/NEPs/pull/167> for details"), "minimum_validators_per_shard": z.number().int().gte(0).describe("The minimum number of validators each shard must have"), "num_block_producer_seats": z.number().int().gte(0).describe("Number of block producer seats at genesis."), "num_block_producer_seats_per_shard": z.array(z.number().int().gte(0)).describe("Defines number of shards and number of block producer seats per each shard at genesis."), "num_blocks_per_year": z.number().int().gte(0).describe("Expected number of blocks per year"), "online_max_threshold": z.array(z.number().int()).min(2).max(2).describe("Online maximum threshold above which validator gets full reward."), "online_min_threshold": z.array(z.number().int()).min(2).max(2).describe("Online minimum threshold below which validator doesn't receive reward."), "protocol_reward_rate": z.array(z.number().int()).min(2).max(2).describe("Protocol treasury rate"), "protocol_treasury_account": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("Protocol treasury account"), "protocol_upgrade_stake_threshold": z.array(z.number().int()).min(2).max(2).describe("Threshold of stake that needs to indicate that they ready for upgrade."), "protocol_version": z.number().int().gte(0).describe("Current Protocol Version"), "runtime_config": z.object({ "account_creation_config": z.object({ "min_allowed_top_level_account_length": z.number().int().gte(0).lte(255).describe("The minimum length of the top-level account ID that is allowed to be created by any account."), "registrar_account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("The account ID of the account registrar. This account ID allowed to create top-level\naccounts of any valid length.") }).describe("The structure describes configuration for creation of new accounts.").describe("Config that defines rules for account creation."), "congestion_control_config": z.object({ "allowed_shard_outgoing_gas": z.number().int().gte(0).describe("How much gas the chosen allowed shard can send to a 100% congested shard.\n\nSee [`CongestionControlConfig`] for more details."), "max_congestion_incoming_gas": z.number().int().gte(0).describe("How much gas in delayed receipts of a shard is 100% incoming congestion.\n\nSee [`CongestionControlConfig`] for more details."), "max_congestion_memory_consumption": z.number().int().gte(0).describe("How much memory space of all delayed and buffered receipts in a shard is\nconsidered 100% congested.\n\nSee [`CongestionControlConfig`] for more details."), "max_congestion_missed_chunks": z.number().int().gte(0).describe("How many missed chunks in a row in a shard is considered 100% congested."), "max_congestion_outgoing_gas": z.number().int().gte(0).describe("How much gas in outgoing buffered receipts of a shard is 100% congested.\n\nOutgoing congestion contributes to overall congestion, which reduces how\nmuch other shards are allowed to forward to this shard."), "max_outgoing_gas": z.number().int().gte(0).describe("The maximum amount of gas attached to receipts a shard can forward to\nanother shard per chunk.\n\nSee [`CongestionControlConfig`] for more details."), "max_tx_gas": z.number().int().gte(0).describe("The maximum amount of gas in a chunk spent on converting new transactions to\nreceipts.\n\nSee [`CongestionControlConfig`] for more details."), "min_outgoing_gas": z.number().int().gte(0).describe("The minimum gas each shard can send to a shard that is not fully congested.\n\nSee [`CongestionControlConfig`] for more details."), "min_tx_gas": z.number().int().gte(0).describe("The minimum amount of gas in a chunk spent on converting new transactions\nto receipts, as long as the receiving shard is not congested.\n\nSee [`CongestionControlConfig`] for more details."), "outgoing_receipts_big_size_limit": z.number().int().gte(0).describe("Large size limit for outgoing receipts to a shard, used when it's safe\nto send a lot of receipts without making the state witness too large.\nIt limits the total sum of outgoing receipts, not individual receipts."), "outgoing_receipts_usual_size_limit": z.number().int().gte(0).describe("The standard size limit for outgoing receipts aimed at a single shard.\nThis limit is pretty small to keep the size of source_receipt_proofs under control.\nIt limits the total sum of outgoing receipts, not individual receipts."), "reject_tx_congestion_threshold": z.number().describe("How much congestion a shard can tolerate before it stops all shards from\naccepting new transactions with the receiver set to the congested shard.") }).describe("The configuration for congestion control. More info about congestion [here](https://near.github.io/nearcore/architecture/how/receipt-congestion.html?highlight=congestion#receipt-congestion)").describe("The configuration for congestion control."), "storage_amount_per_byte": z.string().describe("Amount of yN per byte required to have on the account.  See\n<https://nomicon.io/Economics/Economic#state-stake> for details."), "transaction_costs": z.object({ "action_creation_config": z.object({ "add_key_cost": z.object({ "full_access_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of creating a full access access-key."), "function_call_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of creating an access-key restricted to specific functions."), "function_call_cost_per_byte": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Cost per byte of method_names of creating a restricted access-key.") }).describe("Describes the cost of creating an access key.").describe("Base cost of adding a key."), "create_account_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of creating an account."), "delegate_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost for processing a delegate action.\n\nThis is on top of the costs for the actions inside the delegate action."), "delete_account_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of deleting an account."), "delete_key_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of deleting a key."), "deploy_contract_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of deploying a contract."), "deploy_contract_cost_per_byte": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Cost per byte of deploying a contract."), "function_call_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of calling a function."), "function_call_cost_per_byte": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Cost per byte of method name and arguments of calling a function."), "stake_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of staking."), "transfer_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of making a transfer.") }).describe("Describes the cost of creating a specific action, `Action`. Includes all variants.").describe("Describes the cost of creating a certain action, `Action`. Includes all variants."), "action_receipt_creation_config": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Describes the cost of creating an action receipt, `ActionReceipt`, excluding the actual cost\nof actions.\n- `send` cost is burned when a receipt is created using `promise_create` or\n    `promise_batch_create`\n- `exec` cost is burned when the receipt is being executed."), "burnt_gas_reward": z.array(z.number().int()).min(2).max(2).describe("Fraction of the burnt gas to reward to the contract account for execution."), "data_receipt_creation_config": z.object({ "base_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of creating a data receipt.\nBoth `send` and `exec` costs are burned when a new receipt has input dependencies. The gas\nis charged for each input dependency. The dependencies are specified when a receipt is\ncreated using `promise_then` and `promise_batch_then`.\nNOTE: Any receipt with output dependencies will produce data receipts. Even if it fails.\nEven if the last action is not a function call (in case of success it will return empty\nvalue)."), "cost_per_byte": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Additional cost per byte sent.\nBoth `send` and `exec` costs are burned when a function call finishes execution and returns\n`N` bytes of data to every output dependency. For each output dependency the cost is\n`(send(sir) + exec()) * N`.") }).describe("The fees settings for a data receipt creation").describe("Describes the cost of creating a data receipt, `DataReceipt`."), "pessimistic_gas_price_inflation_ratio": z.array(z.number().int()).min(2).max(2).describe("Pessimistic gas price inflation ratio."), "storage_usage_config": z.object({ "num_bytes_account": z.number().int().gte(0).describe("Number of bytes for an account record, including rounding up for account id."), "num_extra_bytes_record": z.number().int().gte(0).describe("Additional number of bytes for a k/v record") }).describe("Describes cost of storage per block").describe("Describes fees for storage.") }).describe("Describes different fees for the runtime").describe("Costs of different actions that need to be performed when sending and\nprocessing transaction and receipts."), "wasm_config": z.object({ "deterministic_account_ids": z.boolean().describe("See [VMConfig::deterministic_account_ids](crate::vm::Config::deterministic_account_ids)."), "discard_custom_sections": z.boolean().describe("See [VMConfig::discard_custom_sections](crate::vm::Config::discard_custom_sections)."), "eth_implicit_accounts": z.boolean().describe("See [VMConfig::eth_implicit_accounts](crate::vm::Config::eth_implicit_accounts)."), "ext_costs": z.object({ "alt_bn128_g1_multiexp_base": z.number().int().gte(0).describe("Base cost for multiexp"), "alt_bn128_g1_multiexp_element": z.number().int().gte(0).describe("Per element cost for multiexp"), "alt_bn128_g1_sum_base": z.number().int().gte(0).describe("Base cost for sum"), "alt_bn128_g1_sum_element": z.number().int().gte(0).describe("Per element cost for sum"), "alt_bn128_pairing_check_base": z.number().int().gte(0).describe("Base cost for pairing check"), "alt_bn128_pairing_check_element": z.number().int().gte(0).describe("Per element cost for pairing check"), "base": z.number().int().gte(0).describe("Base cost for calling a host function."), "bls12381_g1_multiexp_base": z.number().int().gte(0), "bls12381_g1_multiexp_element": z.number().int().gte(0), "bls12381_g2_multiexp_base": z.number().int().gte(0), "bls12381_g2_multiexp_element": z.number().int().gte(0), "bls12381_map_fp2_to_g2_base": z.number().int().gte(0), "bls12381_map_fp2_to_g2_element": z.number().int().gte(0), "bls12381_map_fp_to_g1_base": z.number().int().gte(0), "bls12381_map_fp_to_g1_element": z.number().int().gte(0), "bls12381_p1_decompress_base": z.number().int().gte(0), "bls12381_p1_decompress_element": z.number().int().gte(0), "bls12381_p1_sum_base": z.number().int().gte(0), "bls12381_p1_sum_element": z.number().int().gte(0), "bls12381_p2_decompress_base": z.number().int().gte(0), "bls12381_p2_decompress_element": z.number().int().gte(0), "bls12381_p2_sum_base": z.number().int().gte(0), "bls12381_p2_sum_element": z.number().int().gte(0), "bls12381_pairing_base": z.number().int().gte(0), "bls12381_pairing_element": z.number().int().gte(0), "contract_compile_base": z.number().int().gte(0), "contract_compile_bytes": z.number().int().gte(0), "contract_loading_base": z.number().int().gte(0).describe("Base cost of loading a pre-compiled contract"), "contract_loading_bytes": z.number().int().gte(0).describe("Cost per byte of loading a pre-compiled contract"), "ecrecover_base": z.number().int().gte(0).describe("Cost of calling ecrecover"), "ed25519_verify_base": z.number().int().gte(0).describe("Cost of getting ed25519 base"), "ed25519_verify_byte": z.number().int().gte(0).describe("Cost of getting ed25519 per byte"), "keccak256_base": z.number().int().gte(0).describe("Cost of getting sha256 base"), "keccak256_byte": z.number().int().gte(0).describe("Cost of getting sha256 per byte"), "keccak512_base": z.number().int().gte(0).describe("Cost of getting sha256 base"), "keccak512_byte": z.number().int().gte(0).describe("Cost of getting sha256 per byte"), "log_base": z.number().int().gte(0).describe("Cost for calling logging."), "log_byte": z.number().int().gte(0).describe("Cost for logging per byte"), "promise_and_base": z.number().int().gte(0).describe("Cost for calling `promise_and`"), "promise_and_per_promise": z.number().int().gte(0).describe("Cost for calling `promise_and` for each promise"), "promise_return": z.number().int().gte(0).describe("Cost for calling `promise_return`"), "read_cached_trie_node": z.number().int().gte(0).describe("Cost for reading trie node from memory"), "read_memory_base": z.number().int().gte(0).describe("Base cost for guest memory read"), "read_memory_byte": z.number().int().gte(0).describe("Cost for guest memory read"), "read_register_base": z.number().int().gte(0).describe("Base cost for reading from register"), "read_register_byte": z.number().int().gte(0).describe("Cost for reading byte from register"), "ripemd160_base": z.number().int().gte(0).describe("Cost of getting ripemd160 base"), "ripemd160_block": z.number().int().gte(0).describe("Cost of getting ripemd160 per message block"), "sha256_base": z.number().int().gte(0).describe("Cost of getting sha256 base"), "sha256_byte": z.number().int().gte(0).describe("Cost of getting sha256 per byte"), "storage_has_key_base": z.number().int().gte(0).describe("Storage trie check for key existence cost base"), "storage_has_key_byte": z.number().int().gte(0).describe("Storage trie check for key existence per key byte"), "storage_iter_create_from_byte": z.number().int().gte(0).describe("Create trie range iterator cost per byte of from key."), "storage_iter_create_prefix_base": z.number().int().gte(0).describe("Create trie prefix iterator cost base"), "storage_iter_create_prefix_byte": z.number().int().gte(0).describe("Create trie prefix iterator cost per byte."), "storage_iter_create_range_base": z.number().int().gte(0).describe("Create trie range iterator cost base"), "storage_iter_create_to_byte": z.number().int().gte(0).describe("Create trie range iterator cost per byte of to key."), "storage_iter_next_base": z.number().int().gte(0).describe("Trie iterator per key base cost"), "storage_iter_next_key_byte": z.number().int().gte(0).describe("Trie iterator next key byte cost"), "storage_iter_next_value_byte": z.number().int().gte(0).describe("Trie iterator next key byte cost"), "storage_large_read_overhead_base": z.number().int().gte(0).describe("Storage trie read key overhead base cost, when doing large reads"), "storage_large_read_overhead_byte": z.number().int().gte(0).describe("Storage trie read key overhead  per-byte cost, when doing large reads"), "storage_read_base": z.number().int().gte(0).describe("Storage trie read key base cost"), "storage_read_key_byte": z.number().int().gte(0).describe("Storage trie read key per byte cost"), "storage_read_value_byte": z.number().int().gte(0).describe("Storage trie read value cost per byte cost"), "storage_remove_base": z.number().int().gte(0).describe("Remove key from trie base cost"), "storage_remove_key_byte": z.number().int().gte(0).describe("Remove key from trie per byte cost"), "storage_remove_ret_value_byte": z.number().int().gte(0).describe("Remove key from trie ret value byte cost"), "storage_write_base": z.number().int().gte(0).describe("Storage trie write key base cost"), "storage_write_evicted_byte": z.number().int().gte(0).describe("Storage trie write cost per byte of evicted value."), "storage_write_key_byte": z.number().int().gte(0).describe("Storage trie write key per byte cost"), "storage_write_value_byte": z.number().int().gte(0).describe("Storage trie write value per byte cost"), "touching_trie_node": z.number().int().gte(0).describe("Cost per reading trie node from DB"), "utf16_decoding_base": z.number().int().gte(0).describe("Base cost of decoding utf16. It's used for `log_utf16`."), "utf16_decoding_byte": z.number().int().gte(0).describe("Cost per byte of decoding utf16. It's used for `log_utf16`."), "utf8_decoding_base": z.number().int().gte(0).describe("Base cost of decoding utf8. It's used for `log_utf8` and `panic_utf8`."), "utf8_decoding_byte": z.number().int().gte(0).describe("Cost per byte of decoding utf8. It's used for `log_utf8` and `panic_utf8`."), "validator_stake_base": z.number().int().gte(0).describe("Cost of calling `validator_stake`."), "validator_total_stake_base": z.number().int().gte(0).describe("Cost of calling `validator_total_stake`."), "write_memory_base": z.number().int().gte(0).describe("Base cost for guest memory write"), "write_memory_byte": z.number().int().gte(0).describe("Cost for guest memory write per byte"), "write_register_base": z.number().int().gte(0).describe("Base cost for writing into register"), "write_register_byte": z.number().int().gte(0).describe("Cost for writing byte into register"), "yield_create_base": z.number().int().gte(0).describe("Base cost for creating a yield promise."), "yield_create_byte": z.number().int().gte(0).describe("Per byte cost of arguments and method name."), "yield_resume_base": z.number().int().gte(0).describe("Base cost for resuming a yield receipt."), "yield_resume_byte": z.number().int().gte(0).describe("Per byte cost of resume payload.") }).describe("Typed view of ExtCostsConfig to preserve JSON output field names in protocol\nconfig RPC output.").describe("Costs for runtime externals"), "fix_contract_loading_cost": z.boolean().describe("See [VMConfig::fix_contract_loading_cost](crate::vm::Config::fix_contract_loading_cost)."), "global_contract_host_fns": z.boolean().describe("See [VMConfig::global_contract_host_fns](crate::vm::Config::global_contract_host_fns)."), "grow_mem_cost": z.number().int().gte(0).describe("Gas cost of a growing memory by single page."), "implicit_account_creation": z.boolean().describe("See [VMConfig::implicit_account_creation](crate::vm::Config::implicit_account_creation)."), "limit_config": z.object({ "account_id_validity_rules_version": z.number().int().gte(0).lte(255).describe("Whether to enforce account_id well-formed-ness where it wasn't enforced\nhistorically.").default(0), "initial_memory_pages": z.number().int().gte(0).describe("The initial number of memory pages.\nNOTE: It's not a limiter itself, but it's a value we use for initial_memory_pages."), "max_actions_per_receipt": z.number().int().gte(0).describe("Max number of actions per receipt."), "max_arguments_length": z.number().int().gte(0).describe("Max length of arguments in a function call action."), "max_contract_size": z.number().int().gte(0).describe("Max contract size"), "max_elements_per_contract_table": z.union([z.number().int().gte(0).describe("If present, stores max number of elements in a single contract's table"), z.null().describe("If present, stores max number of elements in a single contract's table")]).describe("If present, stores max number of elements in a single contract's table").optional(), "max_functions_number_per_contract": z.union([z.number().int().gte(0).describe("If present, stores max number of functions in one contract"), z.null().describe("If present, stores max number of functions in one contract")]).describe("If present, stores max number of functions in one contract").optional(), "max_gas_burnt": z.number().int().gte(0).describe("Max amount of gas that can be used, excluding gas attached to promises."), "max_length_method_name": z.number().int().gte(0).describe("Max length of any method name (without terminating character)."), "max_length_returned_data": z.number().int().gte(0).describe("Max length of returned data"), "max_length_storage_key": z.number().int().gte(0).describe("Max storage key size"), "max_length_storage_value": z.number().int().gte(0).describe("Max storage value size"), "max_locals_per_contract": z.union([z.number().int().gte(0).describe("If present, stores max number of locals declared globally in one contract"), z.null().describe("If present, stores max number of locals declared globally in one contract")]).describe("If present, stores max number of locals declared globally in one contract").optional(), "max_memory_pages": z.number().int().gte(0).describe("What is the maximal memory pages amount is allowed to have for a contract."), "max_number_bytes_method_names": z.number().int().gte(0).describe("Max total length of all method names (including terminating character) for a function call\npermission access key."), "max_number_input_data_dependencies": z.number().int().gte(0).describe("Max number of input data dependencies"), "max_number_logs": z.number().int().gte(0).describe("Maximum number of log entries."), "max_number_registers": z.number().int().gte(0).describe("Maximum number of registers that can be used simultaneously.\n\nNote that due to an implementation quirk [read: a bug] in VMLogic, if we\nhave this number of registers, no subsequent writes to the registers\nwill succeed even if they replace an existing register."), "max_promises_per_function_call_action": z.number().int().gte(0).describe("Max number of promises that a function call can create"), "max_receipt_size": z.number().int().gte(0).describe("Max receipt size"), "max_register_size": z.number().int().gte(0).describe("Maximum number of bytes that can be stored in a single register."), "max_stack_height": z.number().int().gte(0).describe("How tall the stack is allowed to grow?\n\nSee <https://wiki.parity.io/WebAssembly-StackHeight> to find out how the stack frame cost\nis calculated."), "max_tables_per_contract": z.union([z.number().int().gte(0).describe("If present, stores max number of tables declared globally in one contract"), z.null().describe("If present, stores max number of tables declared globally in one contract")]).describe("If present, stores max number of tables declared globally in one contract").optional(), "max_total_log_length": z.number().int().gte(0).describe("Maximum total length in bytes of all log messages."), "max_total_prepaid_gas": z.number().int().gte(0).describe("Max total prepaid gas for all function call actions per receipt."), "max_transaction_size": z.number().int().gte(0).describe("Max transaction size"), "max_yield_payload_size": z.number().int().gte(0).describe("Maximum number of bytes for payload passed over a yield resume."), "per_receipt_storage_proof_size_limit": z.number().int().gte(0).describe("Hard limit on the size of storage proof generated while executing a single receipt."), "registers_memory_limit": z.number().int().gte(0).describe("Limit of memory used by registers."), "yield_timeout_length_in_blocks": z.number().int().gte(0).describe("Number of blocks after which a yielded promise times out.") }).describe("Describes limits for VM and Runtime.\nTODO #4139: consider switching to strongly-typed wrappers instead of raw quantities").describe("Describes limits for VM and Runtime.\n\nTODO: Consider changing this to `VMLimitConfigView` to avoid dependency\non runtime."), "linear_op_base_cost": z.number().int().gte(0).describe("Base gas cost of a linear operation"), "linear_op_unit_cost": z.number().int().gte(0).describe("Unit gas cost of a linear operation"), "reftypes_bulk_memory": z.boolean().describe("See [VMConfig::reftypes_bulk_memory](crate::vm::Config::reftypes_bulk_memory)."), "regular_op_cost": z.number().int().gte(0).describe("Gas cost of a regular operation."), "saturating_float_to_int": z.boolean().describe("See [VMConfig::saturating_float_to_int](crate::vm::Config::saturating_float_to_int)."), "storage_get_mode": z.enum(["FlatStorage","Trie"]).describe("This enum represents if a storage_get call will be performed through flat storage or trie").describe("See [VMConfig::storage_get_mode](crate::vm::Config::storage_get_mode)."), "vm_kind": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Wasmer0").describe("Wasmer 0.17.x VM. Gone now."), z.literal("Wasmtime").describe("Wasmtime VM."), z.literal("Wasmer2").describe("Wasmer 2.x VM."), z.literal("NearVm").describe("NearVM.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("See [VMConfig::vm_kind](crate::vm::Config::vm_kind).") }).describe("Config of wasm operations."), "witness_config": z.object({ "combined_transactions_size_limit": z.number().int().gte(0).describe("Maximum size of transactions contained inside ChunkStateWitness.\n\nA witness contains transactions from both the previous chunk and the current one.\nThis parameter limits the sum of sizes of transactions from both of those chunks."), "main_storage_proof_size_soft_limit": z.number().int().gte(0).describe("Size limit for storage proof generated while executing receipts in a chunk.\nAfter this limit is reached we defer execution of any new receipts."), "new_transactions_validation_state_size_soft_limit": z.number().int().gte(0).describe("Soft size limit of storage proof used to validate new transactions in ChunkStateWitness.") }).describe("Configuration specific to ChunkStateWitness.").describe("Configuration specific to ChunkStateWitness.") }).describe("View that preserves JSON format of the runtime config.").describe("Runtime configuration (mostly economics constants)."), "shard_layout": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "V0": z.object({ "num_shards": z.number().int().gte(0).describe("Map accounts evenly across all shards"), "version": z.number().int().gte(0).describe("Version of the shard layout, this is useful for uniquely identify the shard layout") }).describe("A shard layout that maps accounts evenly across all shards -- by calculate the hash of account\nid and mod number of shards. This is added to capture the old `account_id_to_shard_id` algorithm,\nto keep backward compatibility for some existing tests.\n`parent_shards` for `ShardLayoutV1` is always `None`, meaning it can only be the first shard layout\na chain uses.") }).strict(), z.object({ "V1": z.object({ "boundary_accounts": z.array(z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```")).describe("The boundary accounts are the accounts on boundaries between shards.\nEach shard contains a range of accounts from one boundary account to\nanother - or the smallest or largest account possible. The total\nnumber of shards is equal to the number of boundary accounts plus 1."), "shards_split_map": z.union([z.array(z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias."))).describe("Maps shards from the last shard layout to shards that it splits to in this shard layout,\nUseful for constructing states for the shards.\nNone for the genesis shard layout"), z.null().describe("Maps shards from the last shard layout to shards that it splits to in this shard layout,\nUseful for constructing states for the shards.\nNone for the genesis shard layout")]).describe("Maps shards from the last shard layout to shards that it splits to in this shard layout,\nUseful for constructing states for the shards.\nNone for the genesis shard layout").optional(), "to_parent_shard_map": z.union([z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")).describe("Maps shard in this shard layout to their parent shard\nSince shard_ids always range from 0 to num_shards - 1, we use vec instead of a hashmap"), z.null().describe("Maps shard in this shard layout to their parent shard\nSince shard_ids always range from 0 to num_shards - 1, we use vec instead of a hashmap")]).describe("Maps shard in this shard layout to their parent shard\nSince shard_ids always range from 0 to num_shards - 1, we use vec instead of a hashmap").optional(), "version": z.number().int().gte(0).describe("Version of the shard layout, this is useful for uniquely identify the shard layout") }) }).strict(), z.object({ "V2": z.object({ "boundary_accounts": z.array(z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```")), "id_to_index_map": z.record(z.number().int().gte(0)), "index_to_id_map": z.record(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")), "shard_ids": z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")), "shards_parent_map": z.union([z.record(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")), z.null()]).optional(), "shards_split_map": z.union([z.record(z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias."))), z.null()]).optional(), "version": z.number().int().gte(0) }).describe("Counterpart to `ShardLayoutV2` composed of maps with string keys to aid\nserde serialization.") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("A versioned struct that contains all information needed to assign accounts to shards.\n\nBecause of re-sharding, the chain may use different shard layout to split shards at different\ntimes. Currently, `ShardLayout` is stored as part of `EpochConfig`, which is generated each\nepoch given the epoch protocol version. In mainnet/testnet, we use two shard layouts since\nre-sharding has only happened once. It is stored as part of genesis config, see\ndefault_simple_nightshade_shard_layout() Below is an overview for some important\nfunctionalities of ShardLayout interface.").describe("Layout information regarding how to split accounts to shards"), "shuffle_shard_assignment_for_chunk_producers": z.boolean().describe("If true, shuffle the chunk producers across shards. In other words, if\nthe shard assignments were `[S_0, S_1, S_2, S_3]` where `S_i` represents\nthe set of chunk producers for shard `i`, if this flag were true, the\nshard assignments might become, for example, `[S_2, S_0, S_3, S_1]`."), "target_validator_mandates_per_shard": z.number().int().gte(0).describe("Number of target chunk validator mandates for each shard."), "transaction_validity_period": z.number().int().gte(0).describe("Number of blocks for which a given transaction is valid") })
export type RpcProtocolConfigResponse = z.infer<typeof RpcProtocolConfigResponse>


export const RpcQueryRequest = z.record(z.any()).and(z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "block_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.number().int().gte(0), z.string()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "request_type": z.literal("view_account") }), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "block_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.number().int().gte(0), z.string()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "request_type": z.literal("view_code") }), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "block_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.number().int().gte(0), z.string()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "include_proof": z.boolean().optional(), "prefix_base64": z.string().describe("This type is used to mark keys (arrays of bytes) that are queried from store.\n\nNOTE: Currently, this type is only used in the view_client and RPC to be able to transparently\npretty-serialize the bytes arrays as base64-encoded strings (see `serialize.rs`)."), "request_type": z.literal("view_state") }), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "block_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.number().int().gte(0), z.string()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "public_key": z.string(), "request_type": z.literal("view_access_key") }), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "block_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.number().int().gte(0), z.string()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "request_type": z.literal("view_access_key_list") }), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "args_base64": z.string().describe("This type is used to mark function arguments.\n\nNOTE: The main reason for this to exist (except the type-safety) is that the value is\ntransparently serialized and deserialized as a base64-encoded string when serde is used\n(serde_json)."), "block_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.number().int().gte(0), z.string()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "method_name": z.string(), "request_type": z.literal("call_function") }), z.object({ "block_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.number().int().gte(0), z.string()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "code_hash": z.string(), "request_type": z.literal("view_global_contract_code") }), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "block_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.number().int().gte(0), z.string()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "request_type": z.literal("view_global_contract_code_by_account_id") }), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "finality": z.enum(["optimistic","near-final","final"]).describe("Different types of finality."), "request_type": z.literal("view_account") }), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "finality": z.enum(["optimistic","near-final","final"]).describe("Different types of finality."), "request_type": z.literal("view_code") }), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "finality": z.enum(["optimistic","near-final","final"]).describe("Different types of finality."), "include_proof": z.boolean().optional(), "prefix_base64": z.string().describe("This type is used to mark keys (arrays of bytes) that are queried from store.\n\nNOTE: Currently, this type is only used in the view_client and RPC to be able to transparently\npretty-serialize the bytes arrays as base64-encoded strings (see `serialize.rs`)."), "request_type": z.literal("view_state") }), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "finality": z.enum(["optimistic","near-final","final"]).describe("Different types of finality."), "public_key": z.string(), "request_type": z.literal("view_access_key") }), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "finality": z.enum(["optimistic","near-final","final"]).describe("Different types of finality."), "request_type": z.literal("view_access_key_list") }), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "args_base64": z.string().describe("This type is used to mark function arguments.\n\nNOTE: The main reason for this to exist (except the type-safety) is that the value is\ntransparently serialized and deserialized as a base64-encoded string when serde is used\n(serde_json)."), "finality": z.enum(["optimistic","near-final","final"]).describe("Different types of finality."), "method_name": z.string(), "request_type": z.literal("call_function") }), z.object({ "code_hash": z.string(), "finality": z.enum(["optimistic","near-final","final"]).describe("Different types of finality."), "request_type": z.literal("view_global_contract_code") }), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "finality": z.enum(["optimistic","near-final","final"]).describe("Different types of finality."), "request_type": z.literal("view_global_contract_code_by_account_id") }), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "request_type": z.literal("view_account"), "sync_checkpoint": z.enum(["genesis","earliest_available"]) }), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "request_type": z.literal("view_code"), "sync_checkpoint": z.enum(["genesis","earliest_available"]) }), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "include_proof": z.boolean().optional(), "prefix_base64": z.string().describe("This type is used to mark keys (arrays of bytes) that are queried from store.\n\nNOTE: Currently, this type is only used in the view_client and RPC to be able to transparently\npretty-serialize the bytes arrays as base64-encoded strings (see `serialize.rs`)."), "request_type": z.literal("view_state"), "sync_checkpoint": z.enum(["genesis","earliest_available"]) }), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string(), "request_type": z.literal("view_access_key"), "sync_checkpoint": z.enum(["genesis","earliest_available"]) }), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "request_type": z.literal("view_access_key_list"), "sync_checkpoint": z.enum(["genesis","earliest_available"]) }), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "args_base64": z.string().describe("This type is used to mark function arguments.\n\nNOTE: The main reason for this to exist (except the type-safety) is that the value is\ntransparently serialized and deserialized as a base64-encoded string when serde is used\n(serde_json)."), "method_name": z.string(), "request_type": z.literal("call_function"), "sync_checkpoint": z.enum(["genesis","earliest_available"]) }), z.object({ "code_hash": z.string(), "request_type": z.literal("view_global_contract_code"), "sync_checkpoint": z.enum(["genesis","earliest_available"]) }), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "request_type": z.literal("view_global_contract_code_by_account_id"), "sync_checkpoint": z.enum(["genesis","earliest_available"]) })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }))
export type RpcQueryRequest = z.infer<typeof RpcQueryRequest>


export const RpcQueryResponse = z.record(z.any()).and(z.any().superRefine((x, ctx) => {
    const schemas = [z.intersection(z.object({ "block_hash": z.string(), "block_height": z.number().int().gte(0) }), z.object({ "amount": z.string(), "code_hash": z.string(), "global_contract_account_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "global_contract_hash": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "locked": z.string(), "storage_paid_at": z.number().int().gte(0).describe("TODO(2271): deprecated.").default(0), "storage_usage": z.number().int().gte(0) }).describe("A view of the account")), z.intersection(z.object({ "block_hash": z.string(), "block_height": z.number().int().gte(0) }), z.object({ "code_base64": z.string(), "hash": z.string() }).describe("A view of the contract code.")), z.intersection(z.object({ "block_hash": z.string(), "block_height": z.number().int().gte(0) }), z.object({ "proof": z.array(z.string()).optional(), "values": z.array(z.object({ "key": z.string().describe("This type is used to mark keys (arrays of bytes) that are queried from store.\n\nNOTE: Currently, this type is only used in the view_client and RPC to be able to transparently\npretty-serialize the bytes arrays as base64-encoded strings (see `serialize.rs`)."), "value": z.string().describe("This type is used to mark values returned from store (arrays of bytes).\n\nNOTE: Currently, this type is only used in the view_client and RPC to be able to transparently\npretty-serialize the bytes arrays as base64-encoded strings (see `serialize.rs`).") }).describe("Item of the state, key and value are serialized in base64 and proof for inclusion of given state item.")) }).describe("Resulting state values for a view state query request")), z.intersection(z.object({ "block_hash": z.string(), "block_height": z.number().int().gte(0) }), z.object({ "logs": z.array(z.string()), "result": z.array(z.number().int().gte(0).lte(255)) }).describe("A result returned by contract method")), z.intersection(z.object({ "block_hash": z.string(), "block_height": z.number().int().gte(0) }), z.object({ "nonce": z.number().int().gte(0), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("FullAccess"), z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "method_names": z.array(z.string()), "receiver_id": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the permission scope for an access key. Whether it is a function call or a full access key.") }).describe("Describes access key permission scope and nonce.")), z.intersection(z.object({ "block_hash": z.string(), "block_height": z.number().int().gte(0) }), z.object({ "keys": z.array(z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("FullAccess"), z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "method_names": z.array(z.string()), "receiver_id": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the permission scope for an access key. Whether it is a function call or a full access key.") }).describe("Describes access key permission scope and nonce."), "public_key": z.string() }).describe("Describes information about an access key including the public key.")) }).describe("Lists access keys"))];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }))
export type RpcQueryResponse = z.infer<typeof RpcQueryResponse>


export const RpcReceiptRequest = z.object({ "receipt_id": z.string() })
export type RpcReceiptRequest = z.infer<typeof RpcReceiptRequest>


export const RpcReceiptResponse = z.object({ "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "priority": z.number().int().gte(0).default(0), "receipt": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "Action": z.object({ "actions": z.array(z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("CreateAccount"), z.object({ "DeployContract": z.object({ "code": z.string() }) }).strict(), z.object({ "FunctionCall": z.object({ "args": z.string().describe("This type is used to mark function arguments.\n\nNOTE: The main reason for this to exist (except the type-safety) is that the value is\ntransparently serialized and deserialized as a base64-encoded string when serde is used\n(serde_json)."), "deposit": z.string(), "gas": z.number().int().gte(0), "method_name": z.string() }) }).strict(), z.object({ "Transfer": z.object({ "deposit": z.string() }) }).strict(), z.object({ "Stake": z.object({ "public_key": z.string(), "stake": z.string() }) }).strict(), z.object({ "AddKey": z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("FullAccess"), z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "method_names": z.array(z.string()), "receiver_id": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the permission scope for an access key. Whether it is a function call or a full access key.") }).describe("Describes access key permission scope and nonce."), "public_key": z.string() }) }).strict(), z.object({ "DeleteKey": z.object({ "public_key": z.string() }) }).strict(), z.object({ "DeleteAccount": z.object({ "beneficiary_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "Delegate": z.object({ "delegate_action": z.object({ "actions": z.array(z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CreateAccount": z.record(z.any()).describe("Create account action") }).strict().describe("Create an (sub)account using a transaction `receiver_id` as an ID for\na new account ID must pass validation rules described here\n<https://nomicon.io/DataStructures/Account>."), z.object({ "DeployContract": z.object({ "code": z.string().describe("WebAssembly binary") }).describe("Deploy contract action") }).strict().describe("Sets a Wasm code to a receiver_id"), z.object({ "FunctionCall": z.object({ "args": z.string(), "deposit": z.string(), "gas": z.number().int().gte(0), "method_name": z.string() }) }).strict(), z.object({ "Transfer": z.object({ "deposit": z.string() }) }).strict(), z.object({ "Stake": z.object({ "public_key": z.string().describe("Validator key which will be used to sign transactions on behalf of signer_id"), "stake": z.string().describe("Amount of tokens to stake.") }).describe("An action which stakes signer_id tokens and setup's validator public key") }).strict(), z.object({ "AddKey": z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0).describe("Nonce for this access key, used for tx nonce generation. When access key is created, nonce\nis set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\nSee <https://github.com/near/nearcore/issues/3779> for more details."), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Allowance is a balance limit to use by this access key to pay for function call gas and\ntransaction fees. When this access key is used, both account balance and the allowance is\ndecreased by the same value.\n`None` means unlimited allowance.\nNOTE: To change or increase the allowance, the old access key needs to be deleted and a new\naccess key should be created.").optional(), "method_names": z.array(z.string()).describe("A list of method names that can be used. The access key only allows transactions with the\nfunction call of one of the given method names.\nEmpty list means any method name can be used."), "receiver_id": z.string().describe("The access key only allows transactions with the given receiver's account id.") }).describe("Grants limited permission to make transactions with FunctionCallActions\nThe permission can limit the allowed balance to be spent on the prepaid gas.\nIt also restrict the account ID of the receiver for this function call.\nIt also can restrict the method name for the allowed function calls.") }).strict(), z.literal("FullAccess").describe("Grants full access to the account.\nNOTE: It's used to replace account-level public keys.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Defines permissions for AccessKey").describe("Defines permissions for this access key.") }).describe("Access key provides limited access to an account. Each access key belongs to some account and\nis identified by a unique (within the account) public key. One account may have large number of\naccess keys. Access keys allow to act on behalf of the account by restricting transactions\nthat can be issued.\n`account_id,public_key` is a key in the state").describe("An access key with the permission"), "public_key": z.string().describe("A public key which will be associated with an access_key") }).describe("An action that adds key with public key associated") }).strict(), z.object({ "DeleteKey": z.object({ "public_key": z.string().describe("A public key associated with the access_key to be deleted.") }) }).strict(), z.object({ "DeleteAccount": z.object({ "beneficiary_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeployGlobalContract": z.object({ "code": z.string().describe("WebAssembly binary"), "deploy_mode": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("CodeHash").describe("Contract is deployed under its code hash.\nUsers will be able reference it by that hash.\nThis effectively makes the contract immutable."), z.literal("AccountId").describe("Contract is deployed under the owner account id.\nUsers will be able reference it by that account id.\nThis allows the owner to update the contract for all its users.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Deploy global contract action") }).strict(), z.object({ "UseGlobalContract": z.object({ "contract_identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Use global contract action") }).strict(), z.object({ "DeterministicStateInit": z.object({ "deposit": z.string(), "state_init": z.object({ "V1": z.object({ "code": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "data": z.record(z.string()) }) }).strict() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An Action that can be included in a transaction or receipt, excluding delegate actions. This type represents all possible action types except DelegateAction to prevent infinite recursion in meta-transactions.")).describe("List of actions to be executed.\n\nWith the meta transactions MVP defined in NEP-366, nested\nDelegateActions are not allowed. A separate type is used to enforce it."), "max_block_height": z.number().int().gte(0).describe("The maximal height of the block in the blockchain below which the given DelegateAction is valid."), "nonce": z.number().int().gte(0).describe("Nonce to ensure that the same delegate action is not sent twice by a\nrelayer and should match for given account's `public_key`.\nAfter this action is processed it will increment."), "public_key": z.string().describe("Public key used to sign this delegated action."), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("Receiver of the delegated actions."), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("Signer of the delegated actions") }).describe("This action allows to execute the inner actions behalf of the defined sender."), "signature": z.string() }) }).strict(), z.object({ "DeployGlobalContract": z.object({ "code": z.string() }) }).strict(), z.object({ "DeployGlobalContractByAccountId": z.object({ "code": z.string() }) }).strict(), z.object({ "UseGlobalContract": z.object({ "code_hash": z.string() }) }).strict(), z.object({ "UseGlobalContractByAccountId": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInit": z.object({ "code": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "hash": z.string() }).strict(), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "data": z.record(z.string()), "deposit": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })), "gas_price": z.string(), "input_data_ids": z.array(z.string()), "is_promise_yield": z.boolean().default(false), "output_data_receivers": z.array(z.object({ "data_id": z.string(), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") })), "refund_to": z.any().superRefine((x, ctx) => {
    const schemas = [z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "signer_public_key": z.string() }) }).strict(), z.object({ "Data": z.object({ "data": z.union([z.string(), z.null()]).default(null), "data_id": z.string(), "is_promise_resume": z.boolean().default(false) }) }).strict(), z.object({ "GlobalContractDistribution": z.object({ "already_delivered_shards": z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")), "code": z.string(), "id": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "target_shard": z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.") }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "receipt_id": z.string(), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") })
export type RpcReceiptResponse = z.infer<typeof RpcReceiptResponse>


export const RpcSendTransactionRequest = z.object({ "signed_tx_base64": z.string(), "wait_until": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("NONE").describe("Transaction is waiting to be included into the block"), z.literal("INCLUDED").describe("Transaction is included into the block. The block may be not finalized yet"), z.literal("EXECUTED_OPTIMISTIC").describe("Transaction is included into the block +\nAll non-refund transaction receipts finished their execution.\nThe corresponding blocks for tx and each receipt may be not finalized yet"), z.literal("INCLUDED_FINAL").describe("Transaction is included into finalized block"), z.literal("EXECUTED").describe("Transaction is included into finalized block +\nAll non-refund transaction receipts finished their execution.\nThe corresponding blocks for each receipt may be not finalized yet"), z.literal("FINAL").describe("Transaction is included into finalized block +\nExecution of all transaction receipts is finalized, including refund receipts")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).default("EXECUTED_OPTIMISTIC") })
export type RpcSendTransactionRequest = z.infer<typeof RpcSendTransactionRequest>


export const RpcSplitStorageInfoRequest = z.record(z.any())
export type RpcSplitStorageInfoRequest = z.infer<typeof RpcSplitStorageInfoRequest>


export const RpcSplitStorageInfoResponse = z.object({ "cold_head_height": z.union([z.number().int().gte(0), z.null()]).optional(), "final_head_height": z.union([z.number().int().gte(0), z.null()]).optional(), "head_height": z.union([z.number().int().gte(0), z.null()]).optional(), "hot_db_kind": z.union([z.string(), z.null()]).optional() }).describe("Contains the split storage information.")
export type RpcSplitStorageInfoResponse = z.infer<typeof RpcSplitStorageInfoResponse>


export const RpcStateChangesInBlockByTypeRequest = z.record(z.any()).and(z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "account_ids": z.array(z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```")), "block_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.number().int().gte(0), z.string()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "changes_type": z.literal("account_changes") }), z.object({ "block_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.number().int().gte(0), z.string()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "changes_type": z.literal("single_access_key_changes"), "keys": z.array(z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }).describe("Account ID with its public key.")) }), z.object({ "block_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.number().int().gte(0), z.string()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "changes_type": z.literal("single_gas_key_changes"), "keys": z.array(z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }).describe("Account ID with its public key.")) }), z.object({ "account_ids": z.array(z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```")), "block_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.number().int().gte(0), z.string()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "changes_type": z.literal("all_access_key_changes") }), z.object({ "account_ids": z.array(z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```")), "block_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.number().int().gte(0), z.string()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "changes_type": z.literal("all_gas_key_changes") }), z.object({ "account_ids": z.array(z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```")), "block_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.number().int().gte(0), z.string()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "changes_type": z.literal("contract_code_changes") }), z.object({ "account_ids": z.array(z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```")), "block_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.number().int().gte(0), z.string()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "changes_type": z.literal("data_changes"), "key_prefix_base64": z.string().describe("This type is used to mark keys (arrays of bytes) that are queried from store.\n\nNOTE: Currently, this type is only used in the view_client and RPC to be able to transparently\npretty-serialize the bytes arrays as base64-encoded strings (see `serialize.rs`).") }), z.object({ "account_ids": z.array(z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```")), "changes_type": z.literal("account_changes"), "finality": z.enum(["optimistic","near-final","final"]).describe("Different types of finality.") }), z.object({ "changes_type": z.literal("single_access_key_changes"), "finality": z.enum(["optimistic","near-final","final"]).describe("Different types of finality."), "keys": z.array(z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }).describe("Account ID with its public key.")) }), z.object({ "changes_type": z.literal("single_gas_key_changes"), "finality": z.enum(["optimistic","near-final","final"]).describe("Different types of finality."), "keys": z.array(z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }).describe("Account ID with its public key.")) }), z.object({ "account_ids": z.array(z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```")), "changes_type": z.literal("all_access_key_changes"), "finality": z.enum(["optimistic","near-final","final"]).describe("Different types of finality.") }), z.object({ "account_ids": z.array(z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```")), "changes_type": z.literal("all_gas_key_changes"), "finality": z.enum(["optimistic","near-final","final"]).describe("Different types of finality.") }), z.object({ "account_ids": z.array(z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```")), "changes_type": z.literal("contract_code_changes"), "finality": z.enum(["optimistic","near-final","final"]).describe("Different types of finality.") }), z.object({ "account_ids": z.array(z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```")), "changes_type": z.literal("data_changes"), "finality": z.enum(["optimistic","near-final","final"]).describe("Different types of finality."), "key_prefix_base64": z.string().describe("This type is used to mark keys (arrays of bytes) that are queried from store.\n\nNOTE: Currently, this type is only used in the view_client and RPC to be able to transparently\npretty-serialize the bytes arrays as base64-encoded strings (see `serialize.rs`).") }), z.object({ "account_ids": z.array(z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```")), "changes_type": z.literal("account_changes"), "sync_checkpoint": z.enum(["genesis","earliest_available"]) }), z.object({ "changes_type": z.literal("single_access_key_changes"), "keys": z.array(z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }).describe("Account ID with its public key.")), "sync_checkpoint": z.enum(["genesis","earliest_available"]) }), z.object({ "changes_type": z.literal("single_gas_key_changes"), "keys": z.array(z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }).describe("Account ID with its public key.")), "sync_checkpoint": z.enum(["genesis","earliest_available"]) }), z.object({ "account_ids": z.array(z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```")), "changes_type": z.literal("all_access_key_changes"), "sync_checkpoint": z.enum(["genesis","earliest_available"]) }), z.object({ "account_ids": z.array(z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```")), "changes_type": z.literal("all_gas_key_changes"), "sync_checkpoint": z.enum(["genesis","earliest_available"]) }), z.object({ "account_ids": z.array(z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```")), "changes_type": z.literal("contract_code_changes"), "sync_checkpoint": z.enum(["genesis","earliest_available"]) }), z.object({ "account_ids": z.array(z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```")), "changes_type": z.literal("data_changes"), "key_prefix_base64": z.string().describe("This type is used to mark keys (arrays of bytes) that are queried from store.\n\nNOTE: Currently, this type is only used in the view_client and RPC to be able to transparently\npretty-serialize the bytes arrays as base64-encoded strings (see `serialize.rs`)."), "sync_checkpoint": z.enum(["genesis","earliest_available"]) })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })).describe("It is a [serializable view] of [`StateChangesRequest`].\n\n[serializable view]: ./index.html\n[`StateChangesRequest`]: ../types/struct.StateChangesRequest.html")
export type RpcStateChangesInBlockByTypeRequest = z.infer<typeof RpcStateChangesInBlockByTypeRequest>


export const RpcStateChangesInBlockByTypeResponse = z.object({ "block_hash": z.string(), "changes": z.array(z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "type": z.literal("account_touched") }), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "type": z.literal("access_key_touched") }), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "type": z.literal("data_touched") }), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "type": z.literal("contract_code_touched") })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("It is a [serializable view] of [`StateChangeKind`].\n\n[serializable view]: ./index.html\n[`StateChangeKind`]: ../types/struct.StateChangeKind.html")) })
export type RpcStateChangesInBlockByTypeResponse = z.infer<typeof RpcStateChangesInBlockByTypeResponse>


export const RpcStateChangesInBlockRequest = z.record(z.any()).and(z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "block_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.number().int().gte(0), z.string()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }), z.object({ "finality": z.enum(["optimistic","near-final","final"]).describe("Different types of finality.") }), z.object({ "sync_checkpoint": z.enum(["genesis","earliest_available"]) })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }))
export type RpcStateChangesInBlockRequest = z.infer<typeof RpcStateChangesInBlockRequest>


export const RpcStateChangesInBlockResponse = z.object({ "block_hash": z.string(), "changes": z.array(z.record(z.any()).and(z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "cause": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "type": z.literal("not_writable_to_disk") }), z.object({ "type": z.literal("initial_state") }), z.object({ "tx_hash": z.string(), "type": z.literal("transaction_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_processing_started") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_gas_reward") }), z.object({ "receipt_hash": z.string(), "type": z.literal("receipt_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("postponed_receipt") }), z.object({ "type": z.literal("updated_delayed_receipts") }), z.object({ "type": z.literal("validator_accounts_update") }), z.object({ "type": z.literal("migration") }), z.object({ "type": z.literal("bandwidth_scheduler_state_update") })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("See crate::types::StateChangeCause for details."), "change": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "amount": z.string(), "code_hash": z.string(), "global_contract_account_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "global_contract_hash": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "locked": z.string(), "storage_paid_at": z.number().int().gte(0).describe("TODO(2271): deprecated.").default(0), "storage_usage": z.number().int().gte(0) }).describe("A view of the account"), "type": z.literal("account_update") }), z.object({ "cause": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "type": z.literal("not_writable_to_disk") }), z.object({ "type": z.literal("initial_state") }), z.object({ "tx_hash": z.string(), "type": z.literal("transaction_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_processing_started") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_gas_reward") }), z.object({ "receipt_hash": z.string(), "type": z.literal("receipt_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("postponed_receipt") }), z.object({ "type": z.literal("updated_delayed_receipts") }), z.object({ "type": z.literal("validator_accounts_update") }), z.object({ "type": z.literal("migration") }), z.object({ "type": z.literal("bandwidth_scheduler_state_update") })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("See crate::types::StateChangeCause for details."), "change": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }), "type": z.literal("account_deletion") }), z.object({ "cause": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "type": z.literal("not_writable_to_disk") }), z.object({ "type": z.literal("initial_state") }), z.object({ "tx_hash": z.string(), "type": z.literal("transaction_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_processing_started") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_gas_reward") }), z.object({ "receipt_hash": z.string(), "type": z.literal("receipt_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("postponed_receipt") }), z.object({ "type": z.literal("updated_delayed_receipts") }), z.object({ "type": z.literal("validator_accounts_update") }), z.object({ "type": z.literal("migration") }), z.object({ "type": z.literal("bandwidth_scheduler_state_update") })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("See crate::types::StateChangeCause for details."), "change": z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("FullAccess"), z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "method_names": z.array(z.string()), "receiver_id": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the permission scope for an access key. Whether it is a function call or a full access key.") }).describe("Describes access key permission scope and nonce."), "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }), "type": z.literal("access_key_update") }), z.object({ "cause": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "type": z.literal("not_writable_to_disk") }), z.object({ "type": z.literal("initial_state") }), z.object({ "tx_hash": z.string(), "type": z.literal("transaction_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_processing_started") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_gas_reward") }), z.object({ "receipt_hash": z.string(), "type": z.literal("receipt_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("postponed_receipt") }), z.object({ "type": z.literal("updated_delayed_receipts") }), z.object({ "type": z.literal("validator_accounts_update") }), z.object({ "type": z.literal("migration") }), z.object({ "type": z.literal("bandwidth_scheduler_state_update") })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("See crate::types::StateChangeCause for details."), "change": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }), "type": z.literal("access_key_deletion") }), z.object({ "cause": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "type": z.literal("not_writable_to_disk") }), z.object({ "type": z.literal("initial_state") }), z.object({ "tx_hash": z.string(), "type": z.literal("transaction_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_processing_started") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_gas_reward") }), z.object({ "receipt_hash": z.string(), "type": z.literal("receipt_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("postponed_receipt") }), z.object({ "type": z.literal("updated_delayed_receipts") }), z.object({ "type": z.literal("validator_accounts_update") }), z.object({ "type": z.literal("migration") }), z.object({ "type": z.literal("bandwidth_scheduler_state_update") })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("See crate::types::StateChangeCause for details."), "change": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "gas_key": z.object({ "balance": z.string(), "num_nonces": z.number().int().gte(0), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("FullAccess"), z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "method_names": z.array(z.string()), "receiver_id": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the permission scope for an access key. Whether it is a function call or a full access key.") }), "public_key": z.string() }), "type": z.literal("gas_key_update") }), z.object({ "cause": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "type": z.literal("not_writable_to_disk") }), z.object({ "type": z.literal("initial_state") }), z.object({ "tx_hash": z.string(), "type": z.literal("transaction_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_processing_started") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_gas_reward") }), z.object({ "receipt_hash": z.string(), "type": z.literal("receipt_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("postponed_receipt") }), z.object({ "type": z.literal("updated_delayed_receipts") }), z.object({ "type": z.literal("validator_accounts_update") }), z.object({ "type": z.literal("migration") }), z.object({ "type": z.literal("bandwidth_scheduler_state_update") })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("See crate::types::StateChangeCause for details."), "change": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "index": z.number().int().gte(0), "nonce": z.number().int().gte(0), "public_key": z.string() }), "type": z.literal("gas_key_nonce_update") }), z.object({ "cause": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "type": z.literal("not_writable_to_disk") }), z.object({ "type": z.literal("initial_state") }), z.object({ "tx_hash": z.string(), "type": z.literal("transaction_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_processing_started") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_gas_reward") }), z.object({ "receipt_hash": z.string(), "type": z.literal("receipt_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("postponed_receipt") }), z.object({ "type": z.literal("updated_delayed_receipts") }), z.object({ "type": z.literal("validator_accounts_update") }), z.object({ "type": z.literal("migration") }), z.object({ "type": z.literal("bandwidth_scheduler_state_update") })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("See crate::types::StateChangeCause for details."), "change": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }), "type": z.literal("gas_key_deletion") }), z.object({ "cause": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "type": z.literal("not_writable_to_disk") }), z.object({ "type": z.literal("initial_state") }), z.object({ "tx_hash": z.string(), "type": z.literal("transaction_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_processing_started") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_gas_reward") }), z.object({ "receipt_hash": z.string(), "type": z.literal("receipt_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("postponed_receipt") }), z.object({ "type": z.literal("updated_delayed_receipts") }), z.object({ "type": z.literal("validator_accounts_update") }), z.object({ "type": z.literal("migration") }), z.object({ "type": z.literal("bandwidth_scheduler_state_update") })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("See crate::types::StateChangeCause for details."), "change": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "key_base64": z.string().describe("This type is used to mark keys (arrays of bytes) that are queried from store.\n\nNOTE: Currently, this type is only used in the view_client and RPC to be able to transparently\npretty-serialize the bytes arrays as base64-encoded strings (see `serialize.rs`)."), "value_base64": z.string().describe("This type is used to mark values returned from store (arrays of bytes).\n\nNOTE: Currently, this type is only used in the view_client and RPC to be able to transparently\npretty-serialize the bytes arrays as base64-encoded strings (see `serialize.rs`).") }), "type": z.literal("data_update") }), z.object({ "cause": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "type": z.literal("not_writable_to_disk") }), z.object({ "type": z.literal("initial_state") }), z.object({ "tx_hash": z.string(), "type": z.literal("transaction_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_processing_started") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_gas_reward") }), z.object({ "receipt_hash": z.string(), "type": z.literal("receipt_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("postponed_receipt") }), z.object({ "type": z.literal("updated_delayed_receipts") }), z.object({ "type": z.literal("validator_accounts_update") }), z.object({ "type": z.literal("migration") }), z.object({ "type": z.literal("bandwidth_scheduler_state_update") })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("See crate::types::StateChangeCause for details."), "change": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "key_base64": z.string().describe("This type is used to mark keys (arrays of bytes) that are queried from store.\n\nNOTE: Currently, this type is only used in the view_client and RPC to be able to transparently\npretty-serialize the bytes arrays as base64-encoded strings (see `serialize.rs`).") }), "type": z.literal("data_deletion") }), z.object({ "cause": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "type": z.literal("not_writable_to_disk") }), z.object({ "type": z.literal("initial_state") }), z.object({ "tx_hash": z.string(), "type": z.literal("transaction_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_processing_started") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_gas_reward") }), z.object({ "receipt_hash": z.string(), "type": z.literal("receipt_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("postponed_receipt") }), z.object({ "type": z.literal("updated_delayed_receipts") }), z.object({ "type": z.literal("validator_accounts_update") }), z.object({ "type": z.literal("migration") }), z.object({ "type": z.literal("bandwidth_scheduler_state_update") })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("See crate::types::StateChangeCause for details."), "change": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "code_base64": z.string() }), "type": z.literal("contract_code_update") }), z.object({ "cause": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "type": z.literal("not_writable_to_disk") }), z.object({ "type": z.literal("initial_state") }), z.object({ "tx_hash": z.string(), "type": z.literal("transaction_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_processing_started") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_gas_reward") }), z.object({ "receipt_hash": z.string(), "type": z.literal("receipt_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("postponed_receipt") }), z.object({ "type": z.literal("updated_delayed_receipts") }), z.object({ "type": z.literal("validator_accounts_update") }), z.object({ "type": z.literal("migration") }), z.object({ "type": z.literal("bandwidth_scheduler_state_update") })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("See crate::types::StateChangeCause for details."), "change": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }), "type": z.literal("contract_code_deletion") })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }))) })
export type RpcStateChangesInBlockResponse = z.infer<typeof RpcStateChangesInBlockResponse>


export const RpcStatusRequest = z.record(z.any())
export type RpcStatusRequest = z.infer<typeof RpcStatusRequest>


export const RpcStatusResponse = z.object({ "chain_id": z.string().describe("Unique chain id."), "detailed_debug_status": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "block_production_delay_millis": z.number().int().gte(0), "catchup_status": z.array(z.object({ "blocks_to_catchup": z.array(z.object({ "hash": z.string(), "height": z.number().int().gte(0) }).describe("Height and hash of a block")), "shard_sync_status": z.record(z.union([z.string(), z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^\\d+$"))) {
evaluated = true
const result = z.string().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}), "sync_block_hash": z.string(), "sync_block_height": z.number().int().gte(0) }).describe("Status of the [catchup](https://near.github.io/nearcore/architecture/how/sync.html#catchup) process")), "current_head_status": z.object({ "hash": z.string(), "height": z.number().int().gte(0) }).describe("Height and hash of a block"), "current_header_head_status": z.object({ "hash": z.string(), "height": z.number().int().gte(0) }).describe("Height and hash of a block"), "network_info": z.object({ "connected_peers": z.array(z.object({ "account_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "addr": z.string(), "archival": z.boolean(), "block_hash": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "connection_established_time_millis": z.number().int().gte(0), "height": z.union([z.number().int().gte(0), z.null()]).optional(), "is_highest_block_invalid": z.boolean(), "is_outbound_peer": z.boolean(), "last_time_peer_requested_millis": z.number().int().gte(0), "last_time_received_message_millis": z.number().int().gte(0), "nonce": z.number().int().gte(0).describe("Connection nonce."), "peer_id": z.string(), "received_bytes_per_sec": z.number().int().gte(0), "sent_bytes_per_sec": z.number().int().gte(0), "tracked_shards": z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")) })), "known_producers": z.array(z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "next_hops": z.union([z.array(z.string()), z.null()]).optional(), "peer_id": z.string() }).describe("Information about a Producer: its account name, peer_id and a list of connected peers that\nthe node can use to send message for this producer.")), "num_connected_peers": z.number().int().gte(0), "peer_max_count": z.number().int().gte(0), "tier1_accounts_data": z.array(z.object({ "account_key": z.string().describe("Account key of the validator signing this AccountData."), "peer_id": z.string().describe("ID of the node that handles the account key (aka validator key)."), "proxies": z.array(z.object({ "addr": z.string(), "peer_id": z.string() })).describe("Proxy nodes that are directly connected to the validator node\n(this list may include the validator node itself).\nTIER1 nodes should connect to one of the proxies to sent TIER1\nmessages to the validator."), "timestamp": z.string().describe("UTC timestamp of when the AccountData has been signed.") }).describe("AccountData is a piece of global state that a validator\nsigns and broadcasts to the network.\n\nIt is essentially the data that a validator wants to share with the network.\nAll the nodes in the network are collecting the account data\nbroadcasted by the validators.\nSince the number of the validators is bounded and their\nidentity is known (and the maximal size of allowed AccountData is bounded)\nthe global state that is distributed in the form of AccountData is bounded\nas well.\nFind more information in the docs [here](https://github.com/near/nearcore/blob/560f7fc8f4b3106e0d5d46050688610b1f104ac6/chain/client/src/client.rs#L2232)")), "tier1_accounts_keys": z.array(z.string()), "tier1_connections": z.array(z.object({ "account_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "addr": z.string(), "archival": z.boolean(), "block_hash": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "connection_established_time_millis": z.number().int().gte(0), "height": z.union([z.number().int().gte(0), z.null()]).optional(), "is_highest_block_invalid": z.boolean(), "is_outbound_peer": z.boolean(), "last_time_peer_requested_millis": z.number().int().gte(0), "last_time_received_message_millis": z.number().int().gte(0), "nonce": z.number().int().gte(0).describe("Connection nonce."), "peer_id": z.string(), "received_bytes_per_sec": z.number().int().gte(0), "sent_bytes_per_sec": z.number().int().gte(0), "tracked_shards": z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")) })) }), "sync_status": z.string() }), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Information about last blocks, network, epoch and chain & chunk info.").optional(), "genesis_hash": z.string().describe("Genesis hash of the chain."), "latest_protocol_version": z.number().int().gte(0).describe("Latest protocol version that this client supports."), "node_key": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Deprecated; same as `validator_public_key` which you should use instead.").optional(), "node_public_key": z.string().describe("Public key of the node."), "protocol_version": z.number().int().gte(0).describe("Currently active protocol version."), "rpc_addr": z.union([z.string().describe("Address for RPC server.  None if node doesn't have RPC endpoint enabled."), z.null().describe("Address for RPC server.  None if node doesn't have RPC endpoint enabled.")]).describe("Address for RPC server.  None if node doesn't have RPC endpoint enabled.").optional(), "sync_info": z.object({ "earliest_block_hash": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "earliest_block_height": z.union([z.number().int().gte(0), z.null()]).optional(), "earliest_block_time": z.union([z.string(), z.null()]).optional(), "epoch_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.string().describe("Epoch identifier -- wrapped hash, to make it easier to distinguish.\nEpochId of epoch T is the hash of last block in T-2\nEpochId of first two epochs is 0"), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "epoch_start_height": z.union([z.number().int().gte(0), z.null()]).optional(), "latest_block_hash": z.string(), "latest_block_height": z.number().int().gte(0), "latest_block_time": z.string(), "latest_state_root": z.string(), "syncing": z.boolean() }).describe("Sync status of the node."), "uptime_sec": z.number().int().describe("Uptime of the node."), "validator_account_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Validator id of the node").optional(), "validator_public_key": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Public key of the validator.").optional(), "validators": z.array(z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") })).describe("Current epoch validators."), "version": z.object({ "build": z.string(), "commit": z.string(), "rustc_version": z.string().default(""), "version": z.string() }).describe("Data structure for semver version and github tag or commit.").describe("Binary version.") })
export type RpcStatusResponse = z.infer<typeof RpcStatusResponse>


export const RpcTransactionResponse = z.record(z.any()).and(z.any().superRefine((x, ctx) => {
    const schemas = [z.intersection(z.object({ "final_execution_status": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("NONE").describe("Transaction is waiting to be included into the block"), z.literal("INCLUDED").describe("Transaction is included into the block. The block may be not finalized yet"), z.literal("EXECUTED_OPTIMISTIC").describe("Transaction is included into the block +\nAll non-refund transaction receipts finished their execution.\nThe corresponding blocks for tx and each receipt may be not finalized yet"), z.literal("INCLUDED_FINAL").describe("Transaction is included into finalized block"), z.literal("EXECUTED").describe("Transaction is included into finalized block +\nAll non-refund transaction receipts finished their execution.\nThe corresponding blocks for each receipt may be not finalized yet"), z.literal("FINAL").describe("Transaction is included into finalized block +\nExecution of all transaction receipts is finalized, including refund receipts")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }), z.object({ "receipts": z.array(z.object({ "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "priority": z.number().int().gte(0).default(0), "receipt": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "Action": z.object({ "actions": z.array(z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("CreateAccount"), z.object({ "DeployContract": z.object({ "code": z.string() }) }).strict(), z.object({ "FunctionCall": z.object({ "args": z.string().describe("This type is used to mark function arguments.\n\nNOTE: The main reason for this to exist (except the type-safety) is that the value is\ntransparently serialized and deserialized as a base64-encoded string when serde is used\n(serde_json)."), "deposit": z.string(), "gas": z.number().int().gte(0), "method_name": z.string() }) }).strict(), z.object({ "Transfer": z.object({ "deposit": z.string() }) }).strict(), z.object({ "Stake": z.object({ "public_key": z.string(), "stake": z.string() }) }).strict(), z.object({ "AddKey": z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("FullAccess"), z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "method_names": z.array(z.string()), "receiver_id": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the permission scope for an access key. Whether it is a function call or a full access key.") }).describe("Describes access key permission scope and nonce."), "public_key": z.string() }) }).strict(), z.object({ "DeleteKey": z.object({ "public_key": z.string() }) }).strict(), z.object({ "DeleteAccount": z.object({ "beneficiary_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "Delegate": z.object({ "delegate_action": z.object({ "actions": z.array(z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CreateAccount": z.record(z.any()).describe("Create account action") }).strict().describe("Create an (sub)account using a transaction `receiver_id` as an ID for\na new account ID must pass validation rules described here\n<https://nomicon.io/DataStructures/Account>."), z.object({ "DeployContract": z.object({ "code": z.string().describe("WebAssembly binary") }).describe("Deploy contract action") }).strict().describe("Sets a Wasm code to a receiver_id"), z.object({ "FunctionCall": z.object({ "args": z.string(), "deposit": z.string(), "gas": z.number().int().gte(0), "method_name": z.string() }) }).strict(), z.object({ "Transfer": z.object({ "deposit": z.string() }) }).strict(), z.object({ "Stake": z.object({ "public_key": z.string().describe("Validator key which will be used to sign transactions on behalf of signer_id"), "stake": z.string().describe("Amount of tokens to stake.") }).describe("An action which stakes signer_id tokens and setup's validator public key") }).strict(), z.object({ "AddKey": z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0).describe("Nonce for this access key, used for tx nonce generation. When access key is created, nonce\nis set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\nSee <https://github.com/near/nearcore/issues/3779> for more details."), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Allowance is a balance limit to use by this access key to pay for function call gas and\ntransaction fees. When this access key is used, both account balance and the allowance is\ndecreased by the same value.\n`None` means unlimited allowance.\nNOTE: To change or increase the allowance, the old access key needs to be deleted and a new\naccess key should be created.").optional(), "method_names": z.array(z.string()).describe("A list of method names that can be used. The access key only allows transactions with the\nfunction call of one of the given method names.\nEmpty list means any method name can be used."), "receiver_id": z.string().describe("The access key only allows transactions with the given receiver's account id.") }).describe("Grants limited permission to make transactions with FunctionCallActions\nThe permission can limit the allowed balance to be spent on the prepaid gas.\nIt also restrict the account ID of the receiver for this function call.\nIt also can restrict the method name for the allowed function calls.") }).strict(), z.literal("FullAccess").describe("Grants full access to the account.\nNOTE: It's used to replace account-level public keys.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Defines permissions for AccessKey").describe("Defines permissions for this access key.") }).describe("Access key provides limited access to an account. Each access key belongs to some account and\nis identified by a unique (within the account) public key. One account may have large number of\naccess keys. Access keys allow to act on behalf of the account by restricting transactions\nthat can be issued.\n`account_id,public_key` is a key in the state").describe("An access key with the permission"), "public_key": z.string().describe("A public key which will be associated with an access_key") }).describe("An action that adds key with public key associated") }).strict(), z.object({ "DeleteKey": z.object({ "public_key": z.string().describe("A public key associated with the access_key to be deleted.") }) }).strict(), z.object({ "DeleteAccount": z.object({ "beneficiary_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeployGlobalContract": z.object({ "code": z.string().describe("WebAssembly binary"), "deploy_mode": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("CodeHash").describe("Contract is deployed under its code hash.\nUsers will be able reference it by that hash.\nThis effectively makes the contract immutable."), z.literal("AccountId").describe("Contract is deployed under the owner account id.\nUsers will be able reference it by that account id.\nThis allows the owner to update the contract for all its users.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Deploy global contract action") }).strict(), z.object({ "UseGlobalContract": z.object({ "contract_identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Use global contract action") }).strict(), z.object({ "DeterministicStateInit": z.object({ "deposit": z.string(), "state_init": z.object({ "V1": z.object({ "code": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "data": z.record(z.string()) }) }).strict() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An Action that can be included in a transaction or receipt, excluding delegate actions. This type represents all possible action types except DelegateAction to prevent infinite recursion in meta-transactions.")).describe("List of actions to be executed.\n\nWith the meta transactions MVP defined in NEP-366, nested\nDelegateActions are not allowed. A separate type is used to enforce it."), "max_block_height": z.number().int().gte(0).describe("The maximal height of the block in the blockchain below which the given DelegateAction is valid."), "nonce": z.number().int().gte(0).describe("Nonce to ensure that the same delegate action is not sent twice by a\nrelayer and should match for given account's `public_key`.\nAfter this action is processed it will increment."), "public_key": z.string().describe("Public key used to sign this delegated action."), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("Receiver of the delegated actions."), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("Signer of the delegated actions") }).describe("This action allows to execute the inner actions behalf of the defined sender."), "signature": z.string() }) }).strict(), z.object({ "DeployGlobalContract": z.object({ "code": z.string() }) }).strict(), z.object({ "DeployGlobalContractByAccountId": z.object({ "code": z.string() }) }).strict(), z.object({ "UseGlobalContract": z.object({ "code_hash": z.string() }) }).strict(), z.object({ "UseGlobalContractByAccountId": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInit": z.object({ "code": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "hash": z.string() }).strict(), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "data": z.record(z.string()), "deposit": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })), "gas_price": z.string(), "input_data_ids": z.array(z.string()), "is_promise_yield": z.boolean().default(false), "output_data_receivers": z.array(z.object({ "data_id": z.string(), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") })), "refund_to": z.any().superRefine((x, ctx) => {
    const schemas = [z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "signer_public_key": z.string() }) }).strict(), z.object({ "Data": z.object({ "data": z.union([z.string(), z.null()]).default(null), "data_id": z.string(), "is_promise_resume": z.boolean().default(false) }) }).strict(), z.object({ "GlobalContractDistribution": z.object({ "already_delivered_shards": z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")), "code": z.string(), "id": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "target_shard": z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.") }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "receipt_id": z.string(), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") })).describe("Receipts generated from the transaction"), "receipts_outcome": z.array(z.object({ "block_hash": z.string(), "id": z.string(), "outcome": z.object({ "executor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("The id of the account on which the execution happens. For transaction this is signer_id,\nfor receipt this is receiver_id."), "gas_burnt": z.number().int().gte(0).describe("The amount of the gas burnt by the given transaction or receipt."), "logs": z.array(z.string()).describe("Logs from this transaction or receipt."), "metadata": z.object({ "gas_profile": z.union([z.array(z.object({ "cost": z.string(), "cost_category": z.string().describe("Either ACTION_COST or WASM_HOST_COST."), "gas_used": z.string() }).describe("Shows gas profile. More info [here](https://near.github.io/nearcore/architecture/gas/gas_profile.html?highlight=WASM_HOST_COST#example-transaction-gas-profile).")), z.null()]).optional(), "version": z.number().int().gte(0) }).describe("Execution metadata, versioned").default({"gas_profile":null,"version":1}), "receipt_ids": z.array(z.string()).describe("Receipt IDs generated by this transaction or receipt."), "status": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unknown").describe("The execution is pending or unknown."), z.object({ "Failure": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "ActionError": z.object({ "index": z.union([z.number().int().gte(0).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`"), z.null().describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`")]).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`").optional(), "kind": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccountAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage"), z.object({ "AccountDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when TX receiver_id doesn't exist (but action is not Action::CreateAccount)"), z.object({ "CreateAccountOnlyByRegistrar": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "registrar_account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A top-level account ID can only be created by registrar."), z.object({ "CreateAccountNotAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A newly created account must be under a namespace of the creator account"), z.object({ "ActorNoPermission": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "actor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\nor the first TX action is a `CreateAccount` action"), z.object({ "DeleteKeyDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("Account tries to remove an access key that doesn't exist"), z.object({ "AddKeyAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The public key is already used for an existing access key"), z.object({ "DeleteAccountStaking": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is staking and can not be deleted"), z.object({ "LackBalanceForState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which needs balance"), "amount": z.string().describe("Balance required to complete an action.") }) }).strict().describe("ActionReceipt can't be completed, because the remaining balance will not be enough to cover storage."), z.object({ "TriesToUnstake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is not yet staked, but tries to unstake"), z.object({ "TriesToStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "balance": z.string(), "locked": z.string(), "stake": z.string() }) }).strict().describe("The account doesn't have enough balance to increase the stake."), z.object({ "InsufficientStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "minimum_stake": z.string(), "stake": z.string() }) }).strict(), z.object({ "FunctionCallError": z.any().superRefine((x, ctx) => {
    const schemas = [z.enum(["WasmUnknownError","_EVMError"]), z.object({ "CompilationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "PrepareError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Serialization").describe("Error happened while serializing the module."), z.literal("Deserialization").describe("Error happened while deserializing the module."), z.literal("InternalMemoryDeclared").describe("Internal memory declaration has been found in the module."), z.literal("GasInstrumentation").describe("Gas instrumentation failed.\n\nThis most likely indicates the module isn't valid."), z.literal("StackHeightInstrumentation").describe("Stack instrumentation failed.\n\nThis  most likely indicates the module isn't valid."), z.literal("Instantiate").describe("Error happened during instantiation.\n\nThis might indicate that `start` function trapped, or module isn't\ninstantiable and/or un-linkable."), z.literal("Memory").describe("Error creating memory."), z.literal("TooManyFunctions").describe("Contract contains too many functions."), z.literal("TooManyLocals").describe("Contract contains too many locals."), z.literal("TooManyTables").describe("Contract contains too many tables."), z.literal("TooManyTableElements").describe("Contract contains too many table elements.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error that can occur while preparing or executing Wasm smart-contract.") }).strict(), z.object({ "WasmerCompileError": z.object({ "msg": z.string() }) }).strict().describe("This is for defense in depth.\nWe expect our runtime-independent preparation code to fully catch all invalid wasms,\nbut, if it ever misses something we’ll emit this error")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Wasm compilation error"), z.object({ "LinkError": z.object({ "msg": z.string() }) }).strict().describe("Wasm binary env link error\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "MethodResolveError": z.enum(["MethodEmptyName","MethodNotFound","MethodInvalidSignature"]) }).strict().describe("Import/export resolve error"), z.object({ "WasmTrap": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unreachable").describe("An `unreachable` opcode was executed."), z.literal("IncorrectCallIndirectSignature").describe("Call indirect incorrect signature trap."), z.literal("MemoryOutOfBounds").describe("Memory out of bounds trap."), z.literal("CallIndirectOOB").describe("Call indirect out of bounds trap."), z.literal("IllegalArithmetic").describe("An arithmetic exception, e.g. divided by zero."), z.literal("MisalignedAtomicAccess").describe("Misaligned atomic access trap."), z.literal("IndirectCallToNull").describe("Indirect call to null."), z.literal("StackOverflow").describe("Stack overflow."), z.literal("GenericTrap").describe("Generic trap.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("A kind of a trap happened during execution of a binary") }).strict().describe("A trap happened during execution of a binary\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "HostError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("BadUTF16").describe("String encoding is bad UTF-16 sequence"), z.literal("BadUTF8").describe("String encoding is bad UTF-8 sequence"), z.literal("GasExceeded").describe("Exceeded the prepaid gas"), z.literal("GasLimitExceeded").describe("Exceeded the maximum amount of gas allowed to burn per contract"), z.literal("BalanceExceeded").describe("Exceeded the account balance"), z.literal("EmptyMethodName").describe("Tried to call an empty method name"), z.object({ "GuestPanic": z.object({ "panic_msg": z.string() }) }).strict().describe("Smart contract panicked"), z.literal("IntegerOverflow").describe("IntegerOverflow happened during a contract execution"), z.object({ "InvalidPromiseIndex": z.object({ "promise_idx": z.number().int().gte(0) }) }).strict().describe("`promise_idx` does not correspond to existing promises"), z.literal("CannotAppendActionToJointPromise").describe("Actions can only be appended to non-joint promise."), z.literal("CannotReturnJointPromise").describe("Returning joint promise is currently prohibited"), z.object({ "InvalidPromiseResultIndex": z.object({ "result_idx": z.number().int().gte(0) }) }).strict().describe("Accessed invalid promise result index"), z.object({ "InvalidRegisterId": z.object({ "register_id": z.number().int().gte(0) }) }).strict().describe("Accessed invalid register id"), z.object({ "IteratorWasInvalidated": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie"), z.literal("MemoryAccessViolation").describe("Accessed memory outside the bounds"), z.object({ "InvalidReceiptIndex": z.object({ "receipt_index": z.number().int().gte(0) }) }).strict().describe("VM Logic returned an invalid receipt index"), z.object({ "InvalidIteratorIndex": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator index `iterator_index` does not exist"), z.literal("InvalidAccountId").describe("VM Logic returned an invalid account id"), z.literal("InvalidMethodName").describe("VM Logic returned an invalid method name"), z.literal("InvalidPublicKey").describe("VM Logic provided an invalid public key"), z.object({ "ProhibitedInView": z.object({ "method_name": z.string() }) }).strict().describe("`method_name` is not allowed in view calls"), z.object({ "NumberOfLogsExceeded": z.object({ "limit": z.number().int().gte(0) }) }).strict().describe("The total number of logs will exceed the limit."), z.object({ "KeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage key length exceeded the limit."), z.object({ "ValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage value length exceeded the limit."), z.object({ "TotalLogLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The total log length exceeded the limit."), z.object({ "NumberPromisesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_promises": z.number().int().gte(0) }) }).strict().describe("The maximum number of promises within a FunctionCall exceeded the limit."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The maximum number of input data dependencies exceeded the limit."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The returned value length exceeded the limit."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The contract size for DeployContract action exceeded the limit."), z.object({ "Deprecated": z.object({ "method_name": z.string() }) }).strict().describe("The host function was deprecated."), z.object({ "ECRecoverError": z.object({ "msg": z.string() }) }).strict().describe("General errors for ECDSA recover."), z.object({ "AltBn128InvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to alt_bn128 family of functions (e.g., point which isn't\non the curve)."), z.object({ "Ed25519VerifyInvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to ed25519 signature verification function (e.g. signature cannot be\nderived from bytes).")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Note: this is only to deserialize old data, use execution error for new data"), z.object({ "ExecutionError": z.string() }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Serializable version of `near-vm-runner::FunctionCallError`.\n\nMust never reorder/remove elements, can only add new variants at the end (but do that very\ncarefully). It describes stable serialization format, and only used by serialization logic.") }).strict().describe("An error occurred during a `FunctionCall` Action, parameter is debug message."), z.object({ "NewReceiptValidationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidPredecessorId": z.object({ "account_id": z.string() }) }).strict().describe("The `predecessor_id` of a Receipt is not valid."), z.object({ "InvalidReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a Receipt is not valid."), z.object({ "InvalidSignerId": z.object({ "account_id": z.string() }) }).strict().describe("The `signer_id` of an ActionReceipt is not valid."), z.object({ "InvalidDataReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a DataReceiver within an ActionReceipt is not valid."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the returned data exceeded the limit in a DataReceipt."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The number of input data dependencies exceeds the limit in an ActionReceipt."), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of an ActionReceipt."), z.object({ "ReceiptSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("Receipt is bigger than the limit."), z.object({ "InvalidRefundTo": z.object({ "account_id": z.string() }) }).strict().describe("The `refund_to` of an ActionReceipt is not valid.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a receipt.") }).strict().describe("Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\nreceipt validation."), z.object({ "OnlyImplicitAccountCreationAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\nSee NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\nAlso, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\nTODO(#8598): This error is named very poorly. A better name would be\n`OnlyNamedAccountCreationAllowed`."), z.object({ "DeleteAccountWithLargeState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Delete account whose state is large is temporarily banned."), z.literal("DelegateActionInvalidSignature").describe("Signature does not match the provided actions and given signer public key."), z.object({ "DelegateActionSenderDoesNotMatchTxReceiver": z.object({ "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Receiver of the transaction doesn't match Sender of the delegate action"), z.literal("DelegateActionExpired").describe("Delegate action has expired. `max_block_height` is less than actual block height."), z.object({ "DelegateActionAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("The given public key doesn't exist for Sender account"), z.object({ "DelegateActionInvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "delegate_nonce": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce must be greater sender[public_key].nonce"), z.object({ "DelegateActionNonceTooLarge": z.object({ "delegate_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce is larger than the upper bound given by the block height"), z.object({ "GlobalContractDoesNotExist": z.object({ "identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("The kind of ActionError happened") }).describe("An error happened during Action execution") }).strict().describe("An error happened during Action execution"), z.object({ "InvalidTxError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Happens if a wrong AccessKey used or AccessKey has not enough permissions"), z.object({ "InvalidSignerId": z.object({ "signer_id": z.string() }) }).strict().describe("TX signer_id is not a valid [`AccountId`]"), z.object({ "SignerDoesNotExist": z.object({ "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("TX signer_id is not found in a storage"), z.object({ "InvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "tx_nonce": z.number().int().gte(0) }) }).strict().describe("Transaction nonce must be strictly greater than `account[access_key].nonce`."), z.object({ "NonceTooLarge": z.object({ "tx_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("Transaction nonce is larger than the upper bound given by the block height"), z.object({ "InvalidReceiverId": z.object({ "receiver_id": z.string() }) }).strict().describe("TX receiver_id is not a valid AccountId"), z.literal("InvalidSignature").describe("TX signature is not valid"), z.object({ "NotEnoughBalance": z.object({ "balance": z.string(), "cost": z.string(), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account does not have enough balance to cover TX cost"), z.object({ "LackBalanceForState": z.object({ "amount": z.string().describe("Required balance to cover the state."), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which doesn't have enough balance to cover storage.") }) }).strict().describe("Signer account doesn't have enough balance after transaction."), z.literal("CostOverflow").describe("An integer overflow occurred during transaction cost estimation."), z.literal("InvalidChain").describe("Transaction parent block hash doesn't belong to the current chain"), z.literal("Expired").describe("Transaction has expired"), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of a Transaction."), z.object({ "TransactionSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of serialized transaction exceeded the limit."), z.literal("InvalidTransactionVersion").describe("Transaction version is invalid."), z.object({ "StorageError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("StorageInternalError").describe("Key-value db internal failure"), z.object({ "MissingTrieValue": z.object({ "context": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("TrieIterator").describe("Missing trie value when reading from TrieIterator."), z.literal("TriePrefetchingStorage").describe("Missing trie value when reading from TriePrefetchingStorage."), z.literal("TrieMemoryPartialStorage").describe("Missing trie value when reading from TrieMemoryPartialStorage."), z.literal("TrieStorage").describe("Missing trie value when reading from TrieStorage.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Contexts in which `StorageError::MissingTrieValue` error might occur."), "hash": z.string() }) }).strict().describe("Requested trie value by its hash which is missing in storage."), z.literal("UnexpectedTrieValue").describe("Found trie node which shouldn't be part of state. Raised during\nvalidation of state sync parts where incorrect node was passed.\nTODO (#8997): consider including hash of trie node."), z.object({ "StorageInconsistentState": z.string() }).strict().describe("Either invalid state or key-value db is corrupted.\nFor PartialStorage it cannot be corrupted.\nError message is unreliable and for debugging purposes only. It's also probably ok to\npanic in every place that produces this error.\nWe can check if db is corrupted by verifying everything in the state trie."), z.object({ "FlatStorageBlockNotSupported": z.string() }).strict().describe("Flat storage error, meaning that it doesn't support some block anymore.\nWe guarantee that such block cannot become final, thus block processing\nmust resume normally."), z.object({ "MemTrieLoadingError": z.string() }).strict().describe("In-memory trie could not be loaded for some reason.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Errors which may occur during working with trie storages, storing\ntrie values (trie nodes and state values) by their hashes.") }).strict(), z.object({ "ShardCongested": z.object({ "congestion_level": z.number().describe("A value between 0 (no congestion) and 1 (max congestion)."), "shard_id": z.number().int().gte(0).describe("The congested shard.") }) }).strict().describe("The receiver shard of the transaction is too congested to accept new\ntransactions at the moment."), z.object({ "ShardStuck": z.object({ "missed_chunks": z.number().int().gte(0).describe("The number of blocks since the last included chunk of the shard."), "shard_id": z.number().int().gte(0).describe("The shard that fails making progress.") }) }).strict().describe("The receiver shard of the transaction missed several chunks and rejects\nnew transaction until it can make progress again.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An error happened during TX execution") }).strict().describe("An error happened during Transaction execution")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error returned in the ExecutionOutcome in case of failure") }).strict().describe("The execution has failed."), z.object({ "SuccessValue": z.string() }).strict().describe("The final action succeeded and returned some value or an empty vec encoded in base64."), z.object({ "SuccessReceiptId": z.string() }).strict().describe("The final action of the receipt returned a promise or the signed transaction was converted\nto a receipt. Contains the receipt_id of the generated receipt.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Execution status. Contains the result in case of successful execution."), "tokens_burnt": z.string().describe("The amount of tokens burnt corresponding to the burnt gas amount.\nThis value doesn't always equal to the `gas_burnt` multiplied by the gas price, because\nthe prepaid gas price might be lower than the actual gas price and it creates a deficit.\n`tokens_burnt` also contains the penalty subtracted from refunds, while\n`gas_burnt` only contains the gas that we actually burn for the execution.") }), "proof": z.array(z.object({ "direction": z.enum(["Left","Right"]), "hash": z.string() })) })).describe("The execution outcome of receipts."), "status": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("NotStarted").describe("The execution has not yet started."), z.literal("Started").describe("The execution has started and still going."), z.object({ "Failure": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "ActionError": z.object({ "index": z.union([z.number().int().gte(0).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`"), z.null().describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`")]).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`").optional(), "kind": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccountAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage"), z.object({ "AccountDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when TX receiver_id doesn't exist (but action is not Action::CreateAccount)"), z.object({ "CreateAccountOnlyByRegistrar": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "registrar_account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A top-level account ID can only be created by registrar."), z.object({ "CreateAccountNotAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A newly created account must be under a namespace of the creator account"), z.object({ "ActorNoPermission": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "actor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\nor the first TX action is a `CreateAccount` action"), z.object({ "DeleteKeyDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("Account tries to remove an access key that doesn't exist"), z.object({ "AddKeyAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The public key is already used for an existing access key"), z.object({ "DeleteAccountStaking": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is staking and can not be deleted"), z.object({ "LackBalanceForState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which needs balance"), "amount": z.string().describe("Balance required to complete an action.") }) }).strict().describe("ActionReceipt can't be completed, because the remaining balance will not be enough to cover storage."), z.object({ "TriesToUnstake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is not yet staked, but tries to unstake"), z.object({ "TriesToStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "balance": z.string(), "locked": z.string(), "stake": z.string() }) }).strict().describe("The account doesn't have enough balance to increase the stake."), z.object({ "InsufficientStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "minimum_stake": z.string(), "stake": z.string() }) }).strict(), z.object({ "FunctionCallError": z.any().superRefine((x, ctx) => {
    const schemas = [z.enum(["WasmUnknownError","_EVMError"]), z.object({ "CompilationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "PrepareError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Serialization").describe("Error happened while serializing the module."), z.literal("Deserialization").describe("Error happened while deserializing the module."), z.literal("InternalMemoryDeclared").describe("Internal memory declaration has been found in the module."), z.literal("GasInstrumentation").describe("Gas instrumentation failed.\n\nThis most likely indicates the module isn't valid."), z.literal("StackHeightInstrumentation").describe("Stack instrumentation failed.\n\nThis  most likely indicates the module isn't valid."), z.literal("Instantiate").describe("Error happened during instantiation.\n\nThis might indicate that `start` function trapped, or module isn't\ninstantiable and/or un-linkable."), z.literal("Memory").describe("Error creating memory."), z.literal("TooManyFunctions").describe("Contract contains too many functions."), z.literal("TooManyLocals").describe("Contract contains too many locals."), z.literal("TooManyTables").describe("Contract contains too many tables."), z.literal("TooManyTableElements").describe("Contract contains too many table elements.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error that can occur while preparing or executing Wasm smart-contract.") }).strict(), z.object({ "WasmerCompileError": z.object({ "msg": z.string() }) }).strict().describe("This is for defense in depth.\nWe expect our runtime-independent preparation code to fully catch all invalid wasms,\nbut, if it ever misses something we’ll emit this error")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Wasm compilation error"), z.object({ "LinkError": z.object({ "msg": z.string() }) }).strict().describe("Wasm binary env link error\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "MethodResolveError": z.enum(["MethodEmptyName","MethodNotFound","MethodInvalidSignature"]) }).strict().describe("Import/export resolve error"), z.object({ "WasmTrap": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unreachable").describe("An `unreachable` opcode was executed."), z.literal("IncorrectCallIndirectSignature").describe("Call indirect incorrect signature trap."), z.literal("MemoryOutOfBounds").describe("Memory out of bounds trap."), z.literal("CallIndirectOOB").describe("Call indirect out of bounds trap."), z.literal("IllegalArithmetic").describe("An arithmetic exception, e.g. divided by zero."), z.literal("MisalignedAtomicAccess").describe("Misaligned atomic access trap."), z.literal("IndirectCallToNull").describe("Indirect call to null."), z.literal("StackOverflow").describe("Stack overflow."), z.literal("GenericTrap").describe("Generic trap.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("A kind of a trap happened during execution of a binary") }).strict().describe("A trap happened during execution of a binary\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "HostError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("BadUTF16").describe("String encoding is bad UTF-16 sequence"), z.literal("BadUTF8").describe("String encoding is bad UTF-8 sequence"), z.literal("GasExceeded").describe("Exceeded the prepaid gas"), z.literal("GasLimitExceeded").describe("Exceeded the maximum amount of gas allowed to burn per contract"), z.literal("BalanceExceeded").describe("Exceeded the account balance"), z.literal("EmptyMethodName").describe("Tried to call an empty method name"), z.object({ "GuestPanic": z.object({ "panic_msg": z.string() }) }).strict().describe("Smart contract panicked"), z.literal("IntegerOverflow").describe("IntegerOverflow happened during a contract execution"), z.object({ "InvalidPromiseIndex": z.object({ "promise_idx": z.number().int().gte(0) }) }).strict().describe("`promise_idx` does not correspond to existing promises"), z.literal("CannotAppendActionToJointPromise").describe("Actions can only be appended to non-joint promise."), z.literal("CannotReturnJointPromise").describe("Returning joint promise is currently prohibited"), z.object({ "InvalidPromiseResultIndex": z.object({ "result_idx": z.number().int().gte(0) }) }).strict().describe("Accessed invalid promise result index"), z.object({ "InvalidRegisterId": z.object({ "register_id": z.number().int().gte(0) }) }).strict().describe("Accessed invalid register id"), z.object({ "IteratorWasInvalidated": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie"), z.literal("MemoryAccessViolation").describe("Accessed memory outside the bounds"), z.object({ "InvalidReceiptIndex": z.object({ "receipt_index": z.number().int().gte(0) }) }).strict().describe("VM Logic returned an invalid receipt index"), z.object({ "InvalidIteratorIndex": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator index `iterator_index` does not exist"), z.literal("InvalidAccountId").describe("VM Logic returned an invalid account id"), z.literal("InvalidMethodName").describe("VM Logic returned an invalid method name"), z.literal("InvalidPublicKey").describe("VM Logic provided an invalid public key"), z.object({ "ProhibitedInView": z.object({ "method_name": z.string() }) }).strict().describe("`method_name` is not allowed in view calls"), z.object({ "NumberOfLogsExceeded": z.object({ "limit": z.number().int().gte(0) }) }).strict().describe("The total number of logs will exceed the limit."), z.object({ "KeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage key length exceeded the limit."), z.object({ "ValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage value length exceeded the limit."), z.object({ "TotalLogLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The total log length exceeded the limit."), z.object({ "NumberPromisesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_promises": z.number().int().gte(0) }) }).strict().describe("The maximum number of promises within a FunctionCall exceeded the limit."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The maximum number of input data dependencies exceeded the limit."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The returned value length exceeded the limit."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The contract size for DeployContract action exceeded the limit."), z.object({ "Deprecated": z.object({ "method_name": z.string() }) }).strict().describe("The host function was deprecated."), z.object({ "ECRecoverError": z.object({ "msg": z.string() }) }).strict().describe("General errors for ECDSA recover."), z.object({ "AltBn128InvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to alt_bn128 family of functions (e.g., point which isn't\non the curve)."), z.object({ "Ed25519VerifyInvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to ed25519 signature verification function (e.g. signature cannot be\nderived from bytes).")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Note: this is only to deserialize old data, use execution error for new data"), z.object({ "ExecutionError": z.string() }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Serializable version of `near-vm-runner::FunctionCallError`.\n\nMust never reorder/remove elements, can only add new variants at the end (but do that very\ncarefully). It describes stable serialization format, and only used by serialization logic.") }).strict().describe("An error occurred during a `FunctionCall` Action, parameter is debug message."), z.object({ "NewReceiptValidationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidPredecessorId": z.object({ "account_id": z.string() }) }).strict().describe("The `predecessor_id` of a Receipt is not valid."), z.object({ "InvalidReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a Receipt is not valid."), z.object({ "InvalidSignerId": z.object({ "account_id": z.string() }) }).strict().describe("The `signer_id` of an ActionReceipt is not valid."), z.object({ "InvalidDataReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a DataReceiver within an ActionReceipt is not valid."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the returned data exceeded the limit in a DataReceipt."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The number of input data dependencies exceeds the limit in an ActionReceipt."), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of an ActionReceipt."), z.object({ "ReceiptSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("Receipt is bigger than the limit."), z.object({ "InvalidRefundTo": z.object({ "account_id": z.string() }) }).strict().describe("The `refund_to` of an ActionReceipt is not valid.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a receipt.") }).strict().describe("Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\nreceipt validation."), z.object({ "OnlyImplicitAccountCreationAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\nSee NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\nAlso, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\nTODO(#8598): This error is named very poorly. A better name would be\n`OnlyNamedAccountCreationAllowed`."), z.object({ "DeleteAccountWithLargeState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Delete account whose state is large is temporarily banned."), z.literal("DelegateActionInvalidSignature").describe("Signature does not match the provided actions and given signer public key."), z.object({ "DelegateActionSenderDoesNotMatchTxReceiver": z.object({ "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Receiver of the transaction doesn't match Sender of the delegate action"), z.literal("DelegateActionExpired").describe("Delegate action has expired. `max_block_height` is less than actual block height."), z.object({ "DelegateActionAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("The given public key doesn't exist for Sender account"), z.object({ "DelegateActionInvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "delegate_nonce": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce must be greater sender[public_key].nonce"), z.object({ "DelegateActionNonceTooLarge": z.object({ "delegate_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce is larger than the upper bound given by the block height"), z.object({ "GlobalContractDoesNotExist": z.object({ "identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("The kind of ActionError happened") }).describe("An error happened during Action execution") }).strict().describe("An error happened during Action execution"), z.object({ "InvalidTxError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Happens if a wrong AccessKey used or AccessKey has not enough permissions"), z.object({ "InvalidSignerId": z.object({ "signer_id": z.string() }) }).strict().describe("TX signer_id is not a valid [`AccountId`]"), z.object({ "SignerDoesNotExist": z.object({ "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("TX signer_id is not found in a storage"), z.object({ "InvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "tx_nonce": z.number().int().gte(0) }) }).strict().describe("Transaction nonce must be strictly greater than `account[access_key].nonce`."), z.object({ "NonceTooLarge": z.object({ "tx_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("Transaction nonce is larger than the upper bound given by the block height"), z.object({ "InvalidReceiverId": z.object({ "receiver_id": z.string() }) }).strict().describe("TX receiver_id is not a valid AccountId"), z.literal("InvalidSignature").describe("TX signature is not valid"), z.object({ "NotEnoughBalance": z.object({ "balance": z.string(), "cost": z.string(), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account does not have enough balance to cover TX cost"), z.object({ "LackBalanceForState": z.object({ "amount": z.string().describe("Required balance to cover the state."), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which doesn't have enough balance to cover storage.") }) }).strict().describe("Signer account doesn't have enough balance after transaction."), z.literal("CostOverflow").describe("An integer overflow occurred during transaction cost estimation."), z.literal("InvalidChain").describe("Transaction parent block hash doesn't belong to the current chain"), z.literal("Expired").describe("Transaction has expired"), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of a Transaction."), z.object({ "TransactionSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of serialized transaction exceeded the limit."), z.literal("InvalidTransactionVersion").describe("Transaction version is invalid."), z.object({ "StorageError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("StorageInternalError").describe("Key-value db internal failure"), z.object({ "MissingTrieValue": z.object({ "context": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("TrieIterator").describe("Missing trie value when reading from TrieIterator."), z.literal("TriePrefetchingStorage").describe("Missing trie value when reading from TriePrefetchingStorage."), z.literal("TrieMemoryPartialStorage").describe("Missing trie value when reading from TrieMemoryPartialStorage."), z.literal("TrieStorage").describe("Missing trie value when reading from TrieStorage.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Contexts in which `StorageError::MissingTrieValue` error might occur."), "hash": z.string() }) }).strict().describe("Requested trie value by its hash which is missing in storage."), z.literal("UnexpectedTrieValue").describe("Found trie node which shouldn't be part of state. Raised during\nvalidation of state sync parts where incorrect node was passed.\nTODO (#8997): consider including hash of trie node."), z.object({ "StorageInconsistentState": z.string() }).strict().describe("Either invalid state or key-value db is corrupted.\nFor PartialStorage it cannot be corrupted.\nError message is unreliable and for debugging purposes only. It's also probably ok to\npanic in every place that produces this error.\nWe can check if db is corrupted by verifying everything in the state trie."), z.object({ "FlatStorageBlockNotSupported": z.string() }).strict().describe("Flat storage error, meaning that it doesn't support some block anymore.\nWe guarantee that such block cannot become final, thus block processing\nmust resume normally."), z.object({ "MemTrieLoadingError": z.string() }).strict().describe("In-memory trie could not be loaded for some reason.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Errors which may occur during working with trie storages, storing\ntrie values (trie nodes and state values) by their hashes.") }).strict(), z.object({ "ShardCongested": z.object({ "congestion_level": z.number().describe("A value between 0 (no congestion) and 1 (max congestion)."), "shard_id": z.number().int().gte(0).describe("The congested shard.") }) }).strict().describe("The receiver shard of the transaction is too congested to accept new\ntransactions at the moment."), z.object({ "ShardStuck": z.object({ "missed_chunks": z.number().int().gte(0).describe("The number of blocks since the last included chunk of the shard."), "shard_id": z.number().int().gte(0).describe("The shard that fails making progress.") }) }).strict().describe("The receiver shard of the transaction missed several chunks and rejects\nnew transaction until it can make progress again.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An error happened during TX execution") }).strict().describe("An error happened during Transaction execution")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error returned in the ExecutionOutcome in case of failure") }).strict().describe("The execution has failed with the given error."), z.object({ "SuccessValue": z.string() }).strict().describe("The execution has succeeded and returned some value or an empty vec encoded in base64.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Execution status defined by chain.rs:get_final_transaction_result\nFinalExecutionStatus::NotStarted - the tx is not converted to the receipt yet\nFinalExecutionStatus::Started - we have at least 1 receipt, but the first leaf receipt_id (using dfs) hasn't finished the execution\nFinalExecutionStatus::Failure - the result of the first leaf receipt_id\nFinalExecutionStatus::SuccessValue - the result of the first leaf receipt_id"), "transaction": z.object({ "actions": z.array(z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("CreateAccount"), z.object({ "DeployContract": z.object({ "code": z.string() }) }).strict(), z.object({ "FunctionCall": z.object({ "args": z.string().describe("This type is used to mark function arguments.\n\nNOTE: The main reason for this to exist (except the type-safety) is that the value is\ntransparently serialized and deserialized as a base64-encoded string when serde is used\n(serde_json)."), "deposit": z.string(), "gas": z.number().int().gte(0), "method_name": z.string() }) }).strict(), z.object({ "Transfer": z.object({ "deposit": z.string() }) }).strict(), z.object({ "Stake": z.object({ "public_key": z.string(), "stake": z.string() }) }).strict(), z.object({ "AddKey": z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("FullAccess"), z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "method_names": z.array(z.string()), "receiver_id": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the permission scope for an access key. Whether it is a function call or a full access key.") }).describe("Describes access key permission scope and nonce."), "public_key": z.string() }) }).strict(), z.object({ "DeleteKey": z.object({ "public_key": z.string() }) }).strict(), z.object({ "DeleteAccount": z.object({ "beneficiary_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "Delegate": z.object({ "delegate_action": z.object({ "actions": z.array(z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CreateAccount": z.record(z.any()).describe("Create account action") }).strict().describe("Create an (sub)account using a transaction `receiver_id` as an ID for\na new account ID must pass validation rules described here\n<https://nomicon.io/DataStructures/Account>."), z.object({ "DeployContract": z.object({ "code": z.string().describe("WebAssembly binary") }).describe("Deploy contract action") }).strict().describe("Sets a Wasm code to a receiver_id"), z.object({ "FunctionCall": z.object({ "args": z.string(), "deposit": z.string(), "gas": z.number().int().gte(0), "method_name": z.string() }) }).strict(), z.object({ "Transfer": z.object({ "deposit": z.string() }) }).strict(), z.object({ "Stake": z.object({ "public_key": z.string().describe("Validator key which will be used to sign transactions on behalf of signer_id"), "stake": z.string().describe("Amount of tokens to stake.") }).describe("An action which stakes signer_id tokens and setup's validator public key") }).strict(), z.object({ "AddKey": z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0).describe("Nonce for this access key, used for tx nonce generation. When access key is created, nonce\nis set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\nSee <https://github.com/near/nearcore/issues/3779> for more details."), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Allowance is a balance limit to use by this access key to pay for function call gas and\ntransaction fees. When this access key is used, both account balance and the allowance is\ndecreased by the same value.\n`None` means unlimited allowance.\nNOTE: To change or increase the allowance, the old access key needs to be deleted and a new\naccess key should be created.").optional(), "method_names": z.array(z.string()).describe("A list of method names that can be used. The access key only allows transactions with the\nfunction call of one of the given method names.\nEmpty list means any method name can be used."), "receiver_id": z.string().describe("The access key only allows transactions with the given receiver's account id.") }).describe("Grants limited permission to make transactions with FunctionCallActions\nThe permission can limit the allowed balance to be spent on the prepaid gas.\nIt also restrict the account ID of the receiver for this function call.\nIt also can restrict the method name for the allowed function calls.") }).strict(), z.literal("FullAccess").describe("Grants full access to the account.\nNOTE: It's used to replace account-level public keys.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Defines permissions for AccessKey").describe("Defines permissions for this access key.") }).describe("Access key provides limited access to an account. Each access key belongs to some account and\nis identified by a unique (within the account) public key. One account may have large number of\naccess keys. Access keys allow to act on behalf of the account by restricting transactions\nthat can be issued.\n`account_id,public_key` is a key in the state").describe("An access key with the permission"), "public_key": z.string().describe("A public key which will be associated with an access_key") }).describe("An action that adds key with public key associated") }).strict(), z.object({ "DeleteKey": z.object({ "public_key": z.string().describe("A public key associated with the access_key to be deleted.") }) }).strict(), z.object({ "DeleteAccount": z.object({ "beneficiary_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeployGlobalContract": z.object({ "code": z.string().describe("WebAssembly binary"), "deploy_mode": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("CodeHash").describe("Contract is deployed under its code hash.\nUsers will be able reference it by that hash.\nThis effectively makes the contract immutable."), z.literal("AccountId").describe("Contract is deployed under the owner account id.\nUsers will be able reference it by that account id.\nThis allows the owner to update the contract for all its users.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Deploy global contract action") }).strict(), z.object({ "UseGlobalContract": z.object({ "contract_identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Use global contract action") }).strict(), z.object({ "DeterministicStateInit": z.object({ "deposit": z.string(), "state_init": z.object({ "V1": z.object({ "code": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "data": z.record(z.string()) }) }).strict() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An Action that can be included in a transaction or receipt, excluding delegate actions. This type represents all possible action types except DelegateAction to prevent infinite recursion in meta-transactions.")).describe("List of actions to be executed.\n\nWith the meta transactions MVP defined in NEP-366, nested\nDelegateActions are not allowed. A separate type is used to enforce it."), "max_block_height": z.number().int().gte(0).describe("The maximal height of the block in the blockchain below which the given DelegateAction is valid."), "nonce": z.number().int().gte(0).describe("Nonce to ensure that the same delegate action is not sent twice by a\nrelayer and should match for given account's `public_key`.\nAfter this action is processed it will increment."), "public_key": z.string().describe("Public key used to sign this delegated action."), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("Receiver of the delegated actions."), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("Signer of the delegated actions") }).describe("This action allows to execute the inner actions behalf of the defined sender."), "signature": z.string() }) }).strict(), z.object({ "DeployGlobalContract": z.object({ "code": z.string() }) }).strict(), z.object({ "DeployGlobalContractByAccountId": z.object({ "code": z.string() }) }).strict(), z.object({ "UseGlobalContract": z.object({ "code_hash": z.string() }) }).strict(), z.object({ "UseGlobalContractByAccountId": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInit": z.object({ "code": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "hash": z.string() }).strict(), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "data": z.record(z.string()), "deposit": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })), "hash": z.string(), "nonce": z.number().int().gte(0), "priority_fee": z.number().int().gte(0).default(0), "public_key": z.string(), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "signature": z.string(), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).describe("Signed Transaction"), "transaction_outcome": z.object({ "block_hash": z.string(), "id": z.string(), "outcome": z.object({ "executor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("The id of the account on which the execution happens. For transaction this is signer_id,\nfor receipt this is receiver_id."), "gas_burnt": z.number().int().gte(0).describe("The amount of the gas burnt by the given transaction or receipt."), "logs": z.array(z.string()).describe("Logs from this transaction or receipt."), "metadata": z.object({ "gas_profile": z.union([z.array(z.object({ "cost": z.string(), "cost_category": z.string().describe("Either ACTION_COST or WASM_HOST_COST."), "gas_used": z.string() }).describe("Shows gas profile. More info [here](https://near.github.io/nearcore/architecture/gas/gas_profile.html?highlight=WASM_HOST_COST#example-transaction-gas-profile).")), z.null()]).optional(), "version": z.number().int().gte(0) }).describe("Execution metadata, versioned").default({"gas_profile":null,"version":1}), "receipt_ids": z.array(z.string()).describe("Receipt IDs generated by this transaction or receipt."), "status": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unknown").describe("The execution is pending or unknown."), z.object({ "Failure": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "ActionError": z.object({ "index": z.union([z.number().int().gte(0).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`"), z.null().describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`")]).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`").optional(), "kind": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccountAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage"), z.object({ "AccountDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when TX receiver_id doesn't exist (but action is not Action::CreateAccount)"), z.object({ "CreateAccountOnlyByRegistrar": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "registrar_account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A top-level account ID can only be created by registrar."), z.object({ "CreateAccountNotAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A newly created account must be under a namespace of the creator account"), z.object({ "ActorNoPermission": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "actor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\nor the first TX action is a `CreateAccount` action"), z.object({ "DeleteKeyDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("Account tries to remove an access key that doesn't exist"), z.object({ "AddKeyAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The public key is already used for an existing access key"), z.object({ "DeleteAccountStaking": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is staking and can not be deleted"), z.object({ "LackBalanceForState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which needs balance"), "amount": z.string().describe("Balance required to complete an action.") }) }).strict().describe("ActionReceipt can't be completed, because the remaining balance will not be enough to cover storage."), z.object({ "TriesToUnstake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is not yet staked, but tries to unstake"), z.object({ "TriesToStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "balance": z.string(), "locked": z.string(), "stake": z.string() }) }).strict().describe("The account doesn't have enough balance to increase the stake."), z.object({ "InsufficientStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "minimum_stake": z.string(), "stake": z.string() }) }).strict(), z.object({ "FunctionCallError": z.any().superRefine((x, ctx) => {
    const schemas = [z.enum(["WasmUnknownError","_EVMError"]), z.object({ "CompilationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "PrepareError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Serialization").describe("Error happened while serializing the module."), z.literal("Deserialization").describe("Error happened while deserializing the module."), z.literal("InternalMemoryDeclared").describe("Internal memory declaration has been found in the module."), z.literal("GasInstrumentation").describe("Gas instrumentation failed.\n\nThis most likely indicates the module isn't valid."), z.literal("StackHeightInstrumentation").describe("Stack instrumentation failed.\n\nThis  most likely indicates the module isn't valid."), z.literal("Instantiate").describe("Error happened during instantiation.\n\nThis might indicate that `start` function trapped, or module isn't\ninstantiable and/or un-linkable."), z.literal("Memory").describe("Error creating memory."), z.literal("TooManyFunctions").describe("Contract contains too many functions."), z.literal("TooManyLocals").describe("Contract contains too many locals."), z.literal("TooManyTables").describe("Contract contains too many tables."), z.literal("TooManyTableElements").describe("Contract contains too many table elements.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error that can occur while preparing or executing Wasm smart-contract.") }).strict(), z.object({ "WasmerCompileError": z.object({ "msg": z.string() }) }).strict().describe("This is for defense in depth.\nWe expect our runtime-independent preparation code to fully catch all invalid wasms,\nbut, if it ever misses something we’ll emit this error")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Wasm compilation error"), z.object({ "LinkError": z.object({ "msg": z.string() }) }).strict().describe("Wasm binary env link error\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "MethodResolveError": z.enum(["MethodEmptyName","MethodNotFound","MethodInvalidSignature"]) }).strict().describe("Import/export resolve error"), z.object({ "WasmTrap": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unreachable").describe("An `unreachable` opcode was executed."), z.literal("IncorrectCallIndirectSignature").describe("Call indirect incorrect signature trap."), z.literal("MemoryOutOfBounds").describe("Memory out of bounds trap."), z.literal("CallIndirectOOB").describe("Call indirect out of bounds trap."), z.literal("IllegalArithmetic").describe("An arithmetic exception, e.g. divided by zero."), z.literal("MisalignedAtomicAccess").describe("Misaligned atomic access trap."), z.literal("IndirectCallToNull").describe("Indirect call to null."), z.literal("StackOverflow").describe("Stack overflow."), z.literal("GenericTrap").describe("Generic trap.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("A kind of a trap happened during execution of a binary") }).strict().describe("A trap happened during execution of a binary\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "HostError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("BadUTF16").describe("String encoding is bad UTF-16 sequence"), z.literal("BadUTF8").describe("String encoding is bad UTF-8 sequence"), z.literal("GasExceeded").describe("Exceeded the prepaid gas"), z.literal("GasLimitExceeded").describe("Exceeded the maximum amount of gas allowed to burn per contract"), z.literal("BalanceExceeded").describe("Exceeded the account balance"), z.literal("EmptyMethodName").describe("Tried to call an empty method name"), z.object({ "GuestPanic": z.object({ "panic_msg": z.string() }) }).strict().describe("Smart contract panicked"), z.literal("IntegerOverflow").describe("IntegerOverflow happened during a contract execution"), z.object({ "InvalidPromiseIndex": z.object({ "promise_idx": z.number().int().gte(0) }) }).strict().describe("`promise_idx` does not correspond to existing promises"), z.literal("CannotAppendActionToJointPromise").describe("Actions can only be appended to non-joint promise."), z.literal("CannotReturnJointPromise").describe("Returning joint promise is currently prohibited"), z.object({ "InvalidPromiseResultIndex": z.object({ "result_idx": z.number().int().gte(0) }) }).strict().describe("Accessed invalid promise result index"), z.object({ "InvalidRegisterId": z.object({ "register_id": z.number().int().gte(0) }) }).strict().describe("Accessed invalid register id"), z.object({ "IteratorWasInvalidated": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie"), z.literal("MemoryAccessViolation").describe("Accessed memory outside the bounds"), z.object({ "InvalidReceiptIndex": z.object({ "receipt_index": z.number().int().gte(0) }) }).strict().describe("VM Logic returned an invalid receipt index"), z.object({ "InvalidIteratorIndex": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator index `iterator_index` does not exist"), z.literal("InvalidAccountId").describe("VM Logic returned an invalid account id"), z.literal("InvalidMethodName").describe("VM Logic returned an invalid method name"), z.literal("InvalidPublicKey").describe("VM Logic provided an invalid public key"), z.object({ "ProhibitedInView": z.object({ "method_name": z.string() }) }).strict().describe("`method_name` is not allowed in view calls"), z.object({ "NumberOfLogsExceeded": z.object({ "limit": z.number().int().gte(0) }) }).strict().describe("The total number of logs will exceed the limit."), z.object({ "KeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage key length exceeded the limit."), z.object({ "ValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage value length exceeded the limit."), z.object({ "TotalLogLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The total log length exceeded the limit."), z.object({ "NumberPromisesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_promises": z.number().int().gte(0) }) }).strict().describe("The maximum number of promises within a FunctionCall exceeded the limit."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The maximum number of input data dependencies exceeded the limit."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The returned value length exceeded the limit."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The contract size for DeployContract action exceeded the limit."), z.object({ "Deprecated": z.object({ "method_name": z.string() }) }).strict().describe("The host function was deprecated."), z.object({ "ECRecoverError": z.object({ "msg": z.string() }) }).strict().describe("General errors for ECDSA recover."), z.object({ "AltBn128InvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to alt_bn128 family of functions (e.g., point which isn't\non the curve)."), z.object({ "Ed25519VerifyInvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to ed25519 signature verification function (e.g. signature cannot be\nderived from bytes).")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Note: this is only to deserialize old data, use execution error for new data"), z.object({ "ExecutionError": z.string() }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Serializable version of `near-vm-runner::FunctionCallError`.\n\nMust never reorder/remove elements, can only add new variants at the end (but do that very\ncarefully). It describes stable serialization format, and only used by serialization logic.") }).strict().describe("An error occurred during a `FunctionCall` Action, parameter is debug message."), z.object({ "NewReceiptValidationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidPredecessorId": z.object({ "account_id": z.string() }) }).strict().describe("The `predecessor_id` of a Receipt is not valid."), z.object({ "InvalidReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a Receipt is not valid."), z.object({ "InvalidSignerId": z.object({ "account_id": z.string() }) }).strict().describe("The `signer_id` of an ActionReceipt is not valid."), z.object({ "InvalidDataReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a DataReceiver within an ActionReceipt is not valid."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the returned data exceeded the limit in a DataReceipt."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The number of input data dependencies exceeds the limit in an ActionReceipt."), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of an ActionReceipt."), z.object({ "ReceiptSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("Receipt is bigger than the limit."), z.object({ "InvalidRefundTo": z.object({ "account_id": z.string() }) }).strict().describe("The `refund_to` of an ActionReceipt is not valid.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a receipt.") }).strict().describe("Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\nreceipt validation."), z.object({ "OnlyImplicitAccountCreationAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\nSee NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\nAlso, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\nTODO(#8598): This error is named very poorly. A better name would be\n`OnlyNamedAccountCreationAllowed`."), z.object({ "DeleteAccountWithLargeState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Delete account whose state is large is temporarily banned."), z.literal("DelegateActionInvalidSignature").describe("Signature does not match the provided actions and given signer public key."), z.object({ "DelegateActionSenderDoesNotMatchTxReceiver": z.object({ "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Receiver of the transaction doesn't match Sender of the delegate action"), z.literal("DelegateActionExpired").describe("Delegate action has expired. `max_block_height` is less than actual block height."), z.object({ "DelegateActionAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("The given public key doesn't exist for Sender account"), z.object({ "DelegateActionInvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "delegate_nonce": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce must be greater sender[public_key].nonce"), z.object({ "DelegateActionNonceTooLarge": z.object({ "delegate_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce is larger than the upper bound given by the block height"), z.object({ "GlobalContractDoesNotExist": z.object({ "identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("The kind of ActionError happened") }).describe("An error happened during Action execution") }).strict().describe("An error happened during Action execution"), z.object({ "InvalidTxError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Happens if a wrong AccessKey used or AccessKey has not enough permissions"), z.object({ "InvalidSignerId": z.object({ "signer_id": z.string() }) }).strict().describe("TX signer_id is not a valid [`AccountId`]"), z.object({ "SignerDoesNotExist": z.object({ "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("TX signer_id is not found in a storage"), z.object({ "InvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "tx_nonce": z.number().int().gte(0) }) }).strict().describe("Transaction nonce must be strictly greater than `account[access_key].nonce`."), z.object({ "NonceTooLarge": z.object({ "tx_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("Transaction nonce is larger than the upper bound given by the block height"), z.object({ "InvalidReceiverId": z.object({ "receiver_id": z.string() }) }).strict().describe("TX receiver_id is not a valid AccountId"), z.literal("InvalidSignature").describe("TX signature is not valid"), z.object({ "NotEnoughBalance": z.object({ "balance": z.string(), "cost": z.string(), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account does not have enough balance to cover TX cost"), z.object({ "LackBalanceForState": z.object({ "amount": z.string().describe("Required balance to cover the state."), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which doesn't have enough balance to cover storage.") }) }).strict().describe("Signer account doesn't have enough balance after transaction."), z.literal("CostOverflow").describe("An integer overflow occurred during transaction cost estimation."), z.literal("InvalidChain").describe("Transaction parent block hash doesn't belong to the current chain"), z.literal("Expired").describe("Transaction has expired"), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of a Transaction."), z.object({ "TransactionSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of serialized transaction exceeded the limit."), z.literal("InvalidTransactionVersion").describe("Transaction version is invalid."), z.object({ "StorageError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("StorageInternalError").describe("Key-value db internal failure"), z.object({ "MissingTrieValue": z.object({ "context": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("TrieIterator").describe("Missing trie value when reading from TrieIterator."), z.literal("TriePrefetchingStorage").describe("Missing trie value when reading from TriePrefetchingStorage."), z.literal("TrieMemoryPartialStorage").describe("Missing trie value when reading from TrieMemoryPartialStorage."), z.literal("TrieStorage").describe("Missing trie value when reading from TrieStorage.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Contexts in which `StorageError::MissingTrieValue` error might occur."), "hash": z.string() }) }).strict().describe("Requested trie value by its hash which is missing in storage."), z.literal("UnexpectedTrieValue").describe("Found trie node which shouldn't be part of state. Raised during\nvalidation of state sync parts where incorrect node was passed.\nTODO (#8997): consider including hash of trie node."), z.object({ "StorageInconsistentState": z.string() }).strict().describe("Either invalid state or key-value db is corrupted.\nFor PartialStorage it cannot be corrupted.\nError message is unreliable and for debugging purposes only. It's also probably ok to\npanic in every place that produces this error.\nWe can check if db is corrupted by verifying everything in the state trie."), z.object({ "FlatStorageBlockNotSupported": z.string() }).strict().describe("Flat storage error, meaning that it doesn't support some block anymore.\nWe guarantee that such block cannot become final, thus block processing\nmust resume normally."), z.object({ "MemTrieLoadingError": z.string() }).strict().describe("In-memory trie could not be loaded for some reason.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Errors which may occur during working with trie storages, storing\ntrie values (trie nodes and state values) by their hashes.") }).strict(), z.object({ "ShardCongested": z.object({ "congestion_level": z.number().describe("A value between 0 (no congestion) and 1 (max congestion)."), "shard_id": z.number().int().gte(0).describe("The congested shard.") }) }).strict().describe("The receiver shard of the transaction is too congested to accept new\ntransactions at the moment."), z.object({ "ShardStuck": z.object({ "missed_chunks": z.number().int().gte(0).describe("The number of blocks since the last included chunk of the shard."), "shard_id": z.number().int().gte(0).describe("The shard that fails making progress.") }) }).strict().describe("The receiver shard of the transaction missed several chunks and rejects\nnew transaction until it can make progress again.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An error happened during TX execution") }).strict().describe("An error happened during Transaction execution")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error returned in the ExecutionOutcome in case of failure") }).strict().describe("The execution has failed."), z.object({ "SuccessValue": z.string() }).strict().describe("The final action succeeded and returned some value or an empty vec encoded in base64."), z.object({ "SuccessReceiptId": z.string() }).strict().describe("The final action of the receipt returned a promise or the signed transaction was converted\nto a receipt. Contains the receipt_id of the generated receipt.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Execution status. Contains the result in case of successful execution."), "tokens_burnt": z.string().describe("The amount of tokens burnt corresponding to the burnt gas amount.\nThis value doesn't always equal to the `gas_burnt` multiplied by the gas price, because\nthe prepaid gas price might be lower than the actual gas price and it creates a deficit.\n`tokens_burnt` also contains the penalty subtracted from refunds, while\n`gas_burnt` only contains the gas that we actually burn for the execution.") }), "proof": z.array(z.object({ "direction": z.enum(["Left","Right"]), "hash": z.string() })) }).describe("The execution outcome of the signed transaction.") }).describe("Final execution outcome of the transaction and all of subsequent the receipts. Also includes\nthe generated receipt.")), z.intersection(z.object({ "final_execution_status": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("NONE").describe("Transaction is waiting to be included into the block"), z.literal("INCLUDED").describe("Transaction is included into the block. The block may be not finalized yet"), z.literal("EXECUTED_OPTIMISTIC").describe("Transaction is included into the block +\nAll non-refund transaction receipts finished their execution.\nThe corresponding blocks for tx and each receipt may be not finalized yet"), z.literal("INCLUDED_FINAL").describe("Transaction is included into finalized block"), z.literal("EXECUTED").describe("Transaction is included into finalized block +\nAll non-refund transaction receipts finished their execution.\nThe corresponding blocks for each receipt may be not finalized yet"), z.literal("FINAL").describe("Transaction is included into finalized block +\nExecution of all transaction receipts is finalized, including refund receipts")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }), z.object({ "receipts_outcome": z.array(z.object({ "block_hash": z.string(), "id": z.string(), "outcome": z.object({ "executor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("The id of the account on which the execution happens. For transaction this is signer_id,\nfor receipt this is receiver_id."), "gas_burnt": z.number().int().gte(0).describe("The amount of the gas burnt by the given transaction or receipt."), "logs": z.array(z.string()).describe("Logs from this transaction or receipt."), "metadata": z.object({ "gas_profile": z.union([z.array(z.object({ "cost": z.string(), "cost_category": z.string().describe("Either ACTION_COST or WASM_HOST_COST."), "gas_used": z.string() }).describe("Shows gas profile. More info [here](https://near.github.io/nearcore/architecture/gas/gas_profile.html?highlight=WASM_HOST_COST#example-transaction-gas-profile).")), z.null()]).optional(), "version": z.number().int().gte(0) }).describe("Execution metadata, versioned").default({"gas_profile":null,"version":1}), "receipt_ids": z.array(z.string()).describe("Receipt IDs generated by this transaction or receipt."), "status": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unknown").describe("The execution is pending or unknown."), z.object({ "Failure": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "ActionError": z.object({ "index": z.union([z.number().int().gte(0).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`"), z.null().describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`")]).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`").optional(), "kind": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccountAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage"), z.object({ "AccountDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when TX receiver_id doesn't exist (but action is not Action::CreateAccount)"), z.object({ "CreateAccountOnlyByRegistrar": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "registrar_account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A top-level account ID can only be created by registrar."), z.object({ "CreateAccountNotAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A newly created account must be under a namespace of the creator account"), z.object({ "ActorNoPermission": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "actor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\nor the first TX action is a `CreateAccount` action"), z.object({ "DeleteKeyDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("Account tries to remove an access key that doesn't exist"), z.object({ "AddKeyAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The public key is already used for an existing access key"), z.object({ "DeleteAccountStaking": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is staking and can not be deleted"), z.object({ "LackBalanceForState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which needs balance"), "amount": z.string().describe("Balance required to complete an action.") }) }).strict().describe("ActionReceipt can't be completed, because the remaining balance will not be enough to cover storage."), z.object({ "TriesToUnstake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is not yet staked, but tries to unstake"), z.object({ "TriesToStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "balance": z.string(), "locked": z.string(), "stake": z.string() }) }).strict().describe("The account doesn't have enough balance to increase the stake."), z.object({ "InsufficientStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "minimum_stake": z.string(), "stake": z.string() }) }).strict(), z.object({ "FunctionCallError": z.any().superRefine((x, ctx) => {
    const schemas = [z.enum(["WasmUnknownError","_EVMError"]), z.object({ "CompilationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "PrepareError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Serialization").describe("Error happened while serializing the module."), z.literal("Deserialization").describe("Error happened while deserializing the module."), z.literal("InternalMemoryDeclared").describe("Internal memory declaration has been found in the module."), z.literal("GasInstrumentation").describe("Gas instrumentation failed.\n\nThis most likely indicates the module isn't valid."), z.literal("StackHeightInstrumentation").describe("Stack instrumentation failed.\n\nThis  most likely indicates the module isn't valid."), z.literal("Instantiate").describe("Error happened during instantiation.\n\nThis might indicate that `start` function trapped, or module isn't\ninstantiable and/or un-linkable."), z.literal("Memory").describe("Error creating memory."), z.literal("TooManyFunctions").describe("Contract contains too many functions."), z.literal("TooManyLocals").describe("Contract contains too many locals."), z.literal("TooManyTables").describe("Contract contains too many tables."), z.literal("TooManyTableElements").describe("Contract contains too many table elements.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error that can occur while preparing or executing Wasm smart-contract.") }).strict(), z.object({ "WasmerCompileError": z.object({ "msg": z.string() }) }).strict().describe("This is for defense in depth.\nWe expect our runtime-independent preparation code to fully catch all invalid wasms,\nbut, if it ever misses something we’ll emit this error")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Wasm compilation error"), z.object({ "LinkError": z.object({ "msg": z.string() }) }).strict().describe("Wasm binary env link error\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "MethodResolveError": z.enum(["MethodEmptyName","MethodNotFound","MethodInvalidSignature"]) }).strict().describe("Import/export resolve error"), z.object({ "WasmTrap": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unreachable").describe("An `unreachable` opcode was executed."), z.literal("IncorrectCallIndirectSignature").describe("Call indirect incorrect signature trap."), z.literal("MemoryOutOfBounds").describe("Memory out of bounds trap."), z.literal("CallIndirectOOB").describe("Call indirect out of bounds trap."), z.literal("IllegalArithmetic").describe("An arithmetic exception, e.g. divided by zero."), z.literal("MisalignedAtomicAccess").describe("Misaligned atomic access trap."), z.literal("IndirectCallToNull").describe("Indirect call to null."), z.literal("StackOverflow").describe("Stack overflow."), z.literal("GenericTrap").describe("Generic trap.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("A kind of a trap happened during execution of a binary") }).strict().describe("A trap happened during execution of a binary\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "HostError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("BadUTF16").describe("String encoding is bad UTF-16 sequence"), z.literal("BadUTF8").describe("String encoding is bad UTF-8 sequence"), z.literal("GasExceeded").describe("Exceeded the prepaid gas"), z.literal("GasLimitExceeded").describe("Exceeded the maximum amount of gas allowed to burn per contract"), z.literal("BalanceExceeded").describe("Exceeded the account balance"), z.literal("EmptyMethodName").describe("Tried to call an empty method name"), z.object({ "GuestPanic": z.object({ "panic_msg": z.string() }) }).strict().describe("Smart contract panicked"), z.literal("IntegerOverflow").describe("IntegerOverflow happened during a contract execution"), z.object({ "InvalidPromiseIndex": z.object({ "promise_idx": z.number().int().gte(0) }) }).strict().describe("`promise_idx` does not correspond to existing promises"), z.literal("CannotAppendActionToJointPromise").describe("Actions can only be appended to non-joint promise."), z.literal("CannotReturnJointPromise").describe("Returning joint promise is currently prohibited"), z.object({ "InvalidPromiseResultIndex": z.object({ "result_idx": z.number().int().gte(0) }) }).strict().describe("Accessed invalid promise result index"), z.object({ "InvalidRegisterId": z.object({ "register_id": z.number().int().gte(0) }) }).strict().describe("Accessed invalid register id"), z.object({ "IteratorWasInvalidated": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie"), z.literal("MemoryAccessViolation").describe("Accessed memory outside the bounds"), z.object({ "InvalidReceiptIndex": z.object({ "receipt_index": z.number().int().gte(0) }) }).strict().describe("VM Logic returned an invalid receipt index"), z.object({ "InvalidIteratorIndex": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator index `iterator_index` does not exist"), z.literal("InvalidAccountId").describe("VM Logic returned an invalid account id"), z.literal("InvalidMethodName").describe("VM Logic returned an invalid method name"), z.literal("InvalidPublicKey").describe("VM Logic provided an invalid public key"), z.object({ "ProhibitedInView": z.object({ "method_name": z.string() }) }).strict().describe("`method_name` is not allowed in view calls"), z.object({ "NumberOfLogsExceeded": z.object({ "limit": z.number().int().gte(0) }) }).strict().describe("The total number of logs will exceed the limit."), z.object({ "KeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage key length exceeded the limit."), z.object({ "ValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage value length exceeded the limit."), z.object({ "TotalLogLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The total log length exceeded the limit."), z.object({ "NumberPromisesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_promises": z.number().int().gte(0) }) }).strict().describe("The maximum number of promises within a FunctionCall exceeded the limit."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The maximum number of input data dependencies exceeded the limit."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The returned value length exceeded the limit."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The contract size for DeployContract action exceeded the limit."), z.object({ "Deprecated": z.object({ "method_name": z.string() }) }).strict().describe("The host function was deprecated."), z.object({ "ECRecoverError": z.object({ "msg": z.string() }) }).strict().describe("General errors for ECDSA recover."), z.object({ "AltBn128InvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to alt_bn128 family of functions (e.g., point which isn't\non the curve)."), z.object({ "Ed25519VerifyInvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to ed25519 signature verification function (e.g. signature cannot be\nderived from bytes).")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Note: this is only to deserialize old data, use execution error for new data"), z.object({ "ExecutionError": z.string() }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Serializable version of `near-vm-runner::FunctionCallError`.\n\nMust never reorder/remove elements, can only add new variants at the end (but do that very\ncarefully). It describes stable serialization format, and only used by serialization logic.") }).strict().describe("An error occurred during a `FunctionCall` Action, parameter is debug message."), z.object({ "NewReceiptValidationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidPredecessorId": z.object({ "account_id": z.string() }) }).strict().describe("The `predecessor_id` of a Receipt is not valid."), z.object({ "InvalidReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a Receipt is not valid."), z.object({ "InvalidSignerId": z.object({ "account_id": z.string() }) }).strict().describe("The `signer_id` of an ActionReceipt is not valid."), z.object({ "InvalidDataReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a DataReceiver within an ActionReceipt is not valid."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the returned data exceeded the limit in a DataReceipt."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The number of input data dependencies exceeds the limit in an ActionReceipt."), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of an ActionReceipt."), z.object({ "ReceiptSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("Receipt is bigger than the limit."), z.object({ "InvalidRefundTo": z.object({ "account_id": z.string() }) }).strict().describe("The `refund_to` of an ActionReceipt is not valid.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a receipt.") }).strict().describe("Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\nreceipt validation."), z.object({ "OnlyImplicitAccountCreationAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\nSee NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\nAlso, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\nTODO(#8598): This error is named very poorly. A better name would be\n`OnlyNamedAccountCreationAllowed`."), z.object({ "DeleteAccountWithLargeState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Delete account whose state is large is temporarily banned."), z.literal("DelegateActionInvalidSignature").describe("Signature does not match the provided actions and given signer public key."), z.object({ "DelegateActionSenderDoesNotMatchTxReceiver": z.object({ "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Receiver of the transaction doesn't match Sender of the delegate action"), z.literal("DelegateActionExpired").describe("Delegate action has expired. `max_block_height` is less than actual block height."), z.object({ "DelegateActionAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("The given public key doesn't exist for Sender account"), z.object({ "DelegateActionInvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "delegate_nonce": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce must be greater sender[public_key].nonce"), z.object({ "DelegateActionNonceTooLarge": z.object({ "delegate_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce is larger than the upper bound given by the block height"), z.object({ "GlobalContractDoesNotExist": z.object({ "identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("The kind of ActionError happened") }).describe("An error happened during Action execution") }).strict().describe("An error happened during Action execution"), z.object({ "InvalidTxError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Happens if a wrong AccessKey used or AccessKey has not enough permissions"), z.object({ "InvalidSignerId": z.object({ "signer_id": z.string() }) }).strict().describe("TX signer_id is not a valid [`AccountId`]"), z.object({ "SignerDoesNotExist": z.object({ "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("TX signer_id is not found in a storage"), z.object({ "InvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "tx_nonce": z.number().int().gte(0) }) }).strict().describe("Transaction nonce must be strictly greater than `account[access_key].nonce`."), z.object({ "NonceTooLarge": z.object({ "tx_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("Transaction nonce is larger than the upper bound given by the block height"), z.object({ "InvalidReceiverId": z.object({ "receiver_id": z.string() }) }).strict().describe("TX receiver_id is not a valid AccountId"), z.literal("InvalidSignature").describe("TX signature is not valid"), z.object({ "NotEnoughBalance": z.object({ "balance": z.string(), "cost": z.string(), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account does not have enough balance to cover TX cost"), z.object({ "LackBalanceForState": z.object({ "amount": z.string().describe("Required balance to cover the state."), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which doesn't have enough balance to cover storage.") }) }).strict().describe("Signer account doesn't have enough balance after transaction."), z.literal("CostOverflow").describe("An integer overflow occurred during transaction cost estimation."), z.literal("InvalidChain").describe("Transaction parent block hash doesn't belong to the current chain"), z.literal("Expired").describe("Transaction has expired"), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of a Transaction."), z.object({ "TransactionSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of serialized transaction exceeded the limit."), z.literal("InvalidTransactionVersion").describe("Transaction version is invalid."), z.object({ "StorageError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("StorageInternalError").describe("Key-value db internal failure"), z.object({ "MissingTrieValue": z.object({ "context": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("TrieIterator").describe("Missing trie value when reading from TrieIterator."), z.literal("TriePrefetchingStorage").describe("Missing trie value when reading from TriePrefetchingStorage."), z.literal("TrieMemoryPartialStorage").describe("Missing trie value when reading from TrieMemoryPartialStorage."), z.literal("TrieStorage").describe("Missing trie value when reading from TrieStorage.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Contexts in which `StorageError::MissingTrieValue` error might occur."), "hash": z.string() }) }).strict().describe("Requested trie value by its hash which is missing in storage."), z.literal("UnexpectedTrieValue").describe("Found trie node which shouldn't be part of state. Raised during\nvalidation of state sync parts where incorrect node was passed.\nTODO (#8997): consider including hash of trie node."), z.object({ "StorageInconsistentState": z.string() }).strict().describe("Either invalid state or key-value db is corrupted.\nFor PartialStorage it cannot be corrupted.\nError message is unreliable and for debugging purposes only. It's also probably ok to\npanic in every place that produces this error.\nWe can check if db is corrupted by verifying everything in the state trie."), z.object({ "FlatStorageBlockNotSupported": z.string() }).strict().describe("Flat storage error, meaning that it doesn't support some block anymore.\nWe guarantee that such block cannot become final, thus block processing\nmust resume normally."), z.object({ "MemTrieLoadingError": z.string() }).strict().describe("In-memory trie could not be loaded for some reason.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Errors which may occur during working with trie storages, storing\ntrie values (trie nodes and state values) by their hashes.") }).strict(), z.object({ "ShardCongested": z.object({ "congestion_level": z.number().describe("A value between 0 (no congestion) and 1 (max congestion)."), "shard_id": z.number().int().gte(0).describe("The congested shard.") }) }).strict().describe("The receiver shard of the transaction is too congested to accept new\ntransactions at the moment."), z.object({ "ShardStuck": z.object({ "missed_chunks": z.number().int().gte(0).describe("The number of blocks since the last included chunk of the shard."), "shard_id": z.number().int().gte(0).describe("The shard that fails making progress.") }) }).strict().describe("The receiver shard of the transaction missed several chunks and rejects\nnew transaction until it can make progress again.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An error happened during TX execution") }).strict().describe("An error happened during Transaction execution")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error returned in the ExecutionOutcome in case of failure") }).strict().describe("The execution has failed."), z.object({ "SuccessValue": z.string() }).strict().describe("The final action succeeded and returned some value or an empty vec encoded in base64."), z.object({ "SuccessReceiptId": z.string() }).strict().describe("The final action of the receipt returned a promise or the signed transaction was converted\nto a receipt. Contains the receipt_id of the generated receipt.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Execution status. Contains the result in case of successful execution."), "tokens_burnt": z.string().describe("The amount of tokens burnt corresponding to the burnt gas amount.\nThis value doesn't always equal to the `gas_burnt` multiplied by the gas price, because\nthe prepaid gas price might be lower than the actual gas price and it creates a deficit.\n`tokens_burnt` also contains the penalty subtracted from refunds, while\n`gas_burnt` only contains the gas that we actually burn for the execution.") }), "proof": z.array(z.object({ "direction": z.enum(["Left","Right"]), "hash": z.string() })) })).describe("The execution outcome of receipts."), "status": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("NotStarted").describe("The execution has not yet started."), z.literal("Started").describe("The execution has started and still going."), z.object({ "Failure": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "ActionError": z.object({ "index": z.union([z.number().int().gte(0).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`"), z.null().describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`")]).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`").optional(), "kind": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccountAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage"), z.object({ "AccountDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when TX receiver_id doesn't exist (but action is not Action::CreateAccount)"), z.object({ "CreateAccountOnlyByRegistrar": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "registrar_account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A top-level account ID can only be created by registrar."), z.object({ "CreateAccountNotAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A newly created account must be under a namespace of the creator account"), z.object({ "ActorNoPermission": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "actor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\nor the first TX action is a `CreateAccount` action"), z.object({ "DeleteKeyDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("Account tries to remove an access key that doesn't exist"), z.object({ "AddKeyAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The public key is already used for an existing access key"), z.object({ "DeleteAccountStaking": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is staking and can not be deleted"), z.object({ "LackBalanceForState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which needs balance"), "amount": z.string().describe("Balance required to complete an action.") }) }).strict().describe("ActionReceipt can't be completed, because the remaining balance will not be enough to cover storage."), z.object({ "TriesToUnstake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is not yet staked, but tries to unstake"), z.object({ "TriesToStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "balance": z.string(), "locked": z.string(), "stake": z.string() }) }).strict().describe("The account doesn't have enough balance to increase the stake."), z.object({ "InsufficientStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "minimum_stake": z.string(), "stake": z.string() }) }).strict(), z.object({ "FunctionCallError": z.any().superRefine((x, ctx) => {
    const schemas = [z.enum(["WasmUnknownError","_EVMError"]), z.object({ "CompilationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "PrepareError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Serialization").describe("Error happened while serializing the module."), z.literal("Deserialization").describe("Error happened while deserializing the module."), z.literal("InternalMemoryDeclared").describe("Internal memory declaration has been found in the module."), z.literal("GasInstrumentation").describe("Gas instrumentation failed.\n\nThis most likely indicates the module isn't valid."), z.literal("StackHeightInstrumentation").describe("Stack instrumentation failed.\n\nThis  most likely indicates the module isn't valid."), z.literal("Instantiate").describe("Error happened during instantiation.\n\nThis might indicate that `start` function trapped, or module isn't\ninstantiable and/or un-linkable."), z.literal("Memory").describe("Error creating memory."), z.literal("TooManyFunctions").describe("Contract contains too many functions."), z.literal("TooManyLocals").describe("Contract contains too many locals."), z.literal("TooManyTables").describe("Contract contains too many tables."), z.literal("TooManyTableElements").describe("Contract contains too many table elements.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error that can occur while preparing or executing Wasm smart-contract.") }).strict(), z.object({ "WasmerCompileError": z.object({ "msg": z.string() }) }).strict().describe("This is for defense in depth.\nWe expect our runtime-independent preparation code to fully catch all invalid wasms,\nbut, if it ever misses something we’ll emit this error")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Wasm compilation error"), z.object({ "LinkError": z.object({ "msg": z.string() }) }).strict().describe("Wasm binary env link error\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "MethodResolveError": z.enum(["MethodEmptyName","MethodNotFound","MethodInvalidSignature"]) }).strict().describe("Import/export resolve error"), z.object({ "WasmTrap": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unreachable").describe("An `unreachable` opcode was executed."), z.literal("IncorrectCallIndirectSignature").describe("Call indirect incorrect signature trap."), z.literal("MemoryOutOfBounds").describe("Memory out of bounds trap."), z.literal("CallIndirectOOB").describe("Call indirect out of bounds trap."), z.literal("IllegalArithmetic").describe("An arithmetic exception, e.g. divided by zero."), z.literal("MisalignedAtomicAccess").describe("Misaligned atomic access trap."), z.literal("IndirectCallToNull").describe("Indirect call to null."), z.literal("StackOverflow").describe("Stack overflow."), z.literal("GenericTrap").describe("Generic trap.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("A kind of a trap happened during execution of a binary") }).strict().describe("A trap happened during execution of a binary\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "HostError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("BadUTF16").describe("String encoding is bad UTF-16 sequence"), z.literal("BadUTF8").describe("String encoding is bad UTF-8 sequence"), z.literal("GasExceeded").describe("Exceeded the prepaid gas"), z.literal("GasLimitExceeded").describe("Exceeded the maximum amount of gas allowed to burn per contract"), z.literal("BalanceExceeded").describe("Exceeded the account balance"), z.literal("EmptyMethodName").describe("Tried to call an empty method name"), z.object({ "GuestPanic": z.object({ "panic_msg": z.string() }) }).strict().describe("Smart contract panicked"), z.literal("IntegerOverflow").describe("IntegerOverflow happened during a contract execution"), z.object({ "InvalidPromiseIndex": z.object({ "promise_idx": z.number().int().gte(0) }) }).strict().describe("`promise_idx` does not correspond to existing promises"), z.literal("CannotAppendActionToJointPromise").describe("Actions can only be appended to non-joint promise."), z.literal("CannotReturnJointPromise").describe("Returning joint promise is currently prohibited"), z.object({ "InvalidPromiseResultIndex": z.object({ "result_idx": z.number().int().gte(0) }) }).strict().describe("Accessed invalid promise result index"), z.object({ "InvalidRegisterId": z.object({ "register_id": z.number().int().gte(0) }) }).strict().describe("Accessed invalid register id"), z.object({ "IteratorWasInvalidated": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie"), z.literal("MemoryAccessViolation").describe("Accessed memory outside the bounds"), z.object({ "InvalidReceiptIndex": z.object({ "receipt_index": z.number().int().gte(0) }) }).strict().describe("VM Logic returned an invalid receipt index"), z.object({ "InvalidIteratorIndex": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator index `iterator_index` does not exist"), z.literal("InvalidAccountId").describe("VM Logic returned an invalid account id"), z.literal("InvalidMethodName").describe("VM Logic returned an invalid method name"), z.literal("InvalidPublicKey").describe("VM Logic provided an invalid public key"), z.object({ "ProhibitedInView": z.object({ "method_name": z.string() }) }).strict().describe("`method_name` is not allowed in view calls"), z.object({ "NumberOfLogsExceeded": z.object({ "limit": z.number().int().gte(0) }) }).strict().describe("The total number of logs will exceed the limit."), z.object({ "KeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage key length exceeded the limit."), z.object({ "ValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage value length exceeded the limit."), z.object({ "TotalLogLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The total log length exceeded the limit."), z.object({ "NumberPromisesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_promises": z.number().int().gte(0) }) }).strict().describe("The maximum number of promises within a FunctionCall exceeded the limit."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The maximum number of input data dependencies exceeded the limit."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The returned value length exceeded the limit."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The contract size for DeployContract action exceeded the limit."), z.object({ "Deprecated": z.object({ "method_name": z.string() }) }).strict().describe("The host function was deprecated."), z.object({ "ECRecoverError": z.object({ "msg": z.string() }) }).strict().describe("General errors for ECDSA recover."), z.object({ "AltBn128InvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to alt_bn128 family of functions (e.g., point which isn't\non the curve)."), z.object({ "Ed25519VerifyInvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to ed25519 signature verification function (e.g. signature cannot be\nderived from bytes).")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Note: this is only to deserialize old data, use execution error for new data"), z.object({ "ExecutionError": z.string() }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Serializable version of `near-vm-runner::FunctionCallError`.\n\nMust never reorder/remove elements, can only add new variants at the end (but do that very\ncarefully). It describes stable serialization format, and only used by serialization logic.") }).strict().describe("An error occurred during a `FunctionCall` Action, parameter is debug message."), z.object({ "NewReceiptValidationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidPredecessorId": z.object({ "account_id": z.string() }) }).strict().describe("The `predecessor_id` of a Receipt is not valid."), z.object({ "InvalidReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a Receipt is not valid."), z.object({ "InvalidSignerId": z.object({ "account_id": z.string() }) }).strict().describe("The `signer_id` of an ActionReceipt is not valid."), z.object({ "InvalidDataReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a DataReceiver within an ActionReceipt is not valid."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the returned data exceeded the limit in a DataReceipt."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The number of input data dependencies exceeds the limit in an ActionReceipt."), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of an ActionReceipt."), z.object({ "ReceiptSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("Receipt is bigger than the limit."), z.object({ "InvalidRefundTo": z.object({ "account_id": z.string() }) }).strict().describe("The `refund_to` of an ActionReceipt is not valid.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a receipt.") }).strict().describe("Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\nreceipt validation."), z.object({ "OnlyImplicitAccountCreationAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\nSee NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\nAlso, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\nTODO(#8598): This error is named very poorly. A better name would be\n`OnlyNamedAccountCreationAllowed`."), z.object({ "DeleteAccountWithLargeState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Delete account whose state is large is temporarily banned."), z.literal("DelegateActionInvalidSignature").describe("Signature does not match the provided actions and given signer public key."), z.object({ "DelegateActionSenderDoesNotMatchTxReceiver": z.object({ "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Receiver of the transaction doesn't match Sender of the delegate action"), z.literal("DelegateActionExpired").describe("Delegate action has expired. `max_block_height` is less than actual block height."), z.object({ "DelegateActionAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("The given public key doesn't exist for Sender account"), z.object({ "DelegateActionInvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "delegate_nonce": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce must be greater sender[public_key].nonce"), z.object({ "DelegateActionNonceTooLarge": z.object({ "delegate_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce is larger than the upper bound given by the block height"), z.object({ "GlobalContractDoesNotExist": z.object({ "identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("The kind of ActionError happened") }).describe("An error happened during Action execution") }).strict().describe("An error happened during Action execution"), z.object({ "InvalidTxError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Happens if a wrong AccessKey used or AccessKey has not enough permissions"), z.object({ "InvalidSignerId": z.object({ "signer_id": z.string() }) }).strict().describe("TX signer_id is not a valid [`AccountId`]"), z.object({ "SignerDoesNotExist": z.object({ "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("TX signer_id is not found in a storage"), z.object({ "InvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "tx_nonce": z.number().int().gte(0) }) }).strict().describe("Transaction nonce must be strictly greater than `account[access_key].nonce`."), z.object({ "NonceTooLarge": z.object({ "tx_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("Transaction nonce is larger than the upper bound given by the block height"), z.object({ "InvalidReceiverId": z.object({ "receiver_id": z.string() }) }).strict().describe("TX receiver_id is not a valid AccountId"), z.literal("InvalidSignature").describe("TX signature is not valid"), z.object({ "NotEnoughBalance": z.object({ "balance": z.string(), "cost": z.string(), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account does not have enough balance to cover TX cost"), z.object({ "LackBalanceForState": z.object({ "amount": z.string().describe("Required balance to cover the state."), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which doesn't have enough balance to cover storage.") }) }).strict().describe("Signer account doesn't have enough balance after transaction."), z.literal("CostOverflow").describe("An integer overflow occurred during transaction cost estimation."), z.literal("InvalidChain").describe("Transaction parent block hash doesn't belong to the current chain"), z.literal("Expired").describe("Transaction has expired"), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of a Transaction."), z.object({ "TransactionSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of serialized transaction exceeded the limit."), z.literal("InvalidTransactionVersion").describe("Transaction version is invalid."), z.object({ "StorageError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("StorageInternalError").describe("Key-value db internal failure"), z.object({ "MissingTrieValue": z.object({ "context": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("TrieIterator").describe("Missing trie value when reading from TrieIterator."), z.literal("TriePrefetchingStorage").describe("Missing trie value when reading from TriePrefetchingStorage."), z.literal("TrieMemoryPartialStorage").describe("Missing trie value when reading from TrieMemoryPartialStorage."), z.literal("TrieStorage").describe("Missing trie value when reading from TrieStorage.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Contexts in which `StorageError::MissingTrieValue` error might occur."), "hash": z.string() }) }).strict().describe("Requested trie value by its hash which is missing in storage."), z.literal("UnexpectedTrieValue").describe("Found trie node which shouldn't be part of state. Raised during\nvalidation of state sync parts where incorrect node was passed.\nTODO (#8997): consider including hash of trie node."), z.object({ "StorageInconsistentState": z.string() }).strict().describe("Either invalid state or key-value db is corrupted.\nFor PartialStorage it cannot be corrupted.\nError message is unreliable and for debugging purposes only. It's also probably ok to\npanic in every place that produces this error.\nWe can check if db is corrupted by verifying everything in the state trie."), z.object({ "FlatStorageBlockNotSupported": z.string() }).strict().describe("Flat storage error, meaning that it doesn't support some block anymore.\nWe guarantee that such block cannot become final, thus block processing\nmust resume normally."), z.object({ "MemTrieLoadingError": z.string() }).strict().describe("In-memory trie could not be loaded for some reason.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Errors which may occur during working with trie storages, storing\ntrie values (trie nodes and state values) by their hashes.") }).strict(), z.object({ "ShardCongested": z.object({ "congestion_level": z.number().describe("A value between 0 (no congestion) and 1 (max congestion)."), "shard_id": z.number().int().gte(0).describe("The congested shard.") }) }).strict().describe("The receiver shard of the transaction is too congested to accept new\ntransactions at the moment."), z.object({ "ShardStuck": z.object({ "missed_chunks": z.number().int().gte(0).describe("The number of blocks since the last included chunk of the shard."), "shard_id": z.number().int().gte(0).describe("The shard that fails making progress.") }) }).strict().describe("The receiver shard of the transaction missed several chunks and rejects\nnew transaction until it can make progress again.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An error happened during TX execution") }).strict().describe("An error happened during Transaction execution")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error returned in the ExecutionOutcome in case of failure") }).strict().describe("The execution has failed with the given error."), z.object({ "SuccessValue": z.string() }).strict().describe("The execution has succeeded and returned some value or an empty vec encoded in base64.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Execution status defined by chain.rs:get_final_transaction_result\nFinalExecutionStatus::NotStarted - the tx is not converted to the receipt yet\nFinalExecutionStatus::Started - we have at least 1 receipt, but the first leaf receipt_id (using dfs) hasn't finished the execution\nFinalExecutionStatus::Failure - the result of the first leaf receipt_id\nFinalExecutionStatus::SuccessValue - the result of the first leaf receipt_id"), "transaction": z.object({ "actions": z.array(z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("CreateAccount"), z.object({ "DeployContract": z.object({ "code": z.string() }) }).strict(), z.object({ "FunctionCall": z.object({ "args": z.string().describe("This type is used to mark function arguments.\n\nNOTE: The main reason for this to exist (except the type-safety) is that the value is\ntransparently serialized and deserialized as a base64-encoded string when serde is used\n(serde_json)."), "deposit": z.string(), "gas": z.number().int().gte(0), "method_name": z.string() }) }).strict(), z.object({ "Transfer": z.object({ "deposit": z.string() }) }).strict(), z.object({ "Stake": z.object({ "public_key": z.string(), "stake": z.string() }) }).strict(), z.object({ "AddKey": z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("FullAccess"), z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "method_names": z.array(z.string()), "receiver_id": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the permission scope for an access key. Whether it is a function call or a full access key.") }).describe("Describes access key permission scope and nonce."), "public_key": z.string() }) }).strict(), z.object({ "DeleteKey": z.object({ "public_key": z.string() }) }).strict(), z.object({ "DeleteAccount": z.object({ "beneficiary_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "Delegate": z.object({ "delegate_action": z.object({ "actions": z.array(z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CreateAccount": z.record(z.any()).describe("Create account action") }).strict().describe("Create an (sub)account using a transaction `receiver_id` as an ID for\na new account ID must pass validation rules described here\n<https://nomicon.io/DataStructures/Account>."), z.object({ "DeployContract": z.object({ "code": z.string().describe("WebAssembly binary") }).describe("Deploy contract action") }).strict().describe("Sets a Wasm code to a receiver_id"), z.object({ "FunctionCall": z.object({ "args": z.string(), "deposit": z.string(), "gas": z.number().int().gte(0), "method_name": z.string() }) }).strict(), z.object({ "Transfer": z.object({ "deposit": z.string() }) }).strict(), z.object({ "Stake": z.object({ "public_key": z.string().describe("Validator key which will be used to sign transactions on behalf of signer_id"), "stake": z.string().describe("Amount of tokens to stake.") }).describe("An action which stakes signer_id tokens and setup's validator public key") }).strict(), z.object({ "AddKey": z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0).describe("Nonce for this access key, used for tx nonce generation. When access key is created, nonce\nis set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\nSee <https://github.com/near/nearcore/issues/3779> for more details."), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Allowance is a balance limit to use by this access key to pay for function call gas and\ntransaction fees. When this access key is used, both account balance and the allowance is\ndecreased by the same value.\n`None` means unlimited allowance.\nNOTE: To change or increase the allowance, the old access key needs to be deleted and a new\naccess key should be created.").optional(), "method_names": z.array(z.string()).describe("A list of method names that can be used. The access key only allows transactions with the\nfunction call of one of the given method names.\nEmpty list means any method name can be used."), "receiver_id": z.string().describe("The access key only allows transactions with the given receiver's account id.") }).describe("Grants limited permission to make transactions with FunctionCallActions\nThe permission can limit the allowed balance to be spent on the prepaid gas.\nIt also restrict the account ID of the receiver for this function call.\nIt also can restrict the method name for the allowed function calls.") }).strict(), z.literal("FullAccess").describe("Grants full access to the account.\nNOTE: It's used to replace account-level public keys.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Defines permissions for AccessKey").describe("Defines permissions for this access key.") }).describe("Access key provides limited access to an account. Each access key belongs to some account and\nis identified by a unique (within the account) public key. One account may have large number of\naccess keys. Access keys allow to act on behalf of the account by restricting transactions\nthat can be issued.\n`account_id,public_key` is a key in the state").describe("An access key with the permission"), "public_key": z.string().describe("A public key which will be associated with an access_key") }).describe("An action that adds key with public key associated") }).strict(), z.object({ "DeleteKey": z.object({ "public_key": z.string().describe("A public key associated with the access_key to be deleted.") }) }).strict(), z.object({ "DeleteAccount": z.object({ "beneficiary_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeployGlobalContract": z.object({ "code": z.string().describe("WebAssembly binary"), "deploy_mode": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("CodeHash").describe("Contract is deployed under its code hash.\nUsers will be able reference it by that hash.\nThis effectively makes the contract immutable."), z.literal("AccountId").describe("Contract is deployed under the owner account id.\nUsers will be able reference it by that account id.\nThis allows the owner to update the contract for all its users.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Deploy global contract action") }).strict(), z.object({ "UseGlobalContract": z.object({ "contract_identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Use global contract action") }).strict(), z.object({ "DeterministicStateInit": z.object({ "deposit": z.string(), "state_init": z.object({ "V1": z.object({ "code": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "data": z.record(z.string()) }) }).strict() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An Action that can be included in a transaction or receipt, excluding delegate actions. This type represents all possible action types except DelegateAction to prevent infinite recursion in meta-transactions.")).describe("List of actions to be executed.\n\nWith the meta transactions MVP defined in NEP-366, nested\nDelegateActions are not allowed. A separate type is used to enforce it."), "max_block_height": z.number().int().gte(0).describe("The maximal height of the block in the blockchain below which the given DelegateAction is valid."), "nonce": z.number().int().gte(0).describe("Nonce to ensure that the same delegate action is not sent twice by a\nrelayer and should match for given account's `public_key`.\nAfter this action is processed it will increment."), "public_key": z.string().describe("Public key used to sign this delegated action."), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("Receiver of the delegated actions."), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("Signer of the delegated actions") }).describe("This action allows to execute the inner actions behalf of the defined sender."), "signature": z.string() }) }).strict(), z.object({ "DeployGlobalContract": z.object({ "code": z.string() }) }).strict(), z.object({ "DeployGlobalContractByAccountId": z.object({ "code": z.string() }) }).strict(), z.object({ "UseGlobalContract": z.object({ "code_hash": z.string() }) }).strict(), z.object({ "UseGlobalContractByAccountId": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInit": z.object({ "code": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "hash": z.string() }).strict(), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "data": z.record(z.string()), "deposit": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })), "hash": z.string(), "nonce": z.number().int().gte(0), "priority_fee": z.number().int().gte(0).default(0), "public_key": z.string(), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "signature": z.string(), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).describe("Signed Transaction"), "transaction_outcome": z.object({ "block_hash": z.string(), "id": z.string(), "outcome": z.object({ "executor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("The id of the account on which the execution happens. For transaction this is signer_id,\nfor receipt this is receiver_id."), "gas_burnt": z.number().int().gte(0).describe("The amount of the gas burnt by the given transaction or receipt."), "logs": z.array(z.string()).describe("Logs from this transaction or receipt."), "metadata": z.object({ "gas_profile": z.union([z.array(z.object({ "cost": z.string(), "cost_category": z.string().describe("Either ACTION_COST or WASM_HOST_COST."), "gas_used": z.string() }).describe("Shows gas profile. More info [here](https://near.github.io/nearcore/architecture/gas/gas_profile.html?highlight=WASM_HOST_COST#example-transaction-gas-profile).")), z.null()]).optional(), "version": z.number().int().gte(0) }).describe("Execution metadata, versioned").default({"gas_profile":null,"version":1}), "receipt_ids": z.array(z.string()).describe("Receipt IDs generated by this transaction or receipt."), "status": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unknown").describe("The execution is pending or unknown."), z.object({ "Failure": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "ActionError": z.object({ "index": z.union([z.number().int().gte(0).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`"), z.null().describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`")]).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`").optional(), "kind": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccountAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage"), z.object({ "AccountDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when TX receiver_id doesn't exist (but action is not Action::CreateAccount)"), z.object({ "CreateAccountOnlyByRegistrar": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "registrar_account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A top-level account ID can only be created by registrar."), z.object({ "CreateAccountNotAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A newly created account must be under a namespace of the creator account"), z.object({ "ActorNoPermission": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "actor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\nor the first TX action is a `CreateAccount` action"), z.object({ "DeleteKeyDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("Account tries to remove an access key that doesn't exist"), z.object({ "AddKeyAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The public key is already used for an existing access key"), z.object({ "DeleteAccountStaking": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is staking and can not be deleted"), z.object({ "LackBalanceForState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which needs balance"), "amount": z.string().describe("Balance required to complete an action.") }) }).strict().describe("ActionReceipt can't be completed, because the remaining balance will not be enough to cover storage."), z.object({ "TriesToUnstake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is not yet staked, but tries to unstake"), z.object({ "TriesToStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "balance": z.string(), "locked": z.string(), "stake": z.string() }) }).strict().describe("The account doesn't have enough balance to increase the stake."), z.object({ "InsufficientStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "minimum_stake": z.string(), "stake": z.string() }) }).strict(), z.object({ "FunctionCallError": z.any().superRefine((x, ctx) => {
    const schemas = [z.enum(["WasmUnknownError","_EVMError"]), z.object({ "CompilationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "PrepareError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Serialization").describe("Error happened while serializing the module."), z.literal("Deserialization").describe("Error happened while deserializing the module."), z.literal("InternalMemoryDeclared").describe("Internal memory declaration has been found in the module."), z.literal("GasInstrumentation").describe("Gas instrumentation failed.\n\nThis most likely indicates the module isn't valid."), z.literal("StackHeightInstrumentation").describe("Stack instrumentation failed.\n\nThis  most likely indicates the module isn't valid."), z.literal("Instantiate").describe("Error happened during instantiation.\n\nThis might indicate that `start` function trapped, or module isn't\ninstantiable and/or un-linkable."), z.literal("Memory").describe("Error creating memory."), z.literal("TooManyFunctions").describe("Contract contains too many functions."), z.literal("TooManyLocals").describe("Contract contains too many locals."), z.literal("TooManyTables").describe("Contract contains too many tables."), z.literal("TooManyTableElements").describe("Contract contains too many table elements.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error that can occur while preparing or executing Wasm smart-contract.") }).strict(), z.object({ "WasmerCompileError": z.object({ "msg": z.string() }) }).strict().describe("This is for defense in depth.\nWe expect our runtime-independent preparation code to fully catch all invalid wasms,\nbut, if it ever misses something we’ll emit this error")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Wasm compilation error"), z.object({ "LinkError": z.object({ "msg": z.string() }) }).strict().describe("Wasm binary env link error\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "MethodResolveError": z.enum(["MethodEmptyName","MethodNotFound","MethodInvalidSignature"]) }).strict().describe("Import/export resolve error"), z.object({ "WasmTrap": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unreachable").describe("An `unreachable` opcode was executed."), z.literal("IncorrectCallIndirectSignature").describe("Call indirect incorrect signature trap."), z.literal("MemoryOutOfBounds").describe("Memory out of bounds trap."), z.literal("CallIndirectOOB").describe("Call indirect out of bounds trap."), z.literal("IllegalArithmetic").describe("An arithmetic exception, e.g. divided by zero."), z.literal("MisalignedAtomicAccess").describe("Misaligned atomic access trap."), z.literal("IndirectCallToNull").describe("Indirect call to null."), z.literal("StackOverflow").describe("Stack overflow."), z.literal("GenericTrap").describe("Generic trap.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("A kind of a trap happened during execution of a binary") }).strict().describe("A trap happened during execution of a binary\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "HostError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("BadUTF16").describe("String encoding is bad UTF-16 sequence"), z.literal("BadUTF8").describe("String encoding is bad UTF-8 sequence"), z.literal("GasExceeded").describe("Exceeded the prepaid gas"), z.literal("GasLimitExceeded").describe("Exceeded the maximum amount of gas allowed to burn per contract"), z.literal("BalanceExceeded").describe("Exceeded the account balance"), z.literal("EmptyMethodName").describe("Tried to call an empty method name"), z.object({ "GuestPanic": z.object({ "panic_msg": z.string() }) }).strict().describe("Smart contract panicked"), z.literal("IntegerOverflow").describe("IntegerOverflow happened during a contract execution"), z.object({ "InvalidPromiseIndex": z.object({ "promise_idx": z.number().int().gte(0) }) }).strict().describe("`promise_idx` does not correspond to existing promises"), z.literal("CannotAppendActionToJointPromise").describe("Actions can only be appended to non-joint promise."), z.literal("CannotReturnJointPromise").describe("Returning joint promise is currently prohibited"), z.object({ "InvalidPromiseResultIndex": z.object({ "result_idx": z.number().int().gte(0) }) }).strict().describe("Accessed invalid promise result index"), z.object({ "InvalidRegisterId": z.object({ "register_id": z.number().int().gte(0) }) }).strict().describe("Accessed invalid register id"), z.object({ "IteratorWasInvalidated": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie"), z.literal("MemoryAccessViolation").describe("Accessed memory outside the bounds"), z.object({ "InvalidReceiptIndex": z.object({ "receipt_index": z.number().int().gte(0) }) }).strict().describe("VM Logic returned an invalid receipt index"), z.object({ "InvalidIteratorIndex": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator index `iterator_index` does not exist"), z.literal("InvalidAccountId").describe("VM Logic returned an invalid account id"), z.literal("InvalidMethodName").describe("VM Logic returned an invalid method name"), z.literal("InvalidPublicKey").describe("VM Logic provided an invalid public key"), z.object({ "ProhibitedInView": z.object({ "method_name": z.string() }) }).strict().describe("`method_name` is not allowed in view calls"), z.object({ "NumberOfLogsExceeded": z.object({ "limit": z.number().int().gte(0) }) }).strict().describe("The total number of logs will exceed the limit."), z.object({ "KeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage key length exceeded the limit."), z.object({ "ValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage value length exceeded the limit."), z.object({ "TotalLogLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The total log length exceeded the limit."), z.object({ "NumberPromisesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_promises": z.number().int().gte(0) }) }).strict().describe("The maximum number of promises within a FunctionCall exceeded the limit."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The maximum number of input data dependencies exceeded the limit."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The returned value length exceeded the limit."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The contract size for DeployContract action exceeded the limit."), z.object({ "Deprecated": z.object({ "method_name": z.string() }) }).strict().describe("The host function was deprecated."), z.object({ "ECRecoverError": z.object({ "msg": z.string() }) }).strict().describe("General errors for ECDSA recover."), z.object({ "AltBn128InvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to alt_bn128 family of functions (e.g., point which isn't\non the curve)."), z.object({ "Ed25519VerifyInvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to ed25519 signature verification function (e.g. signature cannot be\nderived from bytes).")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Note: this is only to deserialize old data, use execution error for new data"), z.object({ "ExecutionError": z.string() }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Serializable version of `near-vm-runner::FunctionCallError`.\n\nMust never reorder/remove elements, can only add new variants at the end (but do that very\ncarefully). It describes stable serialization format, and only used by serialization logic.") }).strict().describe("An error occurred during a `FunctionCall` Action, parameter is debug message."), z.object({ "NewReceiptValidationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidPredecessorId": z.object({ "account_id": z.string() }) }).strict().describe("The `predecessor_id` of a Receipt is not valid."), z.object({ "InvalidReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a Receipt is not valid."), z.object({ "InvalidSignerId": z.object({ "account_id": z.string() }) }).strict().describe("The `signer_id` of an ActionReceipt is not valid."), z.object({ "InvalidDataReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a DataReceiver within an ActionReceipt is not valid."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the returned data exceeded the limit in a DataReceipt."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The number of input data dependencies exceeds the limit in an ActionReceipt."), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of an ActionReceipt."), z.object({ "ReceiptSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("Receipt is bigger than the limit."), z.object({ "InvalidRefundTo": z.object({ "account_id": z.string() }) }).strict().describe("The `refund_to` of an ActionReceipt is not valid.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a receipt.") }).strict().describe("Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\nreceipt validation."), z.object({ "OnlyImplicitAccountCreationAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\nSee NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\nAlso, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\nTODO(#8598): This error is named very poorly. A better name would be\n`OnlyNamedAccountCreationAllowed`."), z.object({ "DeleteAccountWithLargeState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Delete account whose state is large is temporarily banned."), z.literal("DelegateActionInvalidSignature").describe("Signature does not match the provided actions and given signer public key."), z.object({ "DelegateActionSenderDoesNotMatchTxReceiver": z.object({ "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Receiver of the transaction doesn't match Sender of the delegate action"), z.literal("DelegateActionExpired").describe("Delegate action has expired. `max_block_height` is less than actual block height."), z.object({ "DelegateActionAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("The given public key doesn't exist for Sender account"), z.object({ "DelegateActionInvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "delegate_nonce": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce must be greater sender[public_key].nonce"), z.object({ "DelegateActionNonceTooLarge": z.object({ "delegate_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce is larger than the upper bound given by the block height"), z.object({ "GlobalContractDoesNotExist": z.object({ "identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("The kind of ActionError happened") }).describe("An error happened during Action execution") }).strict().describe("An error happened during Action execution"), z.object({ "InvalidTxError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Happens if a wrong AccessKey used or AccessKey has not enough permissions"), z.object({ "InvalidSignerId": z.object({ "signer_id": z.string() }) }).strict().describe("TX signer_id is not a valid [`AccountId`]"), z.object({ "SignerDoesNotExist": z.object({ "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("TX signer_id is not found in a storage"), z.object({ "InvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "tx_nonce": z.number().int().gte(0) }) }).strict().describe("Transaction nonce must be strictly greater than `account[access_key].nonce`."), z.object({ "NonceTooLarge": z.object({ "tx_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("Transaction nonce is larger than the upper bound given by the block height"), z.object({ "InvalidReceiverId": z.object({ "receiver_id": z.string() }) }).strict().describe("TX receiver_id is not a valid AccountId"), z.literal("InvalidSignature").describe("TX signature is not valid"), z.object({ "NotEnoughBalance": z.object({ "balance": z.string(), "cost": z.string(), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account does not have enough balance to cover TX cost"), z.object({ "LackBalanceForState": z.object({ "amount": z.string().describe("Required balance to cover the state."), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which doesn't have enough balance to cover storage.") }) }).strict().describe("Signer account doesn't have enough balance after transaction."), z.literal("CostOverflow").describe("An integer overflow occurred during transaction cost estimation."), z.literal("InvalidChain").describe("Transaction parent block hash doesn't belong to the current chain"), z.literal("Expired").describe("Transaction has expired"), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of a Transaction."), z.object({ "TransactionSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of serialized transaction exceeded the limit."), z.literal("InvalidTransactionVersion").describe("Transaction version is invalid."), z.object({ "StorageError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("StorageInternalError").describe("Key-value db internal failure"), z.object({ "MissingTrieValue": z.object({ "context": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("TrieIterator").describe("Missing trie value when reading from TrieIterator."), z.literal("TriePrefetchingStorage").describe("Missing trie value when reading from TriePrefetchingStorage."), z.literal("TrieMemoryPartialStorage").describe("Missing trie value when reading from TrieMemoryPartialStorage."), z.literal("TrieStorage").describe("Missing trie value when reading from TrieStorage.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Contexts in which `StorageError::MissingTrieValue` error might occur."), "hash": z.string() }) }).strict().describe("Requested trie value by its hash which is missing in storage."), z.literal("UnexpectedTrieValue").describe("Found trie node which shouldn't be part of state. Raised during\nvalidation of state sync parts where incorrect node was passed.\nTODO (#8997): consider including hash of trie node."), z.object({ "StorageInconsistentState": z.string() }).strict().describe("Either invalid state or key-value db is corrupted.\nFor PartialStorage it cannot be corrupted.\nError message is unreliable and for debugging purposes only. It's also probably ok to\npanic in every place that produces this error.\nWe can check if db is corrupted by verifying everything in the state trie."), z.object({ "FlatStorageBlockNotSupported": z.string() }).strict().describe("Flat storage error, meaning that it doesn't support some block anymore.\nWe guarantee that such block cannot become final, thus block processing\nmust resume normally."), z.object({ "MemTrieLoadingError": z.string() }).strict().describe("In-memory trie could not be loaded for some reason.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Errors which may occur during working with trie storages, storing\ntrie values (trie nodes and state values) by their hashes.") }).strict(), z.object({ "ShardCongested": z.object({ "congestion_level": z.number().describe("A value between 0 (no congestion) and 1 (max congestion)."), "shard_id": z.number().int().gte(0).describe("The congested shard.") }) }).strict().describe("The receiver shard of the transaction is too congested to accept new\ntransactions at the moment."), z.object({ "ShardStuck": z.object({ "missed_chunks": z.number().int().gte(0).describe("The number of blocks since the last included chunk of the shard."), "shard_id": z.number().int().gte(0).describe("The shard that fails making progress.") }) }).strict().describe("The receiver shard of the transaction missed several chunks and rejects\nnew transaction until it can make progress again.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An error happened during TX execution") }).strict().describe("An error happened during Transaction execution")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error returned in the ExecutionOutcome in case of failure") }).strict().describe("The execution has failed."), z.object({ "SuccessValue": z.string() }).strict().describe("The final action succeeded and returned some value or an empty vec encoded in base64."), z.object({ "SuccessReceiptId": z.string() }).strict().describe("The final action of the receipt returned a promise or the signed transaction was converted\nto a receipt. Contains the receipt_id of the generated receipt.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Execution status. Contains the result in case of successful execution."), "tokens_burnt": z.string().describe("The amount of tokens burnt corresponding to the burnt gas amount.\nThis value doesn't always equal to the `gas_burnt` multiplied by the gas price, because\nthe prepaid gas price might be lower than the actual gas price and it creates a deficit.\n`tokens_burnt` also contains the penalty subtracted from refunds, while\n`gas_burnt` only contains the gas that we actually burn for the execution.") }), "proof": z.array(z.object({ "direction": z.enum(["Left","Right"]), "hash": z.string() })) }).describe("The execution outcome of the signed transaction.") }).describe("Execution outcome of the transaction and all the subsequent receipts.\nCould be not finalized yet")), z.object({ "final_execution_status": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("NONE").describe("Transaction is waiting to be included into the block"), z.literal("INCLUDED").describe("Transaction is included into the block. The block may be not finalized yet"), z.literal("EXECUTED_OPTIMISTIC").describe("Transaction is included into the block +\nAll non-refund transaction receipts finished their execution.\nThe corresponding blocks for tx and each receipt may be not finalized yet"), z.literal("INCLUDED_FINAL").describe("Transaction is included into finalized block"), z.literal("EXECUTED").describe("Transaction is included into finalized block +\nAll non-refund transaction receipts finished their execution.\nThe corresponding blocks for each receipt may be not finalized yet"), z.literal("FINAL").describe("Transaction is included into finalized block +\nExecution of all transaction receipts is finalized, including refund receipts")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }))
export type RpcTransactionResponse = z.infer<typeof RpcTransactionResponse>


export const RpcTransactionStatusRequest = z.record(z.any()).and(z.any().superRefine((x, ctx) => {
    const schemas = [z.intersection(z.object({ "wait_until": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("NONE").describe("Transaction is waiting to be included into the block"), z.literal("INCLUDED").describe("Transaction is included into the block. The block may be not finalized yet"), z.literal("EXECUTED_OPTIMISTIC").describe("Transaction is included into the block +\nAll non-refund transaction receipts finished their execution.\nThe corresponding blocks for tx and each receipt may be not finalized yet"), z.literal("INCLUDED_FINAL").describe("Transaction is included into finalized block"), z.literal("EXECUTED").describe("Transaction is included into finalized block +\nAll non-refund transaction receipts finished their execution.\nThe corresponding blocks for each receipt may be not finalized yet"), z.literal("FINAL").describe("Transaction is included into finalized block +\nExecution of all transaction receipts is finalized, including refund receipts")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).default("EXECUTED_OPTIMISTIC") }), z.object({ "signed_tx_base64": z.string() })), z.intersection(z.object({ "wait_until": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("NONE").describe("Transaction is waiting to be included into the block"), z.literal("INCLUDED").describe("Transaction is included into the block. The block may be not finalized yet"), z.literal("EXECUTED_OPTIMISTIC").describe("Transaction is included into the block +\nAll non-refund transaction receipts finished their execution.\nThe corresponding blocks for tx and each receipt may be not finalized yet"), z.literal("INCLUDED_FINAL").describe("Transaction is included into finalized block"), z.literal("EXECUTED").describe("Transaction is included into finalized block +\nAll non-refund transaction receipts finished their execution.\nThe corresponding blocks for each receipt may be not finalized yet"), z.literal("FINAL").describe("Transaction is included into finalized block +\nExecution of all transaction receipts is finalized, including refund receipts")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).default("EXECUTED_OPTIMISTIC") }), z.object({ "sender_account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "tx_hash": z.string() }))];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }))
export type RpcTransactionStatusRequest = z.infer<typeof RpcTransactionStatusRequest>


export const RpcValidatorRequest = z.record(z.any()).and(z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "epoch_id": z.string().describe("Epoch identifier -- wrapped hash, to make it easier to distinguish.\nEpochId of epoch T is the hash of last block in T-2\nEpochId of first two epochs is 0") }), z.object({ "block_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.number().int().gte(0), z.string()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }), z.object({ "latest": z.null() })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }))
export type RpcValidatorRequest = z.infer<typeof RpcValidatorRequest>


export const RpcValidatorResponse = z.object({ "current_fishermen": z.array(z.object({ "validator_stake_struct_version": z.literal("V1") }).and(z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string(), "stake": z.string() }))).describe("Fishermen for the current epoch"), "current_proposals": z.array(z.object({ "validator_stake_struct_version": z.literal("V1") }).and(z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string(), "stake": z.string() }))).describe("Proposals in the current epoch"), "current_validators": z.array(z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "is_slashed": z.boolean(), "num_expected_blocks": z.number().int().gte(0), "num_expected_chunks": z.number().int().gte(0).default(0), "num_expected_chunks_per_shard": z.array(z.number().int().gte(0)).describe("Number of chunks this validator was expected to produce in each shard.\nEach entry in the array corresponds to the shard in the `shards_produced` array.").default([]), "num_expected_endorsements": z.number().int().gte(0).default(0), "num_expected_endorsements_per_shard": z.array(z.number().int().gte(0)).describe("Number of chunks this validator was expected to validate and endorse in each shard.\nEach entry in the array corresponds to the shard in the `shards_endorsed` array.").default([]), "num_produced_blocks": z.number().int().gte(0), "num_produced_chunks": z.number().int().gte(0).default(0), "num_produced_chunks_per_shard": z.array(z.number().int().gte(0)).default([]), "num_produced_endorsements": z.number().int().gte(0).default(0), "num_produced_endorsements_per_shard": z.array(z.number().int().gte(0)).default([]), "public_key": z.string(), "shards": z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")).describe("Shards this validator is assigned to as chunk producer in the current epoch."), "shards_endorsed": z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")).describe("Shards this validator is assigned to as chunk validator in the current epoch.").default([]), "stake": z.string() }).describe("Describes information about the current epoch validator")).describe("Validators for the current epoch"), "epoch_height": z.number().int().gte(0).describe("Epoch height"), "epoch_start_height": z.number().int().gte(0).describe("Epoch start block height"), "next_fishermen": z.array(z.object({ "validator_stake_struct_version": z.literal("V1") }).and(z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string(), "stake": z.string() }))).describe("Fishermen for the next epoch"), "next_validators": z.array(z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string(), "shards": z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")), "stake": z.string() })).describe("Validators for the next epoch"), "prev_epoch_kickout": z.array(z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "reason": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("_UnusedSlashed").describe("Deprecated"), z.object({ "NotEnoughBlocks": z.object({ "expected": z.number().int().gte(0), "produced": z.number().int().gte(0) }) }).strict().describe("Validator didn't produce enough blocks."), z.object({ "NotEnoughChunks": z.object({ "expected": z.number().int().gte(0), "produced": z.number().int().gte(0) }) }).strict().describe("Validator didn't produce enough chunks."), z.literal("Unstaked").describe("Validator unstaked themselves."), z.object({ "NotEnoughStake": z.object({ "stake_u128": z.string(), "threshold_u128": z.string() }) }).strict().describe("Validator stake is now below threshold"), z.literal("DidNotGetASeat").describe("Enough stake but is not chosen because of seat limits."), z.object({ "NotEnoughChunkEndorsements": z.object({ "expected": z.number().int().gte(0), "produced": z.number().int().gte(0) }) }).strict().describe("Validator didn't produce enough chunk endorsements."), z.object({ "ProtocolVersionTooOld": z.object({ "network_version": z.number().int().gte(0), "version": z.number().int().gte(0) }) }).strict().describe("Validator's last block proposal was for a protocol version older than\nthe network's voted protocol version.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Reasons for removing a validator from the validator set.") })).describe("Kickout in the previous epoch") }).describe("Information about this epoch validators and next epoch validators")
export type RpcValidatorResponse = z.infer<typeof RpcValidatorResponse>


export const RpcValidatorsOrderedRequest = z.object({ "block_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.any().superRefine((x, ctx) => {
    const schemas = [z.number().int().gte(0), z.string()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional() })
export type RpcValidatorsOrderedRequest = z.infer<typeof RpcValidatorsOrderedRequest>


export const RuntimeConfigView = z.object({ "account_creation_config": z.object({ "min_allowed_top_level_account_length": z.number().int().gte(0).lte(255).describe("The minimum length of the top-level account ID that is allowed to be created by any account."), "registrar_account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("The account ID of the account registrar. This account ID allowed to create top-level\naccounts of any valid length.") }).describe("The structure describes configuration for creation of new accounts.").describe("Config that defines rules for account creation."), "congestion_control_config": z.object({ "allowed_shard_outgoing_gas": z.number().int().gte(0).describe("How much gas the chosen allowed shard can send to a 100% congested shard.\n\nSee [`CongestionControlConfig`] for more details."), "max_congestion_incoming_gas": z.number().int().gte(0).describe("How much gas in delayed receipts of a shard is 100% incoming congestion.\n\nSee [`CongestionControlConfig`] for more details."), "max_congestion_memory_consumption": z.number().int().gte(0).describe("How much memory space of all delayed and buffered receipts in a shard is\nconsidered 100% congested.\n\nSee [`CongestionControlConfig`] for more details."), "max_congestion_missed_chunks": z.number().int().gte(0).describe("How many missed chunks in a row in a shard is considered 100% congested."), "max_congestion_outgoing_gas": z.number().int().gte(0).describe("How much gas in outgoing buffered receipts of a shard is 100% congested.\n\nOutgoing congestion contributes to overall congestion, which reduces how\nmuch other shards are allowed to forward to this shard."), "max_outgoing_gas": z.number().int().gte(0).describe("The maximum amount of gas attached to receipts a shard can forward to\nanother shard per chunk.\n\nSee [`CongestionControlConfig`] for more details."), "max_tx_gas": z.number().int().gte(0).describe("The maximum amount of gas in a chunk spent on converting new transactions to\nreceipts.\n\nSee [`CongestionControlConfig`] for more details."), "min_outgoing_gas": z.number().int().gte(0).describe("The minimum gas each shard can send to a shard that is not fully congested.\n\nSee [`CongestionControlConfig`] for more details."), "min_tx_gas": z.number().int().gte(0).describe("The minimum amount of gas in a chunk spent on converting new transactions\nto receipts, as long as the receiving shard is not congested.\n\nSee [`CongestionControlConfig`] for more details."), "outgoing_receipts_big_size_limit": z.number().int().gte(0).describe("Large size limit for outgoing receipts to a shard, used when it's safe\nto send a lot of receipts without making the state witness too large.\nIt limits the total sum of outgoing receipts, not individual receipts."), "outgoing_receipts_usual_size_limit": z.number().int().gte(0).describe("The standard size limit for outgoing receipts aimed at a single shard.\nThis limit is pretty small to keep the size of source_receipt_proofs under control.\nIt limits the total sum of outgoing receipts, not individual receipts."), "reject_tx_congestion_threshold": z.number().describe("How much congestion a shard can tolerate before it stops all shards from\naccepting new transactions with the receiver set to the congested shard.") }).describe("The configuration for congestion control. More info about congestion [here](https://near.github.io/nearcore/architecture/how/receipt-congestion.html?highlight=congestion#receipt-congestion)").describe("The configuration for congestion control."), "storage_amount_per_byte": z.string().describe("Amount of yN per byte required to have on the account.  See\n<https://nomicon.io/Economics/Economic#state-stake> for details."), "transaction_costs": z.object({ "action_creation_config": z.object({ "add_key_cost": z.object({ "full_access_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of creating a full access access-key."), "function_call_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of creating an access-key restricted to specific functions."), "function_call_cost_per_byte": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Cost per byte of method_names of creating a restricted access-key.") }).describe("Describes the cost of creating an access key.").describe("Base cost of adding a key."), "create_account_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of creating an account."), "delegate_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost for processing a delegate action.\n\nThis is on top of the costs for the actions inside the delegate action."), "delete_account_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of deleting an account."), "delete_key_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of deleting a key."), "deploy_contract_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of deploying a contract."), "deploy_contract_cost_per_byte": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Cost per byte of deploying a contract."), "function_call_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of calling a function."), "function_call_cost_per_byte": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Cost per byte of method name and arguments of calling a function."), "stake_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of staking."), "transfer_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of making a transfer.") }).describe("Describes the cost of creating a specific action, `Action`. Includes all variants.").describe("Describes the cost of creating a certain action, `Action`. Includes all variants."), "action_receipt_creation_config": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Describes the cost of creating an action receipt, `ActionReceipt`, excluding the actual cost\nof actions.\n- `send` cost is burned when a receipt is created using `promise_create` or\n    `promise_batch_create`\n- `exec` cost is burned when the receipt is being executed."), "burnt_gas_reward": z.array(z.number().int()).min(2).max(2).describe("Fraction of the burnt gas to reward to the contract account for execution."), "data_receipt_creation_config": z.object({ "base_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of creating a data receipt.\nBoth `send` and `exec` costs are burned when a new receipt has input dependencies. The gas\nis charged for each input dependency. The dependencies are specified when a receipt is\ncreated using `promise_then` and `promise_batch_then`.\nNOTE: Any receipt with output dependencies will produce data receipts. Even if it fails.\nEven if the last action is not a function call (in case of success it will return empty\nvalue)."), "cost_per_byte": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Additional cost per byte sent.\nBoth `send` and `exec` costs are burned when a function call finishes execution and returns\n`N` bytes of data to every output dependency. For each output dependency the cost is\n`(send(sir) + exec()) * N`.") }).describe("The fees settings for a data receipt creation").describe("Describes the cost of creating a data receipt, `DataReceipt`."), "pessimistic_gas_price_inflation_ratio": z.array(z.number().int()).min(2).max(2).describe("Pessimistic gas price inflation ratio."), "storage_usage_config": z.object({ "num_bytes_account": z.number().int().gte(0).describe("Number of bytes for an account record, including rounding up for account id."), "num_extra_bytes_record": z.number().int().gte(0).describe("Additional number of bytes for a k/v record") }).describe("Describes cost of storage per block").describe("Describes fees for storage.") }).describe("Describes different fees for the runtime").describe("Costs of different actions that need to be performed when sending and\nprocessing transaction and receipts."), "wasm_config": z.object({ "deterministic_account_ids": z.boolean().describe("See [VMConfig::deterministic_account_ids](crate::vm::Config::deterministic_account_ids)."), "discard_custom_sections": z.boolean().describe("See [VMConfig::discard_custom_sections](crate::vm::Config::discard_custom_sections)."), "eth_implicit_accounts": z.boolean().describe("See [VMConfig::eth_implicit_accounts](crate::vm::Config::eth_implicit_accounts)."), "ext_costs": z.object({ "alt_bn128_g1_multiexp_base": z.number().int().gte(0).describe("Base cost for multiexp"), "alt_bn128_g1_multiexp_element": z.number().int().gte(0).describe("Per element cost for multiexp"), "alt_bn128_g1_sum_base": z.number().int().gte(0).describe("Base cost for sum"), "alt_bn128_g1_sum_element": z.number().int().gte(0).describe("Per element cost for sum"), "alt_bn128_pairing_check_base": z.number().int().gte(0).describe("Base cost for pairing check"), "alt_bn128_pairing_check_element": z.number().int().gte(0).describe("Per element cost for pairing check"), "base": z.number().int().gte(0).describe("Base cost for calling a host function."), "bls12381_g1_multiexp_base": z.number().int().gte(0), "bls12381_g1_multiexp_element": z.number().int().gte(0), "bls12381_g2_multiexp_base": z.number().int().gte(0), "bls12381_g2_multiexp_element": z.number().int().gte(0), "bls12381_map_fp2_to_g2_base": z.number().int().gte(0), "bls12381_map_fp2_to_g2_element": z.number().int().gte(0), "bls12381_map_fp_to_g1_base": z.number().int().gte(0), "bls12381_map_fp_to_g1_element": z.number().int().gte(0), "bls12381_p1_decompress_base": z.number().int().gte(0), "bls12381_p1_decompress_element": z.number().int().gte(0), "bls12381_p1_sum_base": z.number().int().gte(0), "bls12381_p1_sum_element": z.number().int().gte(0), "bls12381_p2_decompress_base": z.number().int().gte(0), "bls12381_p2_decompress_element": z.number().int().gte(0), "bls12381_p2_sum_base": z.number().int().gte(0), "bls12381_p2_sum_element": z.number().int().gte(0), "bls12381_pairing_base": z.number().int().gte(0), "bls12381_pairing_element": z.number().int().gte(0), "contract_compile_base": z.number().int().gte(0), "contract_compile_bytes": z.number().int().gte(0), "contract_loading_base": z.number().int().gte(0).describe("Base cost of loading a pre-compiled contract"), "contract_loading_bytes": z.number().int().gte(0).describe("Cost per byte of loading a pre-compiled contract"), "ecrecover_base": z.number().int().gte(0).describe("Cost of calling ecrecover"), "ed25519_verify_base": z.number().int().gte(0).describe("Cost of getting ed25519 base"), "ed25519_verify_byte": z.number().int().gte(0).describe("Cost of getting ed25519 per byte"), "keccak256_base": z.number().int().gte(0).describe("Cost of getting sha256 base"), "keccak256_byte": z.number().int().gte(0).describe("Cost of getting sha256 per byte"), "keccak512_base": z.number().int().gte(0).describe("Cost of getting sha256 base"), "keccak512_byte": z.number().int().gte(0).describe("Cost of getting sha256 per byte"), "log_base": z.number().int().gte(0).describe("Cost for calling logging."), "log_byte": z.number().int().gte(0).describe("Cost for logging per byte"), "promise_and_base": z.number().int().gte(0).describe("Cost for calling `promise_and`"), "promise_and_per_promise": z.number().int().gte(0).describe("Cost for calling `promise_and` for each promise"), "promise_return": z.number().int().gte(0).describe("Cost for calling `promise_return`"), "read_cached_trie_node": z.number().int().gte(0).describe("Cost for reading trie node from memory"), "read_memory_base": z.number().int().gte(0).describe("Base cost for guest memory read"), "read_memory_byte": z.number().int().gte(0).describe("Cost for guest memory read"), "read_register_base": z.number().int().gte(0).describe("Base cost for reading from register"), "read_register_byte": z.number().int().gte(0).describe("Cost for reading byte from register"), "ripemd160_base": z.number().int().gte(0).describe("Cost of getting ripemd160 base"), "ripemd160_block": z.number().int().gte(0).describe("Cost of getting ripemd160 per message block"), "sha256_base": z.number().int().gte(0).describe("Cost of getting sha256 base"), "sha256_byte": z.number().int().gte(0).describe("Cost of getting sha256 per byte"), "storage_has_key_base": z.number().int().gte(0).describe("Storage trie check for key existence cost base"), "storage_has_key_byte": z.number().int().gte(0).describe("Storage trie check for key existence per key byte"), "storage_iter_create_from_byte": z.number().int().gte(0).describe("Create trie range iterator cost per byte of from key."), "storage_iter_create_prefix_base": z.number().int().gte(0).describe("Create trie prefix iterator cost base"), "storage_iter_create_prefix_byte": z.number().int().gte(0).describe("Create trie prefix iterator cost per byte."), "storage_iter_create_range_base": z.number().int().gte(0).describe("Create trie range iterator cost base"), "storage_iter_create_to_byte": z.number().int().gte(0).describe("Create trie range iterator cost per byte of to key."), "storage_iter_next_base": z.number().int().gte(0).describe("Trie iterator per key base cost"), "storage_iter_next_key_byte": z.number().int().gte(0).describe("Trie iterator next key byte cost"), "storage_iter_next_value_byte": z.number().int().gte(0).describe("Trie iterator next key byte cost"), "storage_large_read_overhead_base": z.number().int().gte(0).describe("Storage trie read key overhead base cost, when doing large reads"), "storage_large_read_overhead_byte": z.number().int().gte(0).describe("Storage trie read key overhead  per-byte cost, when doing large reads"), "storage_read_base": z.number().int().gte(0).describe("Storage trie read key base cost"), "storage_read_key_byte": z.number().int().gte(0).describe("Storage trie read key per byte cost"), "storage_read_value_byte": z.number().int().gte(0).describe("Storage trie read value cost per byte cost"), "storage_remove_base": z.number().int().gte(0).describe("Remove key from trie base cost"), "storage_remove_key_byte": z.number().int().gte(0).describe("Remove key from trie per byte cost"), "storage_remove_ret_value_byte": z.number().int().gte(0).describe("Remove key from trie ret value byte cost"), "storage_write_base": z.number().int().gte(0).describe("Storage trie write key base cost"), "storage_write_evicted_byte": z.number().int().gte(0).describe("Storage trie write cost per byte of evicted value."), "storage_write_key_byte": z.number().int().gte(0).describe("Storage trie write key per byte cost"), "storage_write_value_byte": z.number().int().gte(0).describe("Storage trie write value per byte cost"), "touching_trie_node": z.number().int().gte(0).describe("Cost per reading trie node from DB"), "utf16_decoding_base": z.number().int().gte(0).describe("Base cost of decoding utf16. It's used for `log_utf16`."), "utf16_decoding_byte": z.number().int().gte(0).describe("Cost per byte of decoding utf16. It's used for `log_utf16`."), "utf8_decoding_base": z.number().int().gte(0).describe("Base cost of decoding utf8. It's used for `log_utf8` and `panic_utf8`."), "utf8_decoding_byte": z.number().int().gte(0).describe("Cost per byte of decoding utf8. It's used for `log_utf8` and `panic_utf8`."), "validator_stake_base": z.number().int().gte(0).describe("Cost of calling `validator_stake`."), "validator_total_stake_base": z.number().int().gte(0).describe("Cost of calling `validator_total_stake`."), "write_memory_base": z.number().int().gte(0).describe("Base cost for guest memory write"), "write_memory_byte": z.number().int().gte(0).describe("Cost for guest memory write per byte"), "write_register_base": z.number().int().gte(0).describe("Base cost for writing into register"), "write_register_byte": z.number().int().gte(0).describe("Cost for writing byte into register"), "yield_create_base": z.number().int().gte(0).describe("Base cost for creating a yield promise."), "yield_create_byte": z.number().int().gte(0).describe("Per byte cost of arguments and method name."), "yield_resume_base": z.number().int().gte(0).describe("Base cost for resuming a yield receipt."), "yield_resume_byte": z.number().int().gte(0).describe("Per byte cost of resume payload.") }).describe("Typed view of ExtCostsConfig to preserve JSON output field names in protocol\nconfig RPC output.").describe("Costs for runtime externals"), "fix_contract_loading_cost": z.boolean().describe("See [VMConfig::fix_contract_loading_cost](crate::vm::Config::fix_contract_loading_cost)."), "global_contract_host_fns": z.boolean().describe("See [VMConfig::global_contract_host_fns](crate::vm::Config::global_contract_host_fns)."), "grow_mem_cost": z.number().int().gte(0).describe("Gas cost of a growing memory by single page."), "implicit_account_creation": z.boolean().describe("See [VMConfig::implicit_account_creation](crate::vm::Config::implicit_account_creation)."), "limit_config": z.object({ "account_id_validity_rules_version": z.number().int().gte(0).lte(255).describe("Whether to enforce account_id well-formed-ness where it wasn't enforced\nhistorically.").default(0), "initial_memory_pages": z.number().int().gte(0).describe("The initial number of memory pages.\nNOTE: It's not a limiter itself, but it's a value we use for initial_memory_pages."), "max_actions_per_receipt": z.number().int().gte(0).describe("Max number of actions per receipt."), "max_arguments_length": z.number().int().gte(0).describe("Max length of arguments in a function call action."), "max_contract_size": z.number().int().gte(0).describe("Max contract size"), "max_elements_per_contract_table": z.union([z.number().int().gte(0).describe("If present, stores max number of elements in a single contract's table"), z.null().describe("If present, stores max number of elements in a single contract's table")]).describe("If present, stores max number of elements in a single contract's table").optional(), "max_functions_number_per_contract": z.union([z.number().int().gte(0).describe("If present, stores max number of functions in one contract"), z.null().describe("If present, stores max number of functions in one contract")]).describe("If present, stores max number of functions in one contract").optional(), "max_gas_burnt": z.number().int().gte(0).describe("Max amount of gas that can be used, excluding gas attached to promises."), "max_length_method_name": z.number().int().gte(0).describe("Max length of any method name (without terminating character)."), "max_length_returned_data": z.number().int().gte(0).describe("Max length of returned data"), "max_length_storage_key": z.number().int().gte(0).describe("Max storage key size"), "max_length_storage_value": z.number().int().gte(0).describe("Max storage value size"), "max_locals_per_contract": z.union([z.number().int().gte(0).describe("If present, stores max number of locals declared globally in one contract"), z.null().describe("If present, stores max number of locals declared globally in one contract")]).describe("If present, stores max number of locals declared globally in one contract").optional(), "max_memory_pages": z.number().int().gte(0).describe("What is the maximal memory pages amount is allowed to have for a contract."), "max_number_bytes_method_names": z.number().int().gte(0).describe("Max total length of all method names (including terminating character) for a function call\npermission access key."), "max_number_input_data_dependencies": z.number().int().gte(0).describe("Max number of input data dependencies"), "max_number_logs": z.number().int().gte(0).describe("Maximum number of log entries."), "max_number_registers": z.number().int().gte(0).describe("Maximum number of registers that can be used simultaneously.\n\nNote that due to an implementation quirk [read: a bug] in VMLogic, if we\nhave this number of registers, no subsequent writes to the registers\nwill succeed even if they replace an existing register."), "max_promises_per_function_call_action": z.number().int().gte(0).describe("Max number of promises that a function call can create"), "max_receipt_size": z.number().int().gte(0).describe("Max receipt size"), "max_register_size": z.number().int().gte(0).describe("Maximum number of bytes that can be stored in a single register."), "max_stack_height": z.number().int().gte(0).describe("How tall the stack is allowed to grow?\n\nSee <https://wiki.parity.io/WebAssembly-StackHeight> to find out how the stack frame cost\nis calculated."), "max_tables_per_contract": z.union([z.number().int().gte(0).describe("If present, stores max number of tables declared globally in one contract"), z.null().describe("If present, stores max number of tables declared globally in one contract")]).describe("If present, stores max number of tables declared globally in one contract").optional(), "max_total_log_length": z.number().int().gte(0).describe("Maximum total length in bytes of all log messages."), "max_total_prepaid_gas": z.number().int().gte(0).describe("Max total prepaid gas for all function call actions per receipt."), "max_transaction_size": z.number().int().gte(0).describe("Max transaction size"), "max_yield_payload_size": z.number().int().gte(0).describe("Maximum number of bytes for payload passed over a yield resume."), "per_receipt_storage_proof_size_limit": z.number().int().gte(0).describe("Hard limit on the size of storage proof generated while executing a single receipt."), "registers_memory_limit": z.number().int().gte(0).describe("Limit of memory used by registers."), "yield_timeout_length_in_blocks": z.number().int().gte(0).describe("Number of blocks after which a yielded promise times out.") }).describe("Describes limits for VM and Runtime.\nTODO #4139: consider switching to strongly-typed wrappers instead of raw quantities").describe("Describes limits for VM and Runtime.\n\nTODO: Consider changing this to `VMLimitConfigView` to avoid dependency\non runtime."), "linear_op_base_cost": z.number().int().gte(0).describe("Base gas cost of a linear operation"), "linear_op_unit_cost": z.number().int().gte(0).describe("Unit gas cost of a linear operation"), "reftypes_bulk_memory": z.boolean().describe("See [VMConfig::reftypes_bulk_memory](crate::vm::Config::reftypes_bulk_memory)."), "regular_op_cost": z.number().int().gte(0).describe("Gas cost of a regular operation."), "saturating_float_to_int": z.boolean().describe("See [VMConfig::saturating_float_to_int](crate::vm::Config::saturating_float_to_int)."), "storage_get_mode": z.enum(["FlatStorage","Trie"]).describe("This enum represents if a storage_get call will be performed through flat storage or trie").describe("See [VMConfig::storage_get_mode](crate::vm::Config::storage_get_mode)."), "vm_kind": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Wasmer0").describe("Wasmer 0.17.x VM. Gone now."), z.literal("Wasmtime").describe("Wasmtime VM."), z.literal("Wasmer2").describe("Wasmer 2.x VM."), z.literal("NearVm").describe("NearVM.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("See [VMConfig::vm_kind](crate::vm::Config::vm_kind).") }).describe("Config of wasm operations."), "witness_config": z.object({ "combined_transactions_size_limit": z.number().int().gte(0).describe("Maximum size of transactions contained inside ChunkStateWitness.\n\nA witness contains transactions from both the previous chunk and the current one.\nThis parameter limits the sum of sizes of transactions from both of those chunks."), "main_storage_proof_size_soft_limit": z.number().int().gte(0).describe("Size limit for storage proof generated while executing receipts in a chunk.\nAfter this limit is reached we defer execution of any new receipts."), "new_transactions_validation_state_size_soft_limit": z.number().int().gte(0).describe("Soft size limit of storage proof used to validate new transactions in ChunkStateWitness.") }).describe("Configuration specific to ChunkStateWitness.").describe("Configuration specific to ChunkStateWitness.") }).describe("View that preserves JSON format of the runtime config.")
export type RuntimeConfigView = z.infer<typeof RuntimeConfigView>


export const RuntimeFeesConfigView = z.object({ "action_creation_config": z.object({ "add_key_cost": z.object({ "full_access_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of creating a full access access-key."), "function_call_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of creating an access-key restricted to specific functions."), "function_call_cost_per_byte": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Cost per byte of method_names of creating a restricted access-key.") }).describe("Describes the cost of creating an access key.").describe("Base cost of adding a key."), "create_account_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of creating an account."), "delegate_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost for processing a delegate action.\n\nThis is on top of the costs for the actions inside the delegate action."), "delete_account_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of deleting an account."), "delete_key_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of deleting a key."), "deploy_contract_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of deploying a contract."), "deploy_contract_cost_per_byte": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Cost per byte of deploying a contract."), "function_call_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of calling a function."), "function_call_cost_per_byte": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Cost per byte of method name and arguments of calling a function."), "stake_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of staking."), "transfer_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of making a transfer.") }).describe("Describes the cost of creating a specific action, `Action`. Includes all variants.").describe("Describes the cost of creating a certain action, `Action`. Includes all variants."), "action_receipt_creation_config": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Describes the cost of creating an action receipt, `ActionReceipt`, excluding the actual cost\nof actions.\n- `send` cost is burned when a receipt is created using `promise_create` or\n    `promise_batch_create`\n- `exec` cost is burned when the receipt is being executed."), "burnt_gas_reward": z.array(z.number().int()).min(2).max(2).describe("Fraction of the burnt gas to reward to the contract account for execution."), "data_receipt_creation_config": z.object({ "base_cost": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Base cost of creating a data receipt.\nBoth `send` and `exec` costs are burned when a new receipt has input dependencies. The gas\nis charged for each input dependency. The dependencies are specified when a receipt is\ncreated using `promise_then` and `promise_batch_then`.\nNOTE: Any receipt with output dependencies will produce data receipts. Even if it fails.\nEven if the last action is not a function call (in case of success it will return empty\nvalue)."), "cost_per_byte": z.object({ "execution": z.number().int().gte(0).describe("Fee for executing the object."), "send_not_sir": z.number().int().gte(0).describe("Fee for sending an object potentially across the shards."), "send_sir": z.number().int().gte(0).describe("Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard.") }).describe("Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed.").describe("Additional cost per byte sent.\nBoth `send` and `exec` costs are burned when a function call finishes execution and returns\n`N` bytes of data to every output dependency. For each output dependency the cost is\n`(send(sir) + exec()) * N`.") }).describe("The fees settings for a data receipt creation").describe("Describes the cost of creating a data receipt, `DataReceipt`."), "pessimistic_gas_price_inflation_ratio": z.array(z.number().int()).min(2).max(2).describe("Pessimistic gas price inflation ratio."), "storage_usage_config": z.object({ "num_bytes_account": z.number().int().gte(0).describe("Number of bytes for an account record, including rounding up for account id."), "num_extra_bytes_record": z.number().int().gte(0).describe("Additional number of bytes for a k/v record") }).describe("Describes cost of storage per block").describe("Describes fees for storage.") }).describe("Describes different fees for the runtime")
export type RuntimeFeesConfigView = z.infer<typeof RuntimeFeesConfigView>


export const ShardId = z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")
export type ShardId = z.infer<typeof ShardId>


export const ShardLayout = z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "V0": z.object({ "num_shards": z.number().int().gte(0).describe("Map accounts evenly across all shards"), "version": z.number().int().gte(0).describe("Version of the shard layout, this is useful for uniquely identify the shard layout") }).describe("A shard layout that maps accounts evenly across all shards -- by calculate the hash of account\nid and mod number of shards. This is added to capture the old `account_id_to_shard_id` algorithm,\nto keep backward compatibility for some existing tests.\n`parent_shards` for `ShardLayoutV1` is always `None`, meaning it can only be the first shard layout\na chain uses.") }).strict(), z.object({ "V1": z.object({ "boundary_accounts": z.array(z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```")).describe("The boundary accounts are the accounts on boundaries between shards.\nEach shard contains a range of accounts from one boundary account to\nanother - or the smallest or largest account possible. The total\nnumber of shards is equal to the number of boundary accounts plus 1."), "shards_split_map": z.union([z.array(z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias."))).describe("Maps shards from the last shard layout to shards that it splits to in this shard layout,\nUseful for constructing states for the shards.\nNone for the genesis shard layout"), z.null().describe("Maps shards from the last shard layout to shards that it splits to in this shard layout,\nUseful for constructing states for the shards.\nNone for the genesis shard layout")]).describe("Maps shards from the last shard layout to shards that it splits to in this shard layout,\nUseful for constructing states for the shards.\nNone for the genesis shard layout").optional(), "to_parent_shard_map": z.union([z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")).describe("Maps shard in this shard layout to their parent shard\nSince shard_ids always range from 0 to num_shards - 1, we use vec instead of a hashmap"), z.null().describe("Maps shard in this shard layout to their parent shard\nSince shard_ids always range from 0 to num_shards - 1, we use vec instead of a hashmap")]).describe("Maps shard in this shard layout to their parent shard\nSince shard_ids always range from 0 to num_shards - 1, we use vec instead of a hashmap").optional(), "version": z.number().int().gte(0).describe("Version of the shard layout, this is useful for uniquely identify the shard layout") }) }).strict(), z.object({ "V2": z.object({ "boundary_accounts": z.array(z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```")), "id_to_index_map": z.record(z.number().int().gte(0)), "index_to_id_map": z.record(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")), "shard_ids": z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")), "shards_parent_map": z.union([z.record(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")), z.null()]).optional(), "shards_split_map": z.union([z.record(z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias."))), z.null()]).optional(), "version": z.number().int().gte(0) }).describe("Counterpart to `ShardLayoutV2` composed of maps with string keys to aid\nserde serialization.") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("A versioned struct that contains all information needed to assign accounts to shards.\n\nBecause of re-sharding, the chain may use different shard layout to split shards at different\ntimes. Currently, `ShardLayout` is stored as part of `EpochConfig`, which is generated each\nepoch given the epoch protocol version. In mainnet/testnet, we use two shard layouts since\nre-sharding has only happened once. It is stored as part of genesis config, see\ndefault_simple_nightshade_shard_layout() Below is an overview for some important\nfunctionalities of ShardLayout interface.")
export type ShardLayout = z.infer<typeof ShardLayout>


export const ShardLayoutV0 = z.object({ "num_shards": z.number().int().gte(0).describe("Map accounts evenly across all shards"), "version": z.number().int().gte(0).describe("Version of the shard layout, this is useful for uniquely identify the shard layout") }).describe("A shard layout that maps accounts evenly across all shards -- by calculate the hash of account\nid and mod number of shards. This is added to capture the old `account_id_to_shard_id` algorithm,\nto keep backward compatibility for some existing tests.\n`parent_shards` for `ShardLayoutV1` is always `None`, meaning it can only be the first shard layout\na chain uses.")
export type ShardLayoutV0 = z.infer<typeof ShardLayoutV0>


export const ShardLayoutV1 = z.object({ "boundary_accounts": z.array(z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```")).describe("The boundary accounts are the accounts on boundaries between shards.\nEach shard contains a range of accounts from one boundary account to\nanother - or the smallest or largest account possible. The total\nnumber of shards is equal to the number of boundary accounts plus 1."), "shards_split_map": z.union([z.array(z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias."))).describe("Maps shards from the last shard layout to shards that it splits to in this shard layout,\nUseful for constructing states for the shards.\nNone for the genesis shard layout"), z.null().describe("Maps shards from the last shard layout to shards that it splits to in this shard layout,\nUseful for constructing states for the shards.\nNone for the genesis shard layout")]).describe("Maps shards from the last shard layout to shards that it splits to in this shard layout,\nUseful for constructing states for the shards.\nNone for the genesis shard layout").optional(), "to_parent_shard_map": z.union([z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")).describe("Maps shard in this shard layout to their parent shard\nSince shard_ids always range from 0 to num_shards - 1, we use vec instead of a hashmap"), z.null().describe("Maps shard in this shard layout to their parent shard\nSince shard_ids always range from 0 to num_shards - 1, we use vec instead of a hashmap")]).describe("Maps shard in this shard layout to their parent shard\nSince shard_ids always range from 0 to num_shards - 1, we use vec instead of a hashmap").optional(), "version": z.number().int().gte(0).describe("Version of the shard layout, this is useful for uniquely identify the shard layout") })
export type ShardLayoutV1 = z.infer<typeof ShardLayoutV1>


export const ShardLayoutV2 = z.object({ "boundary_accounts": z.array(z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```")), "id_to_index_map": z.record(z.number().int().gte(0)), "index_to_id_map": z.record(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")), "shard_ids": z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")), "shards_parent_map": z.union([z.record(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")), z.null()]).optional(), "shards_split_map": z.union([z.record(z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias."))), z.null()]).optional(), "version": z.number().int().gte(0) }).describe("Counterpart to `ShardLayoutV2` composed of maps with string keys to aid\nserde serialization.")
export type ShardLayoutV2 = z.infer<typeof ShardLayoutV2>


export const ShardUId = z.object({ "shard_id": z.number().int().gte(0), "version": z.number().int().gte(0) }).describe("`ShardUId` is a unique representation for shards from different shard layouts.\n\nComparing to `ShardId`, which is just an ordinal number ranging from 0 to NUM_SHARDS-1,\n`ShardUId` provides a way to unique identify shards when shard layouts may change across epochs.\nThis is important because we store states indexed by shards in our database, so we need a\nway to unique identify shard even when shards change across epochs.\nAnother difference between `ShardUId` and `ShardId` is that `ShardUId` should only exist in\na node's internal state while `ShardId` can be exposed to outside APIs and used in protocol\nlevel information (for example, `ShardChunkHeader` contains `ShardId` instead of `ShardUId`)")
export type ShardUId = z.infer<typeof ShardUId>


export const Signature = z.string()
export type Signature = z.infer<typeof Signature>


export const SignedDelegateAction = z.object({ "delegate_action": z.object({ "actions": z.array(z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CreateAccount": z.record(z.any()).describe("Create account action") }).strict().describe("Create an (sub)account using a transaction `receiver_id` as an ID for\na new account ID must pass validation rules described here\n<https://nomicon.io/DataStructures/Account>."), z.object({ "DeployContract": z.object({ "code": z.string().describe("WebAssembly binary") }).describe("Deploy contract action") }).strict().describe("Sets a Wasm code to a receiver_id"), z.object({ "FunctionCall": z.object({ "args": z.string(), "deposit": z.string(), "gas": z.number().int().gte(0), "method_name": z.string() }) }).strict(), z.object({ "Transfer": z.object({ "deposit": z.string() }) }).strict(), z.object({ "Stake": z.object({ "public_key": z.string().describe("Validator key which will be used to sign transactions on behalf of signer_id"), "stake": z.string().describe("Amount of tokens to stake.") }).describe("An action which stakes signer_id tokens and setup's validator public key") }).strict(), z.object({ "AddKey": z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0).describe("Nonce for this access key, used for tx nonce generation. When access key is created, nonce\nis set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\nSee <https://github.com/near/nearcore/issues/3779> for more details."), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Allowance is a balance limit to use by this access key to pay for function call gas and\ntransaction fees. When this access key is used, both account balance and the allowance is\ndecreased by the same value.\n`None` means unlimited allowance.\nNOTE: To change or increase the allowance, the old access key needs to be deleted and a new\naccess key should be created.").optional(), "method_names": z.array(z.string()).describe("A list of method names that can be used. The access key only allows transactions with the\nfunction call of one of the given method names.\nEmpty list means any method name can be used."), "receiver_id": z.string().describe("The access key only allows transactions with the given receiver's account id.") }).describe("Grants limited permission to make transactions with FunctionCallActions\nThe permission can limit the allowed balance to be spent on the prepaid gas.\nIt also restrict the account ID of the receiver for this function call.\nIt also can restrict the method name for the allowed function calls.") }).strict(), z.literal("FullAccess").describe("Grants full access to the account.\nNOTE: It's used to replace account-level public keys.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Defines permissions for AccessKey").describe("Defines permissions for this access key.") }).describe("Access key provides limited access to an account. Each access key belongs to some account and\nis identified by a unique (within the account) public key. One account may have large number of\naccess keys. Access keys allow to act on behalf of the account by restricting transactions\nthat can be issued.\n`account_id,public_key` is a key in the state").describe("An access key with the permission"), "public_key": z.string().describe("A public key which will be associated with an access_key") }).describe("An action that adds key with public key associated") }).strict(), z.object({ "DeleteKey": z.object({ "public_key": z.string().describe("A public key associated with the access_key to be deleted.") }) }).strict(), z.object({ "DeleteAccount": z.object({ "beneficiary_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeployGlobalContract": z.object({ "code": z.string().describe("WebAssembly binary"), "deploy_mode": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("CodeHash").describe("Contract is deployed under its code hash.\nUsers will be able reference it by that hash.\nThis effectively makes the contract immutable."), z.literal("AccountId").describe("Contract is deployed under the owner account id.\nUsers will be able reference it by that account id.\nThis allows the owner to update the contract for all its users.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Deploy global contract action") }).strict(), z.object({ "UseGlobalContract": z.object({ "contract_identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Use global contract action") }).strict(), z.object({ "DeterministicStateInit": z.object({ "deposit": z.string(), "state_init": z.object({ "V1": z.object({ "code": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "data": z.record(z.string()) }) }).strict() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An Action that can be included in a transaction or receipt, excluding delegate actions. This type represents all possible action types except DelegateAction to prevent infinite recursion in meta-transactions.")).describe("List of actions to be executed.\n\nWith the meta transactions MVP defined in NEP-366, nested\nDelegateActions are not allowed. A separate type is used to enforce it."), "max_block_height": z.number().int().gte(0).describe("The maximal height of the block in the blockchain below which the given DelegateAction is valid."), "nonce": z.number().int().gte(0).describe("Nonce to ensure that the same delegate action is not sent twice by a\nrelayer and should match for given account's `public_key`.\nAfter this action is processed it will increment."), "public_key": z.string().describe("Public key used to sign this delegated action."), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("Receiver of the delegated actions."), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("Signer of the delegated actions") }).describe("This action allows to execute the inner actions behalf of the defined sender."), "signature": z.string() })
export type SignedDelegateAction = z.infer<typeof SignedDelegateAction>


export const SignedTransaction = z.string()
export type SignedTransaction = z.infer<typeof SignedTransaction>


export const SignedTransactionView = z.object({ "actions": z.array(z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("CreateAccount"), z.object({ "DeployContract": z.object({ "code": z.string() }) }).strict(), z.object({ "FunctionCall": z.object({ "args": z.string().describe("This type is used to mark function arguments.\n\nNOTE: The main reason for this to exist (except the type-safety) is that the value is\ntransparently serialized and deserialized as a base64-encoded string when serde is used\n(serde_json)."), "deposit": z.string(), "gas": z.number().int().gte(0), "method_name": z.string() }) }).strict(), z.object({ "Transfer": z.object({ "deposit": z.string() }) }).strict(), z.object({ "Stake": z.object({ "public_key": z.string(), "stake": z.string() }) }).strict(), z.object({ "AddKey": z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("FullAccess"), z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "method_names": z.array(z.string()), "receiver_id": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the permission scope for an access key. Whether it is a function call or a full access key.") }).describe("Describes access key permission scope and nonce."), "public_key": z.string() }) }).strict(), z.object({ "DeleteKey": z.object({ "public_key": z.string() }) }).strict(), z.object({ "DeleteAccount": z.object({ "beneficiary_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "Delegate": z.object({ "delegate_action": z.object({ "actions": z.array(z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CreateAccount": z.record(z.any()).describe("Create account action") }).strict().describe("Create an (sub)account using a transaction `receiver_id` as an ID for\na new account ID must pass validation rules described here\n<https://nomicon.io/DataStructures/Account>."), z.object({ "DeployContract": z.object({ "code": z.string().describe("WebAssembly binary") }).describe("Deploy contract action") }).strict().describe("Sets a Wasm code to a receiver_id"), z.object({ "FunctionCall": z.object({ "args": z.string(), "deposit": z.string(), "gas": z.number().int().gte(0), "method_name": z.string() }) }).strict(), z.object({ "Transfer": z.object({ "deposit": z.string() }) }).strict(), z.object({ "Stake": z.object({ "public_key": z.string().describe("Validator key which will be used to sign transactions on behalf of signer_id"), "stake": z.string().describe("Amount of tokens to stake.") }).describe("An action which stakes signer_id tokens and setup's validator public key") }).strict(), z.object({ "AddKey": z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0).describe("Nonce for this access key, used for tx nonce generation. When access key is created, nonce\nis set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\nSee <https://github.com/near/nearcore/issues/3779> for more details."), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Allowance is a balance limit to use by this access key to pay for function call gas and\ntransaction fees. When this access key is used, both account balance and the allowance is\ndecreased by the same value.\n`None` means unlimited allowance.\nNOTE: To change or increase the allowance, the old access key needs to be deleted and a new\naccess key should be created.").optional(), "method_names": z.array(z.string()).describe("A list of method names that can be used. The access key only allows transactions with the\nfunction call of one of the given method names.\nEmpty list means any method name can be used."), "receiver_id": z.string().describe("The access key only allows transactions with the given receiver's account id.") }).describe("Grants limited permission to make transactions with FunctionCallActions\nThe permission can limit the allowed balance to be spent on the prepaid gas.\nIt also restrict the account ID of the receiver for this function call.\nIt also can restrict the method name for the allowed function calls.") }).strict(), z.literal("FullAccess").describe("Grants full access to the account.\nNOTE: It's used to replace account-level public keys.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Defines permissions for AccessKey").describe("Defines permissions for this access key.") }).describe("Access key provides limited access to an account. Each access key belongs to some account and\nis identified by a unique (within the account) public key. One account may have large number of\naccess keys. Access keys allow to act on behalf of the account by restricting transactions\nthat can be issued.\n`account_id,public_key` is a key in the state").describe("An access key with the permission"), "public_key": z.string().describe("A public key which will be associated with an access_key") }).describe("An action that adds key with public key associated") }).strict(), z.object({ "DeleteKey": z.object({ "public_key": z.string().describe("A public key associated with the access_key to be deleted.") }) }).strict(), z.object({ "DeleteAccount": z.object({ "beneficiary_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeployGlobalContract": z.object({ "code": z.string().describe("WebAssembly binary"), "deploy_mode": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("CodeHash").describe("Contract is deployed under its code hash.\nUsers will be able reference it by that hash.\nThis effectively makes the contract immutable."), z.literal("AccountId").describe("Contract is deployed under the owner account id.\nUsers will be able reference it by that account id.\nThis allows the owner to update the contract for all its users.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Deploy global contract action") }).strict(), z.object({ "UseGlobalContract": z.object({ "contract_identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Use global contract action") }).strict(), z.object({ "DeterministicStateInit": z.object({ "deposit": z.string(), "state_init": z.object({ "V1": z.object({ "code": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "data": z.record(z.string()) }) }).strict() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An Action that can be included in a transaction or receipt, excluding delegate actions. This type represents all possible action types except DelegateAction to prevent infinite recursion in meta-transactions.")).describe("List of actions to be executed.\n\nWith the meta transactions MVP defined in NEP-366, nested\nDelegateActions are not allowed. A separate type is used to enforce it."), "max_block_height": z.number().int().gte(0).describe("The maximal height of the block in the blockchain below which the given DelegateAction is valid."), "nonce": z.number().int().gte(0).describe("Nonce to ensure that the same delegate action is not sent twice by a\nrelayer and should match for given account's `public_key`.\nAfter this action is processed it will increment."), "public_key": z.string().describe("Public key used to sign this delegated action."), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("Receiver of the delegated actions."), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("Signer of the delegated actions") }).describe("This action allows to execute the inner actions behalf of the defined sender."), "signature": z.string() }) }).strict(), z.object({ "DeployGlobalContract": z.object({ "code": z.string() }) }).strict(), z.object({ "DeployGlobalContractByAccountId": z.object({ "code": z.string() }) }).strict(), z.object({ "UseGlobalContract": z.object({ "code_hash": z.string() }) }).strict(), z.object({ "UseGlobalContractByAccountId": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInit": z.object({ "code": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "hash": z.string() }).strict(), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }), "data": z.record(z.string()), "deposit": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })), "hash": z.string(), "nonce": z.number().int().gte(0), "priority_fee": z.number().int().gte(0).default(0), "public_key": z.string(), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "signature": z.string(), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") })
export type SignedTransactionView = z.infer<typeof SignedTransactionView>


export const SlashedValidator = z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "is_double_sign": z.boolean() })
export type SlashedValidator = z.infer<typeof SlashedValidator>


export const StakeAction = z.object({ "public_key": z.string().describe("Validator key which will be used to sign transactions on behalf of signer_id"), "stake": z.string().describe("Amount of tokens to stake.") }).describe("An action which stakes signer_id tokens and setup's validator public key")
export type StakeAction = z.infer<typeof StakeAction>


export const StateChangeCauseView = z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "type": z.literal("not_writable_to_disk") }), z.object({ "type": z.literal("initial_state") }), z.object({ "tx_hash": z.string(), "type": z.literal("transaction_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_processing_started") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_gas_reward") }), z.object({ "receipt_hash": z.string(), "type": z.literal("receipt_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("postponed_receipt") }), z.object({ "type": z.literal("updated_delayed_receipts") }), z.object({ "type": z.literal("validator_accounts_update") }), z.object({ "type": z.literal("migration") }), z.object({ "type": z.literal("bandwidth_scheduler_state_update") })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("See crate::types::StateChangeCause for details.")
export type StateChangeCauseView = z.infer<typeof StateChangeCauseView>


export const StateChangeKindView = z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "type": z.literal("account_touched") }), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "type": z.literal("access_key_touched") }), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "type": z.literal("data_touched") }), z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "type": z.literal("contract_code_touched") })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("It is a [serializable view] of [`StateChangeKind`].\n\n[serializable view]: ./index.html\n[`StateChangeKind`]: ../types/struct.StateChangeKind.html")
export type StateChangeKindView = z.infer<typeof StateChangeKindView>


export const StateChangeWithCauseView = z.record(z.any()).and(z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "cause": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "type": z.literal("not_writable_to_disk") }), z.object({ "type": z.literal("initial_state") }), z.object({ "tx_hash": z.string(), "type": z.literal("transaction_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_processing_started") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_gas_reward") }), z.object({ "receipt_hash": z.string(), "type": z.literal("receipt_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("postponed_receipt") }), z.object({ "type": z.literal("updated_delayed_receipts") }), z.object({ "type": z.literal("validator_accounts_update") }), z.object({ "type": z.literal("migration") }), z.object({ "type": z.literal("bandwidth_scheduler_state_update") })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("See crate::types::StateChangeCause for details."), "change": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "amount": z.string(), "code_hash": z.string(), "global_contract_account_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "global_contract_hash": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "locked": z.string(), "storage_paid_at": z.number().int().gte(0).describe("TODO(2271): deprecated.").default(0), "storage_usage": z.number().int().gte(0) }).describe("A view of the account"), "type": z.literal("account_update") }), z.object({ "cause": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "type": z.literal("not_writable_to_disk") }), z.object({ "type": z.literal("initial_state") }), z.object({ "tx_hash": z.string(), "type": z.literal("transaction_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_processing_started") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_gas_reward") }), z.object({ "receipt_hash": z.string(), "type": z.literal("receipt_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("postponed_receipt") }), z.object({ "type": z.literal("updated_delayed_receipts") }), z.object({ "type": z.literal("validator_accounts_update") }), z.object({ "type": z.literal("migration") }), z.object({ "type": z.literal("bandwidth_scheduler_state_update") })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("See crate::types::StateChangeCause for details."), "change": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }), "type": z.literal("account_deletion") }), z.object({ "cause": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "type": z.literal("not_writable_to_disk") }), z.object({ "type": z.literal("initial_state") }), z.object({ "tx_hash": z.string(), "type": z.literal("transaction_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_processing_started") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_gas_reward") }), z.object({ "receipt_hash": z.string(), "type": z.literal("receipt_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("postponed_receipt") }), z.object({ "type": z.literal("updated_delayed_receipts") }), z.object({ "type": z.literal("validator_accounts_update") }), z.object({ "type": z.literal("migration") }), z.object({ "type": z.literal("bandwidth_scheduler_state_update") })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("See crate::types::StateChangeCause for details."), "change": z.object({ "access_key": z.object({ "nonce": z.number().int().gte(0), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("FullAccess"), z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "method_names": z.array(z.string()), "receiver_id": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the permission scope for an access key. Whether it is a function call or a full access key.") }).describe("Describes access key permission scope and nonce."), "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }), "type": z.literal("access_key_update") }), z.object({ "cause": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "type": z.literal("not_writable_to_disk") }), z.object({ "type": z.literal("initial_state") }), z.object({ "tx_hash": z.string(), "type": z.literal("transaction_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_processing_started") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_gas_reward") }), z.object({ "receipt_hash": z.string(), "type": z.literal("receipt_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("postponed_receipt") }), z.object({ "type": z.literal("updated_delayed_receipts") }), z.object({ "type": z.literal("validator_accounts_update") }), z.object({ "type": z.literal("migration") }), z.object({ "type": z.literal("bandwidth_scheduler_state_update") })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("See crate::types::StateChangeCause for details."), "change": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }), "type": z.literal("access_key_deletion") }), z.object({ "cause": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "type": z.literal("not_writable_to_disk") }), z.object({ "type": z.literal("initial_state") }), z.object({ "tx_hash": z.string(), "type": z.literal("transaction_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_processing_started") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_gas_reward") }), z.object({ "receipt_hash": z.string(), "type": z.literal("receipt_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("postponed_receipt") }), z.object({ "type": z.literal("updated_delayed_receipts") }), z.object({ "type": z.literal("validator_accounts_update") }), z.object({ "type": z.literal("migration") }), z.object({ "type": z.literal("bandwidth_scheduler_state_update") })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("See crate::types::StateChangeCause for details."), "change": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "gas_key": z.object({ "balance": z.string(), "num_nonces": z.number().int().gte(0), "permission": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("FullAccess"), z.object({ "FunctionCall": z.object({ "allowance": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "method_names": z.array(z.string()), "receiver_id": z.string() }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the permission scope for an access key. Whether it is a function call or a full access key.") }), "public_key": z.string() }), "type": z.literal("gas_key_update") }), z.object({ "cause": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "type": z.literal("not_writable_to_disk") }), z.object({ "type": z.literal("initial_state") }), z.object({ "tx_hash": z.string(), "type": z.literal("transaction_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_processing_started") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_gas_reward") }), z.object({ "receipt_hash": z.string(), "type": z.literal("receipt_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("postponed_receipt") }), z.object({ "type": z.literal("updated_delayed_receipts") }), z.object({ "type": z.literal("validator_accounts_update") }), z.object({ "type": z.literal("migration") }), z.object({ "type": z.literal("bandwidth_scheduler_state_update") })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("See crate::types::StateChangeCause for details."), "change": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "index": z.number().int().gte(0), "nonce": z.number().int().gte(0), "public_key": z.string() }), "type": z.literal("gas_key_nonce_update") }), z.object({ "cause": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "type": z.literal("not_writable_to_disk") }), z.object({ "type": z.literal("initial_state") }), z.object({ "tx_hash": z.string(), "type": z.literal("transaction_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_processing_started") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_gas_reward") }), z.object({ "receipt_hash": z.string(), "type": z.literal("receipt_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("postponed_receipt") }), z.object({ "type": z.literal("updated_delayed_receipts") }), z.object({ "type": z.literal("validator_accounts_update") }), z.object({ "type": z.literal("migration") }), z.object({ "type": z.literal("bandwidth_scheduler_state_update") })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("See crate::types::StateChangeCause for details."), "change": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }), "type": z.literal("gas_key_deletion") }), z.object({ "cause": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "type": z.literal("not_writable_to_disk") }), z.object({ "type": z.literal("initial_state") }), z.object({ "tx_hash": z.string(), "type": z.literal("transaction_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_processing_started") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_gas_reward") }), z.object({ "receipt_hash": z.string(), "type": z.literal("receipt_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("postponed_receipt") }), z.object({ "type": z.literal("updated_delayed_receipts") }), z.object({ "type": z.literal("validator_accounts_update") }), z.object({ "type": z.literal("migration") }), z.object({ "type": z.literal("bandwidth_scheduler_state_update") })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("See crate::types::StateChangeCause for details."), "change": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "key_base64": z.string().describe("This type is used to mark keys (arrays of bytes) that are queried from store.\n\nNOTE: Currently, this type is only used in the view_client and RPC to be able to transparently\npretty-serialize the bytes arrays as base64-encoded strings (see `serialize.rs`)."), "value_base64": z.string().describe("This type is used to mark values returned from store (arrays of bytes).\n\nNOTE: Currently, this type is only used in the view_client and RPC to be able to transparently\npretty-serialize the bytes arrays as base64-encoded strings (see `serialize.rs`).") }), "type": z.literal("data_update") }), z.object({ "cause": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "type": z.literal("not_writable_to_disk") }), z.object({ "type": z.literal("initial_state") }), z.object({ "tx_hash": z.string(), "type": z.literal("transaction_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_processing_started") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_gas_reward") }), z.object({ "receipt_hash": z.string(), "type": z.literal("receipt_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("postponed_receipt") }), z.object({ "type": z.literal("updated_delayed_receipts") }), z.object({ "type": z.literal("validator_accounts_update") }), z.object({ "type": z.literal("migration") }), z.object({ "type": z.literal("bandwidth_scheduler_state_update") })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("See crate::types::StateChangeCause for details."), "change": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "key_base64": z.string().describe("This type is used to mark keys (arrays of bytes) that are queried from store.\n\nNOTE: Currently, this type is only used in the view_client and RPC to be able to transparently\npretty-serialize the bytes arrays as base64-encoded strings (see `serialize.rs`).") }), "type": z.literal("data_deletion") }), z.object({ "cause": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "type": z.literal("not_writable_to_disk") }), z.object({ "type": z.literal("initial_state") }), z.object({ "tx_hash": z.string(), "type": z.literal("transaction_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_processing_started") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_gas_reward") }), z.object({ "receipt_hash": z.string(), "type": z.literal("receipt_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("postponed_receipt") }), z.object({ "type": z.literal("updated_delayed_receipts") }), z.object({ "type": z.literal("validator_accounts_update") }), z.object({ "type": z.literal("migration") }), z.object({ "type": z.literal("bandwidth_scheduler_state_update") })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("See crate::types::StateChangeCause for details."), "change": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "code_base64": z.string() }), "type": z.literal("contract_code_update") }), z.object({ "cause": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "type": z.literal("not_writable_to_disk") }), z.object({ "type": z.literal("initial_state") }), z.object({ "tx_hash": z.string(), "type": z.literal("transaction_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_processing_started") }), z.object({ "receipt_hash": z.string(), "type": z.literal("action_receipt_gas_reward") }), z.object({ "receipt_hash": z.string(), "type": z.literal("receipt_processing") }), z.object({ "receipt_hash": z.string(), "type": z.literal("postponed_receipt") }), z.object({ "type": z.literal("updated_delayed_receipts") }), z.object({ "type": z.literal("validator_accounts_update") }), z.object({ "type": z.literal("migration") }), z.object({ "type": z.literal("bandwidth_scheduler_state_update") })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("See crate::types::StateChangeCause for details."), "change": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }), "type": z.literal("contract_code_deletion") })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }))
export type StateChangeWithCauseView = z.infer<typeof StateChangeWithCauseView>


export const StateItem = z.object({ "key": z.string().describe("This type is used to mark keys (arrays of bytes) that are queried from store.\n\nNOTE: Currently, this type is only used in the view_client and RPC to be able to transparently\npretty-serialize the bytes arrays as base64-encoded strings (see `serialize.rs`)."), "value": z.string().describe("This type is used to mark values returned from store (arrays of bytes).\n\nNOTE: Currently, this type is only used in the view_client and RPC to be able to transparently\npretty-serialize the bytes arrays as base64-encoded strings (see `serialize.rs`).") }).describe("Item of the state, key and value are serialized in base64 and proof for inclusion of given state item.")
export type StateItem = z.infer<typeof StateItem>


export const StateSyncConfig = z.object({ "concurrency": z.object({ "apply": z.number().int().gte(0).lte(255).describe("Maximum number of \"apply parts\" tasks that can be performed in parallel.\nThis is a very disk-heavy task and therefore we set this to a low limit,\nor else the rocksdb contention makes the whole server freeze up."), "apply_during_catchup": z.number().int().gte(0).lte(255).describe("Maximum number of \"apply parts\" tasks that can be performed in parallel\nduring catchup. We set this to a very low value to avoid overloading the\nnode while it is still performing normal tasks."), "peer_downloads": z.number().int().gte(0).lte(255).describe("Maximum number of outstanding requests for decentralized state sync."), "per_shard": z.number().int().gte(0).lte(255).describe("The maximum parallelism to use per shard. This is mostly for fairness, because\nthe actual rate limiting is done by the TaskTrackers, but this is useful for\nbalancing the shards a little.") }).optional(), "dump": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "credentials_file": z.union([z.string().describe("Location of a json file with credentials allowing access to the bucket."), z.null().describe("Location of a json file with credentials allowing access to the bucket.")]).describe("Location of a json file with credentials allowing access to the bucket.").optional(), "iteration_delay": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "nanos": z.number().int(), "secs": z.number().int() }), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("How often to check if a new epoch has started.\nFeel free to set to `None`, defaults are sensible.").optional(), "location": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "S3": z.object({ "bucket": z.string().describe("Location on S3."), "region": z.string().describe("Data may only be available in certain locations.") }) }).strict(), z.object({ "Filesystem": z.object({ "root_dir": z.string() }) }).strict().describe("Local filesystem root for storing data."), z.object({ "GCS": z.object({ "bucket": z.string() }) }).strict().describe("Google Cloud Storage bucket name.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Supported external storage backends and their minimal config.").describe("Specifies where to write the obtained state parts."), "restart_dump_for_shards": z.union([z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias.")).describe("Use in case a node that dumps state to the external storage\ngets in trouble."), z.null().describe("Use in case a node that dumps state to the external storage\ngets in trouble.")]).describe("Use in case a node that dumps state to the external storage\ngets in trouble.").optional() }).describe("Configures how to dump state to external storage."), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("`none` value disables state dump to external storage.").optional(), "parts_compression_lvl": z.number().int().describe("Zstd compression level for state parts.").default(1), "sync": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Peers").describe("Syncs state from the peers without reading anything from external storage."), z.object({ "ExternalStorage": z.object({ "external_storage_fallback_threshold": z.number().int().gte(0).describe("The number of attempts the node will make to obtain a part from peers in\nthe network before it fetches from external storage.").default(3), "location": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "S3": z.object({ "bucket": z.string().describe("Location on S3."), "region": z.string().describe("Data may only be available in certain locations.") }) }).strict(), z.object({ "Filesystem": z.object({ "root_dir": z.string() }) }).strict().describe("Local filesystem root for storing data."), z.object({ "GCS": z.object({ "bucket": z.string() }) }).strict().describe("Google Cloud Storage bucket name.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Supported external storage backends and their minimal config.").describe("Location of state parts."), "num_concurrent_requests": z.number().int().gte(0).lte(255).describe("When fetching state parts from external storage, throttle fetch requests\nto this many concurrent requests.").default(25), "num_concurrent_requests_during_catchup": z.number().int().gte(0).lte(255).describe("During catchup, the node will use a different number of concurrent requests\nto reduce the performance impact of state sync.").default(5) }) }).strict().describe("Expects parts to be available in external storage.\n\nUsually as a fallback after some number of attempts to use peers.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Configures how to fetch state parts during state sync.").optional() })
export type StateSyncConfig = z.infer<typeof StateSyncConfig>


export const StatusSyncInfo = z.object({ "earliest_block_hash": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "earliest_block_height": z.union([z.number().int().gte(0), z.null()]).optional(), "earliest_block_time": z.union([z.string(), z.null()]).optional(), "epoch_id": z.any().superRefine((x, ctx) => {
    const schemas = [z.string().describe("Epoch identifier -- wrapped hash, to make it easier to distinguish.\nEpochId of epoch T is the hash of last block in T-2\nEpochId of first two epochs is 0"), z.null()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).optional(), "epoch_start_height": z.union([z.number().int().gte(0), z.null()]).optional(), "latest_block_hash": z.string(), "latest_block_height": z.number().int().gte(0), "latest_block_time": z.string(), "latest_state_root": z.string(), "syncing": z.boolean() })
export type StatusSyncInfo = z.infer<typeof StatusSyncInfo>


export const StorageError = z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("StorageInternalError").describe("Key-value db internal failure"), z.object({ "MissingTrieValue": z.object({ "context": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("TrieIterator").describe("Missing trie value when reading from TrieIterator."), z.literal("TriePrefetchingStorage").describe("Missing trie value when reading from TriePrefetchingStorage."), z.literal("TrieMemoryPartialStorage").describe("Missing trie value when reading from TrieMemoryPartialStorage."), z.literal("TrieStorage").describe("Missing trie value when reading from TrieStorage.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Contexts in which `StorageError::MissingTrieValue` error might occur."), "hash": z.string() }) }).strict().describe("Requested trie value by its hash which is missing in storage."), z.literal("UnexpectedTrieValue").describe("Found trie node which shouldn't be part of state. Raised during\nvalidation of state sync parts where incorrect node was passed.\nTODO (#8997): consider including hash of trie node."), z.object({ "StorageInconsistentState": z.string() }).strict().describe("Either invalid state or key-value db is corrupted.\nFor PartialStorage it cannot be corrupted.\nError message is unreliable and for debugging purposes only. It's also probably ok to\npanic in every place that produces this error.\nWe can check if db is corrupted by verifying everything in the state trie."), z.object({ "FlatStorageBlockNotSupported": z.string() }).strict().describe("Flat storage error, meaning that it doesn't support some block anymore.\nWe guarantee that such block cannot become final, thus block processing\nmust resume normally."), z.object({ "MemTrieLoadingError": z.string() }).strict().describe("In-memory trie could not be loaded for some reason.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Errors which may occur during working with trie storages, storing\ntrie values (trie nodes and state values) by their hashes.")
export type StorageError = z.infer<typeof StorageError>


export const StorageGetMode = z.enum(["FlatStorage","Trie"]).describe("This enum represents if a storage_get call will be performed through flat storage or trie")
export type StorageGetMode = z.infer<typeof StorageGetMode>


export const StorageUsageConfigView = z.object({ "num_bytes_account": z.number().int().gte(0).describe("Number of bytes for an account record, including rounding up for account id."), "num_extra_bytes_record": z.number().int().gte(0).describe("Additional number of bytes for a k/v record") }).describe("Describes cost of storage per block")
export type StorageUsageConfigView = z.infer<typeof StorageUsageConfigView>


export const StoreKey = z.string().describe("This type is used to mark keys (arrays of bytes) that are queried from store.\n\nNOTE: Currently, this type is only used in the view_client and RPC to be able to transparently\npretty-serialize the bytes arrays as base64-encoded strings (see `serialize.rs`).")
export type StoreKey = z.infer<typeof StoreKey>


export const StoreValue = z.string().describe("This type is used to mark values returned from store (arrays of bytes).\n\nNOTE: Currently, this type is only used in the view_client and RPC to be able to transparently\npretty-serialize the bytes arrays as base64-encoded strings (see `serialize.rs`).")
export type StoreValue = z.infer<typeof StoreValue>


export const SyncCheckpoint = z.enum(["genesis","earliest_available"])
export type SyncCheckpoint = z.infer<typeof SyncCheckpoint>


export const SyncConcurrency = z.object({ "apply": z.number().int().gte(0).lte(255).describe("Maximum number of \"apply parts\" tasks that can be performed in parallel.\nThis is a very disk-heavy task and therefore we set this to a low limit,\nor else the rocksdb contention makes the whole server freeze up."), "apply_during_catchup": z.number().int().gte(0).lte(255).describe("Maximum number of \"apply parts\" tasks that can be performed in parallel\nduring catchup. We set this to a very low value to avoid overloading the\nnode while it is still performing normal tasks."), "peer_downloads": z.number().int().gte(0).lte(255).describe("Maximum number of outstanding requests for decentralized state sync."), "per_shard": z.number().int().gte(0).lte(255).describe("The maximum parallelism to use per shard. This is mostly for fairness, because\nthe actual rate limiting is done by the TaskTrackers, but this is useful for\nbalancing the shards a little.") })
export type SyncConcurrency = z.infer<typeof SyncConcurrency>


export const SyncConfig = z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Peers").describe("Syncs state from the peers without reading anything from external storage."), z.object({ "ExternalStorage": z.object({ "external_storage_fallback_threshold": z.number().int().gte(0).describe("The number of attempts the node will make to obtain a part from peers in\nthe network before it fetches from external storage.").default(3), "location": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "S3": z.object({ "bucket": z.string().describe("Location on S3."), "region": z.string().describe("Data may only be available in certain locations.") }) }).strict(), z.object({ "Filesystem": z.object({ "root_dir": z.string() }) }).strict().describe("Local filesystem root for storing data."), z.object({ "GCS": z.object({ "bucket": z.string() }) }).strict().describe("Google Cloud Storage bucket name.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Supported external storage backends and their minimal config.").describe("Location of state parts."), "num_concurrent_requests": z.number().int().gte(0).lte(255).describe("When fetching state parts from external storage, throttle fetch requests\nto this many concurrent requests.").default(25), "num_concurrent_requests_during_catchup": z.number().int().gte(0).lte(255).describe("During catchup, the node will use a different number of concurrent requests\nto reduce the performance impact of state sync.").default(5) }) }).strict().describe("Expects parts to be available in external storage.\n\nUsually as a fallback after some number of attempts to use peers.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Configures how to fetch state parts during state sync.")
export type SyncConfig = z.infer<typeof SyncConfig>


export const Tier1ProxyView = z.object({ "addr": z.string(), "peer_id": z.string() })
export type Tier1ProxyView = z.infer<typeof Tier1ProxyView>


export const TrackedShardsConfig = z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("NoShards").describe("Tracks no shards (light client)."), z.object({ "Shards": z.array(z.object({ "shard_id": z.number().int().gte(0), "version": z.number().int().gte(0) }).describe("`ShardUId` is a unique representation for shards from different shard layouts.\n\nComparing to `ShardId`, which is just an ordinal number ranging from 0 to NUM_SHARDS-1,\n`ShardUId` provides a way to unique identify shards when shard layouts may change across epochs.\nThis is important because we store states indexed by shards in our database, so we need a\nway to unique identify shard even when shards change across epochs.\nAnother difference between `ShardUId` and `ShardId` is that `ShardUId` should only exist in\na node's internal state while `ShardId` can be exposed to outside APIs and used in protocol\nlevel information (for example, `ShardChunkHeader` contains `ShardId` instead of `ShardUId`)")) }).strict().describe("Tracks arbitrary shards."), z.literal("AllShards").describe("Tracks all shards."), z.object({ "ShadowValidator": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict().describe("Tracks shards that are assigned to given validator account."), z.object({ "Schedule": z.array(z.array(z.number().int().gte(0).describe("The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias."))) }).strict().describe("Rotate between these sets of tracked shards.\nUsed to simulate the behavior of chunk only producers without staking tokens."), z.object({ "Accounts": z.array(z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```")) }).strict().describe("Tracks shards that contain one of the given account.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the expected behavior of the node regarding shard tracking.\nIf the node is an active validator, it will also track the shards it is responsible for as a validator.")
export type TrackedShardsConfig = z.infer<typeof TrackedShardsConfig>


export const TransferAction = z.object({ "deposit": z.string() })
export type TransferAction = z.infer<typeof TransferAction>


export const TxExecutionError = z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "ActionError": z.object({ "index": z.union([z.number().int().gte(0).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`"), z.null().describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`")]).describe("Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`").optional(), "kind": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccountAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage"), z.object({ "AccountDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Happens when TX receiver_id doesn't exist (but action is not Action::CreateAccount)"), z.object({ "CreateAccountOnlyByRegistrar": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "registrar_account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A top-level account ID can only be created by registrar."), z.object({ "CreateAccountNotAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "predecessor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("A newly created account must be under a namespace of the creator account"), z.object({ "ActorNoPermission": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "actor_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\nor the first TX action is a `CreateAccount` action"), z.object({ "DeleteKeyDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("Account tries to remove an access key that doesn't exist"), z.object({ "AddKeyAlreadyExists": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The public key is already used for an existing access key"), z.object({ "DeleteAccountStaking": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is staking and can not be deleted"), z.object({ "LackBalanceForState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which needs balance"), "amount": z.string().describe("Balance required to complete an action.") }) }).strict().describe("ActionReceipt can't be completed, because the remaining balance will not be enough to cover storage."), z.object({ "TriesToUnstake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account is not yet staked, but tries to unstake"), z.object({ "TriesToStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "balance": z.string(), "locked": z.string(), "stake": z.string() }) }).strict().describe("The account doesn't have enough balance to increase the stake."), z.object({ "InsufficientStake": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "minimum_stake": z.string(), "stake": z.string() }) }).strict(), z.object({ "FunctionCallError": z.any().superRefine((x, ctx) => {
    const schemas = [z.enum(["WasmUnknownError","_EVMError"]), z.object({ "CompilationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeDoesNotExist": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "PrepareError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Serialization").describe("Error happened while serializing the module."), z.literal("Deserialization").describe("Error happened while deserializing the module."), z.literal("InternalMemoryDeclared").describe("Internal memory declaration has been found in the module."), z.literal("GasInstrumentation").describe("Gas instrumentation failed.\n\nThis most likely indicates the module isn't valid."), z.literal("StackHeightInstrumentation").describe("Stack instrumentation failed.\n\nThis  most likely indicates the module isn't valid."), z.literal("Instantiate").describe("Error happened during instantiation.\n\nThis might indicate that `start` function trapped, or module isn't\ninstantiable and/or un-linkable."), z.literal("Memory").describe("Error creating memory."), z.literal("TooManyFunctions").describe("Contract contains too many functions."), z.literal("TooManyLocals").describe("Contract contains too many locals."), z.literal("TooManyTables").describe("Contract contains too many tables."), z.literal("TooManyTableElements").describe("Contract contains too many table elements.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error that can occur while preparing or executing Wasm smart-contract.") }).strict(), z.object({ "WasmerCompileError": z.object({ "msg": z.string() }) }).strict().describe("This is for defense in depth.\nWe expect our runtime-independent preparation code to fully catch all invalid wasms,\nbut, if it ever misses something we’ll emit this error")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Wasm compilation error"), z.object({ "LinkError": z.object({ "msg": z.string() }) }).strict().describe("Wasm binary env link error\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "MethodResolveError": z.enum(["MethodEmptyName","MethodNotFound","MethodInvalidSignature"]) }).strict().describe("Import/export resolve error"), z.object({ "WasmTrap": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unreachable").describe("An `unreachable` opcode was executed."), z.literal("IncorrectCallIndirectSignature").describe("Call indirect incorrect signature trap."), z.literal("MemoryOutOfBounds").describe("Memory out of bounds trap."), z.literal("CallIndirectOOB").describe("Call indirect out of bounds trap."), z.literal("IllegalArithmetic").describe("An arithmetic exception, e.g. divided by zero."), z.literal("MisalignedAtomicAccess").describe("Misaligned atomic access trap."), z.literal("IndirectCallToNull").describe("Indirect call to null."), z.literal("StackOverflow").describe("Stack overflow."), z.literal("GenericTrap").describe("Generic trap.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("A kind of a trap happened during execution of a binary") }).strict().describe("A trap happened during execution of a binary\n\nNote: this is only to deserialize old data, use execution error for new data"), z.object({ "HostError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("BadUTF16").describe("String encoding is bad UTF-16 sequence"), z.literal("BadUTF8").describe("String encoding is bad UTF-8 sequence"), z.literal("GasExceeded").describe("Exceeded the prepaid gas"), z.literal("GasLimitExceeded").describe("Exceeded the maximum amount of gas allowed to burn per contract"), z.literal("BalanceExceeded").describe("Exceeded the account balance"), z.literal("EmptyMethodName").describe("Tried to call an empty method name"), z.object({ "GuestPanic": z.object({ "panic_msg": z.string() }) }).strict().describe("Smart contract panicked"), z.literal("IntegerOverflow").describe("IntegerOverflow happened during a contract execution"), z.object({ "InvalidPromiseIndex": z.object({ "promise_idx": z.number().int().gte(0) }) }).strict().describe("`promise_idx` does not correspond to existing promises"), z.literal("CannotAppendActionToJointPromise").describe("Actions can only be appended to non-joint promise."), z.literal("CannotReturnJointPromise").describe("Returning joint promise is currently prohibited"), z.object({ "InvalidPromiseResultIndex": z.object({ "result_idx": z.number().int().gte(0) }) }).strict().describe("Accessed invalid promise result index"), z.object({ "InvalidRegisterId": z.object({ "register_id": z.number().int().gte(0) }) }).strict().describe("Accessed invalid register id"), z.object({ "IteratorWasInvalidated": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie"), z.literal("MemoryAccessViolation").describe("Accessed memory outside the bounds"), z.object({ "InvalidReceiptIndex": z.object({ "receipt_index": z.number().int().gte(0) }) }).strict().describe("VM Logic returned an invalid receipt index"), z.object({ "InvalidIteratorIndex": z.object({ "iterator_index": z.number().int().gte(0) }) }).strict().describe("Iterator index `iterator_index` does not exist"), z.literal("InvalidAccountId").describe("VM Logic returned an invalid account id"), z.literal("InvalidMethodName").describe("VM Logic returned an invalid method name"), z.literal("InvalidPublicKey").describe("VM Logic provided an invalid public key"), z.object({ "ProhibitedInView": z.object({ "method_name": z.string() }) }).strict().describe("`method_name` is not allowed in view calls"), z.object({ "NumberOfLogsExceeded": z.object({ "limit": z.number().int().gte(0) }) }).strict().describe("The total number of logs will exceed the limit."), z.object({ "KeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage key length exceeded the limit."), z.object({ "ValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The storage value length exceeded the limit."), z.object({ "TotalLogLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The total log length exceeded the limit."), z.object({ "NumberPromisesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_promises": z.number().int().gte(0) }) }).strict().describe("The maximum number of promises within a FunctionCall exceeded the limit."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The maximum number of input data dependencies exceeded the limit."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The returned value length exceeded the limit."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The contract size for DeployContract action exceeded the limit."), z.object({ "Deprecated": z.object({ "method_name": z.string() }) }).strict().describe("The host function was deprecated."), z.object({ "ECRecoverError": z.object({ "msg": z.string() }) }).strict().describe("General errors for ECDSA recover."), z.object({ "AltBn128InvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to alt_bn128 family of functions (e.g., point which isn't\non the curve)."), z.object({ "Ed25519VerifyInvalidInput": z.object({ "msg": z.string() }) }).strict().describe("Invalid input to ed25519 signature verification function (e.g. signature cannot be\nderived from bytes).")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Note: this is only to deserialize old data, use execution error for new data"), z.object({ "ExecutionError": z.string() }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Serializable version of `near-vm-runner::FunctionCallError`.\n\nMust never reorder/remove elements, can only add new variants at the end (but do that very\ncarefully). It describes stable serialization format, and only used by serialization logic.") }).strict().describe("An error occurred during a `FunctionCall` Action, parameter is debug message."), z.object({ "NewReceiptValidationError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidPredecessorId": z.object({ "account_id": z.string() }) }).strict().describe("The `predecessor_id` of a Receipt is not valid."), z.object({ "InvalidReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a Receipt is not valid."), z.object({ "InvalidSignerId": z.object({ "account_id": z.string() }) }).strict().describe("The `signer_id` of an ActionReceipt is not valid."), z.object({ "InvalidDataReceiverId": z.object({ "account_id": z.string() }) }).strict().describe("The `receiver_id` of a DataReceiver within an ActionReceipt is not valid."), z.object({ "ReturnedValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the returned data exceeded the limit in a DataReceipt."), z.object({ "NumberInputDataDependenciesExceeded": z.object({ "limit": z.number().int().gte(0), "number_of_input_data_dependencies": z.number().int().gte(0) }) }).strict().describe("The number of input data dependencies exceeds the limit in an ActionReceipt."), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of an ActionReceipt."), z.object({ "ReceiptSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("Receipt is bigger than the limit."), z.object({ "InvalidRefundTo": z.object({ "account_id": z.string() }) }).strict().describe("The `refund_to` of an ActionReceipt is not valid.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a receipt.") }).strict().describe("Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\nreceipt validation."), z.object({ "OnlyImplicitAccountCreationAllowed": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\nSee NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\nAlso, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\nTODO(#8598): This error is named very poorly. A better name would be\n`OnlyNamedAccountCreationAllowed`."), z.object({ "DeleteAccountWithLargeState": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Delete account whose state is large is temporarily banned."), z.literal("DelegateActionInvalidSignature").describe("Signature does not match the provided actions and given signer public key."), z.object({ "DelegateActionSenderDoesNotMatchTxReceiver": z.object({ "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "sender_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Receiver of the transaction doesn't match Sender of the delegate action"), z.literal("DelegateActionExpired").describe("Delegate action has expired. `max_block_height` is less than actual block height."), z.object({ "DelegateActionAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("The given public key doesn't exist for Sender account"), z.object({ "DelegateActionInvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "delegate_nonce": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce must be greater sender[public_key].nonce"), z.object({ "DelegateActionNonceTooLarge": z.object({ "delegate_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("DelegateAction nonce is larger than the upper bound given by the block height"), z.object({ "GlobalContractDoesNotExist": z.object({ "identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("The kind of ActionError happened") }).describe("An error happened during Action execution") }).strict().describe("An error happened during Action execution"), z.object({ "InvalidTxError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "InvalidAccessKeyError": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "AccessKeyNotFound": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string() }) }).strict().describe("The access key identified by the `public_key` doesn't exist for the account"), z.object({ "ReceiverMismatch": z.object({ "ak_receiver": z.string(), "tx_receiver": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Transaction `receiver_id` doesn't match the access key receiver_id"), z.object({ "MethodNameMismatch": z.object({ "method_name": z.string() }) }).strict().describe("Transaction method name isn't allowed by the access key"), z.literal("RequiresFullAccess").describe("Transaction requires a full permission access key."), z.object({ "NotEnoughAllowance": z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "allowance": z.string(), "cost": z.string(), "public_key": z.string() }) }).strict().describe("Access Key does not have enough allowance to cover transaction cost"), z.literal("DepositWithFunctionCall").describe("Having a deposit with a function call action is not allowed with a function call access key.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).strict().describe("Happens if a wrong AccessKey used or AccessKey has not enough permissions"), z.object({ "InvalidSignerId": z.object({ "signer_id": z.string() }) }).strict().describe("TX signer_id is not a valid [`AccountId`]"), z.object({ "SignerDoesNotExist": z.object({ "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("TX signer_id is not found in a storage"), z.object({ "InvalidNonce": z.object({ "ak_nonce": z.number().int().gte(0), "tx_nonce": z.number().int().gte(0) }) }).strict().describe("Transaction nonce must be strictly greater than `account[access_key].nonce`."), z.object({ "NonceTooLarge": z.object({ "tx_nonce": z.number().int().gte(0), "upper_bound": z.number().int().gte(0) }) }).strict().describe("Transaction nonce is larger than the upper bound given by the block height"), z.object({ "InvalidReceiverId": z.object({ "receiver_id": z.string() }) }).strict().describe("TX receiver_id is not a valid AccountId"), z.literal("InvalidSignature").describe("TX signature is not valid"), z.object({ "NotEnoughBalance": z.object({ "balance": z.string(), "cost": z.string(), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict().describe("Account does not have enough balance to cover TX cost"), z.object({ "LackBalanceForState": z.object({ "amount": z.string().describe("Required balance to cover the state."), "signer_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```").describe("An account which doesn't have enough balance to cover storage.") }) }).strict().describe("Signer account doesn't have enough balance after transaction."), z.literal("CostOverflow").describe("An integer overflow occurred during transaction cost estimation."), z.literal("InvalidChain").describe("Transaction parent block hash doesn't belong to the current chain"), z.literal("Expired").describe("Transaction has expired"), z.object({ "ActionsValidation": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("DeleteActionMustBeFinal").describe("The delete action must be a final action in transaction"), z.object({ "TotalPrepaidGasExceeded": z.object({ "limit": z.number().int().gte(0), "total_prepaid_gas": z.number().int().gte(0) }) }).strict().describe("The total prepaid gas (for all given actions) exceeded the limit."), z.object({ "TotalNumberOfActionsExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_actions": z.number().int().gte(0) }) }).strict().describe("The number of actions exceeded the given limit."), z.object({ "AddKeyMethodNamesNumberOfBytesExceeded": z.object({ "limit": z.number().int().gte(0), "total_number_of_bytes": z.number().int().gte(0) }) }).strict().describe("The total number of bytes of the method names exceeded the limit in a Add Key action."), z.object({ "AddKeyMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of some method name exceeded the limit in a Add Key action."), z.literal("IntegerOverflow").describe("Integer overflow during a compute."), z.object({ "InvalidAccountId": z.object({ "account_id": z.string() }) }).strict().describe("Invalid account ID."), z.object({ "ContractSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of the contract code exceeded the limit in a DeployContract action."), z.object({ "FunctionCallMethodNameLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the method name exceeded the limit in a Function Call action."), z.object({ "FunctionCallArgumentsLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict().describe("The length of the arguments exceeded the limit in a Function Call action."), z.object({ "UnsuitableStakingKey": z.object({ "public_key": z.string() }) }).strict().describe("An attempt to stake with a public key that is not convertible to ristretto."), z.literal("FunctionCallZeroAttachedGas").describe("The attached amount of gas in a FunctionCall action has to be a positive number."), z.literal("DelegateActionMustBeOnlyOne").describe("There should be the only one DelegateAction"), z.object({ "UnsupportedProtocolFeature": z.object({ "protocol_feature": z.string(), "version": z.number().int().gte(0) }) }).strict().describe("The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."), z.object({ "InvalidDeterministicStateInitReceiver": z.object({ "derived_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "receiver_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }) }).strict(), z.object({ "DeterministicStateInitKeyLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict(), z.object({ "DeterministicStateInitValueLengthExceeded": z.object({ "length": z.number().int().gte(0), "limit": z.number().int().gte(0) }) }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Describes the error for validating a list of actions.") }).strict().describe("An error occurred while validating actions of a Transaction."), z.object({ "TransactionSizeExceeded": z.object({ "limit": z.number().int().gte(0), "size": z.number().int().gte(0) }) }).strict().describe("The size of serialized transaction exceeded the limit."), z.literal("InvalidTransactionVersion").describe("Transaction version is invalid."), z.object({ "StorageError": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("StorageInternalError").describe("Key-value db internal failure"), z.object({ "MissingTrieValue": z.object({ "context": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("TrieIterator").describe("Missing trie value when reading from TrieIterator."), z.literal("TriePrefetchingStorage").describe("Missing trie value when reading from TriePrefetchingStorage."), z.literal("TrieMemoryPartialStorage").describe("Missing trie value when reading from TrieMemoryPartialStorage."), z.literal("TrieStorage").describe("Missing trie value when reading from TrieStorage.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Contexts in which `StorageError::MissingTrieValue` error might occur."), "hash": z.string() }) }).strict().describe("Requested trie value by its hash which is missing in storage."), z.literal("UnexpectedTrieValue").describe("Found trie node which shouldn't be part of state. Raised during\nvalidation of state sync parts where incorrect node was passed.\nTODO (#8997): consider including hash of trie node."), z.object({ "StorageInconsistentState": z.string() }).strict().describe("Either invalid state or key-value db is corrupted.\nFor PartialStorage it cannot be corrupted.\nError message is unreliable and for debugging purposes only. It's also probably ok to\npanic in every place that produces this error.\nWe can check if db is corrupted by verifying everything in the state trie."), z.object({ "FlatStorageBlockNotSupported": z.string() }).strict().describe("Flat storage error, meaning that it doesn't support some block anymore.\nWe guarantee that such block cannot become final, thus block processing\nmust resume normally."), z.object({ "MemTrieLoadingError": z.string() }).strict().describe("In-memory trie could not be loaded for some reason.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Errors which may occur during working with trie storages, storing\ntrie values (trie nodes and state values) by their hashes.") }).strict(), z.object({ "ShardCongested": z.object({ "congestion_level": z.number().describe("A value between 0 (no congestion) and 1 (max congestion)."), "shard_id": z.number().int().gte(0).describe("The congested shard.") }) }).strict().describe("The receiver shard of the transaction is too congested to accept new\ntransactions at the moment."), z.object({ "ShardStuck": z.object({ "missed_chunks": z.number().int().gte(0).describe("The number of blocks since the last included chunk of the shard."), "shard_id": z.number().int().gte(0).describe("The shard that fails making progress.") }) }).strict().describe("The receiver shard of the transaction missed several chunks and rejects\nnew transaction until it can make progress again.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("An error happened during TX execution") }).strict().describe("An error happened during Transaction execution")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Error returned in the ExecutionOutcome in case of failure")
export type TxExecutionError = z.infer<typeof TxExecutionError>


export const TxExecutionStatus = z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("NONE").describe("Transaction is waiting to be included into the block"), z.literal("INCLUDED").describe("Transaction is included into the block. The block may be not finalized yet"), z.literal("EXECUTED_OPTIMISTIC").describe("Transaction is included into the block +\nAll non-refund transaction receipts finished their execution.\nThe corresponding blocks for tx and each receipt may be not finalized yet"), z.literal("INCLUDED_FINAL").describe("Transaction is included into finalized block"), z.literal("EXECUTED").describe("Transaction is included into finalized block +\nAll non-refund transaction receipts finished their execution.\nThe corresponding blocks for each receipt may be not finalized yet"), z.literal("FINAL").describe("Transaction is included into finalized block +\nExecution of all transaction receipts is finalized, including refund receipts")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })
export type TxExecutionStatus = z.infer<typeof TxExecutionStatus>


export const UseGlobalContractAction = z.object({ "contract_identifier": z.any().superRefine((x, ctx) => {
    const schemas = [z.object({ "CodeHash": z.string() }).strict(), z.object({ "AccountId": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") }).strict()];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) }).describe("Use global contract action")
export type UseGlobalContractAction = z.infer<typeof UseGlobalContractAction>


export const VMConfigView = z.object({ "deterministic_account_ids": z.boolean().describe("See [VMConfig::deterministic_account_ids](crate::vm::Config::deterministic_account_ids)."), "discard_custom_sections": z.boolean().describe("See [VMConfig::discard_custom_sections](crate::vm::Config::discard_custom_sections)."), "eth_implicit_accounts": z.boolean().describe("See [VMConfig::eth_implicit_accounts](crate::vm::Config::eth_implicit_accounts)."), "ext_costs": z.object({ "alt_bn128_g1_multiexp_base": z.number().int().gte(0).describe("Base cost for multiexp"), "alt_bn128_g1_multiexp_element": z.number().int().gte(0).describe("Per element cost for multiexp"), "alt_bn128_g1_sum_base": z.number().int().gte(0).describe("Base cost for sum"), "alt_bn128_g1_sum_element": z.number().int().gte(0).describe("Per element cost for sum"), "alt_bn128_pairing_check_base": z.number().int().gte(0).describe("Base cost for pairing check"), "alt_bn128_pairing_check_element": z.number().int().gte(0).describe("Per element cost for pairing check"), "base": z.number().int().gte(0).describe("Base cost for calling a host function."), "bls12381_g1_multiexp_base": z.number().int().gte(0), "bls12381_g1_multiexp_element": z.number().int().gte(0), "bls12381_g2_multiexp_base": z.number().int().gte(0), "bls12381_g2_multiexp_element": z.number().int().gte(0), "bls12381_map_fp2_to_g2_base": z.number().int().gte(0), "bls12381_map_fp2_to_g2_element": z.number().int().gte(0), "bls12381_map_fp_to_g1_base": z.number().int().gte(0), "bls12381_map_fp_to_g1_element": z.number().int().gte(0), "bls12381_p1_decompress_base": z.number().int().gte(0), "bls12381_p1_decompress_element": z.number().int().gte(0), "bls12381_p1_sum_base": z.number().int().gte(0), "bls12381_p1_sum_element": z.number().int().gte(0), "bls12381_p2_decompress_base": z.number().int().gte(0), "bls12381_p2_decompress_element": z.number().int().gte(0), "bls12381_p2_sum_base": z.number().int().gte(0), "bls12381_p2_sum_element": z.number().int().gte(0), "bls12381_pairing_base": z.number().int().gte(0), "bls12381_pairing_element": z.number().int().gte(0), "contract_compile_base": z.number().int().gte(0), "contract_compile_bytes": z.number().int().gte(0), "contract_loading_base": z.number().int().gte(0).describe("Base cost of loading a pre-compiled contract"), "contract_loading_bytes": z.number().int().gte(0).describe("Cost per byte of loading a pre-compiled contract"), "ecrecover_base": z.number().int().gte(0).describe("Cost of calling ecrecover"), "ed25519_verify_base": z.number().int().gte(0).describe("Cost of getting ed25519 base"), "ed25519_verify_byte": z.number().int().gte(0).describe("Cost of getting ed25519 per byte"), "keccak256_base": z.number().int().gte(0).describe("Cost of getting sha256 base"), "keccak256_byte": z.number().int().gte(0).describe("Cost of getting sha256 per byte"), "keccak512_base": z.number().int().gte(0).describe("Cost of getting sha256 base"), "keccak512_byte": z.number().int().gte(0).describe("Cost of getting sha256 per byte"), "log_base": z.number().int().gte(0).describe("Cost for calling logging."), "log_byte": z.number().int().gte(0).describe("Cost for logging per byte"), "promise_and_base": z.number().int().gte(0).describe("Cost for calling `promise_and`"), "promise_and_per_promise": z.number().int().gte(0).describe("Cost for calling `promise_and` for each promise"), "promise_return": z.number().int().gte(0).describe("Cost for calling `promise_return`"), "read_cached_trie_node": z.number().int().gte(0).describe("Cost for reading trie node from memory"), "read_memory_base": z.number().int().gte(0).describe("Base cost for guest memory read"), "read_memory_byte": z.number().int().gte(0).describe("Cost for guest memory read"), "read_register_base": z.number().int().gte(0).describe("Base cost for reading from register"), "read_register_byte": z.number().int().gte(0).describe("Cost for reading byte from register"), "ripemd160_base": z.number().int().gte(0).describe("Cost of getting ripemd160 base"), "ripemd160_block": z.number().int().gte(0).describe("Cost of getting ripemd160 per message block"), "sha256_base": z.number().int().gte(0).describe("Cost of getting sha256 base"), "sha256_byte": z.number().int().gte(0).describe("Cost of getting sha256 per byte"), "storage_has_key_base": z.number().int().gte(0).describe("Storage trie check for key existence cost base"), "storage_has_key_byte": z.number().int().gte(0).describe("Storage trie check for key existence per key byte"), "storage_iter_create_from_byte": z.number().int().gte(0).describe("Create trie range iterator cost per byte of from key."), "storage_iter_create_prefix_base": z.number().int().gte(0).describe("Create trie prefix iterator cost base"), "storage_iter_create_prefix_byte": z.number().int().gte(0).describe("Create trie prefix iterator cost per byte."), "storage_iter_create_range_base": z.number().int().gte(0).describe("Create trie range iterator cost base"), "storage_iter_create_to_byte": z.number().int().gte(0).describe("Create trie range iterator cost per byte of to key."), "storage_iter_next_base": z.number().int().gte(0).describe("Trie iterator per key base cost"), "storage_iter_next_key_byte": z.number().int().gte(0).describe("Trie iterator next key byte cost"), "storage_iter_next_value_byte": z.number().int().gte(0).describe("Trie iterator next key byte cost"), "storage_large_read_overhead_base": z.number().int().gte(0).describe("Storage trie read key overhead base cost, when doing large reads"), "storage_large_read_overhead_byte": z.number().int().gte(0).describe("Storage trie read key overhead  per-byte cost, when doing large reads"), "storage_read_base": z.number().int().gte(0).describe("Storage trie read key base cost"), "storage_read_key_byte": z.number().int().gte(0).describe("Storage trie read key per byte cost"), "storage_read_value_byte": z.number().int().gte(0).describe("Storage trie read value cost per byte cost"), "storage_remove_base": z.number().int().gte(0).describe("Remove key from trie base cost"), "storage_remove_key_byte": z.number().int().gte(0).describe("Remove key from trie per byte cost"), "storage_remove_ret_value_byte": z.number().int().gte(0).describe("Remove key from trie ret value byte cost"), "storage_write_base": z.number().int().gte(0).describe("Storage trie write key base cost"), "storage_write_evicted_byte": z.number().int().gte(0).describe("Storage trie write cost per byte of evicted value."), "storage_write_key_byte": z.number().int().gte(0).describe("Storage trie write key per byte cost"), "storage_write_value_byte": z.number().int().gte(0).describe("Storage trie write value per byte cost"), "touching_trie_node": z.number().int().gte(0).describe("Cost per reading trie node from DB"), "utf16_decoding_base": z.number().int().gte(0).describe("Base cost of decoding utf16. It's used for `log_utf16`."), "utf16_decoding_byte": z.number().int().gte(0).describe("Cost per byte of decoding utf16. It's used for `log_utf16`."), "utf8_decoding_base": z.number().int().gte(0).describe("Base cost of decoding utf8. It's used for `log_utf8` and `panic_utf8`."), "utf8_decoding_byte": z.number().int().gte(0).describe("Cost per byte of decoding utf8. It's used for `log_utf8` and `panic_utf8`."), "validator_stake_base": z.number().int().gte(0).describe("Cost of calling `validator_stake`."), "validator_total_stake_base": z.number().int().gte(0).describe("Cost of calling `validator_total_stake`."), "write_memory_base": z.number().int().gte(0).describe("Base cost for guest memory write"), "write_memory_byte": z.number().int().gte(0).describe("Cost for guest memory write per byte"), "write_register_base": z.number().int().gte(0).describe("Base cost for writing into register"), "write_register_byte": z.number().int().gte(0).describe("Cost for writing byte into register"), "yield_create_base": z.number().int().gte(0).describe("Base cost for creating a yield promise."), "yield_create_byte": z.number().int().gte(0).describe("Per byte cost of arguments and method name."), "yield_resume_base": z.number().int().gte(0).describe("Base cost for resuming a yield receipt."), "yield_resume_byte": z.number().int().gte(0).describe("Per byte cost of resume payload.") }).describe("Typed view of ExtCostsConfig to preserve JSON output field names in protocol\nconfig RPC output.").describe("Costs for runtime externals"), "fix_contract_loading_cost": z.boolean().describe("See [VMConfig::fix_contract_loading_cost](crate::vm::Config::fix_contract_loading_cost)."), "global_contract_host_fns": z.boolean().describe("See [VMConfig::global_contract_host_fns](crate::vm::Config::global_contract_host_fns)."), "grow_mem_cost": z.number().int().gte(0).describe("Gas cost of a growing memory by single page."), "implicit_account_creation": z.boolean().describe("See [VMConfig::implicit_account_creation](crate::vm::Config::implicit_account_creation)."), "limit_config": z.object({ "account_id_validity_rules_version": z.number().int().gte(0).lte(255).describe("Whether to enforce account_id well-formed-ness where it wasn't enforced\nhistorically.").default(0), "initial_memory_pages": z.number().int().gte(0).describe("The initial number of memory pages.\nNOTE: It's not a limiter itself, but it's a value we use for initial_memory_pages."), "max_actions_per_receipt": z.number().int().gte(0).describe("Max number of actions per receipt."), "max_arguments_length": z.number().int().gte(0).describe("Max length of arguments in a function call action."), "max_contract_size": z.number().int().gte(0).describe("Max contract size"), "max_elements_per_contract_table": z.union([z.number().int().gte(0).describe("If present, stores max number of elements in a single contract's table"), z.null().describe("If present, stores max number of elements in a single contract's table")]).describe("If present, stores max number of elements in a single contract's table").optional(), "max_functions_number_per_contract": z.union([z.number().int().gte(0).describe("If present, stores max number of functions in one contract"), z.null().describe("If present, stores max number of functions in one contract")]).describe("If present, stores max number of functions in one contract").optional(), "max_gas_burnt": z.number().int().gte(0).describe("Max amount of gas that can be used, excluding gas attached to promises."), "max_length_method_name": z.number().int().gte(0).describe("Max length of any method name (without terminating character)."), "max_length_returned_data": z.number().int().gte(0).describe("Max length of returned data"), "max_length_storage_key": z.number().int().gte(0).describe("Max storage key size"), "max_length_storage_value": z.number().int().gte(0).describe("Max storage value size"), "max_locals_per_contract": z.union([z.number().int().gte(0).describe("If present, stores max number of locals declared globally in one contract"), z.null().describe("If present, stores max number of locals declared globally in one contract")]).describe("If present, stores max number of locals declared globally in one contract").optional(), "max_memory_pages": z.number().int().gte(0).describe("What is the maximal memory pages amount is allowed to have for a contract."), "max_number_bytes_method_names": z.number().int().gte(0).describe("Max total length of all method names (including terminating character) for a function call\npermission access key."), "max_number_input_data_dependencies": z.number().int().gte(0).describe("Max number of input data dependencies"), "max_number_logs": z.number().int().gte(0).describe("Maximum number of log entries."), "max_number_registers": z.number().int().gte(0).describe("Maximum number of registers that can be used simultaneously.\n\nNote that due to an implementation quirk [read: a bug] in VMLogic, if we\nhave this number of registers, no subsequent writes to the registers\nwill succeed even if they replace an existing register."), "max_promises_per_function_call_action": z.number().int().gte(0).describe("Max number of promises that a function call can create"), "max_receipt_size": z.number().int().gte(0).describe("Max receipt size"), "max_register_size": z.number().int().gte(0).describe("Maximum number of bytes that can be stored in a single register."), "max_stack_height": z.number().int().gte(0).describe("How tall the stack is allowed to grow?\n\nSee <https://wiki.parity.io/WebAssembly-StackHeight> to find out how the stack frame cost\nis calculated."), "max_tables_per_contract": z.union([z.number().int().gte(0).describe("If present, stores max number of tables declared globally in one contract"), z.null().describe("If present, stores max number of tables declared globally in one contract")]).describe("If present, stores max number of tables declared globally in one contract").optional(), "max_total_log_length": z.number().int().gte(0).describe("Maximum total length in bytes of all log messages."), "max_total_prepaid_gas": z.number().int().gte(0).describe("Max total prepaid gas for all function call actions per receipt."), "max_transaction_size": z.number().int().gte(0).describe("Max transaction size"), "max_yield_payload_size": z.number().int().gte(0).describe("Maximum number of bytes for payload passed over a yield resume."), "per_receipt_storage_proof_size_limit": z.number().int().gte(0).describe("Hard limit on the size of storage proof generated while executing a single receipt."), "registers_memory_limit": z.number().int().gte(0).describe("Limit of memory used by registers."), "yield_timeout_length_in_blocks": z.number().int().gte(0).describe("Number of blocks after which a yielded promise times out.") }).describe("Describes limits for VM and Runtime.\nTODO #4139: consider switching to strongly-typed wrappers instead of raw quantities").describe("Describes limits for VM and Runtime.\n\nTODO: Consider changing this to `VMLimitConfigView` to avoid dependency\non runtime."), "linear_op_base_cost": z.number().int().gte(0).describe("Base gas cost of a linear operation"), "linear_op_unit_cost": z.number().int().gte(0).describe("Unit gas cost of a linear operation"), "reftypes_bulk_memory": z.boolean().describe("See [VMConfig::reftypes_bulk_memory](crate::vm::Config::reftypes_bulk_memory)."), "regular_op_cost": z.number().int().gte(0).describe("Gas cost of a regular operation."), "saturating_float_to_int": z.boolean().describe("See [VMConfig::saturating_float_to_int](crate::vm::Config::saturating_float_to_int)."), "storage_get_mode": z.enum(["FlatStorage","Trie"]).describe("This enum represents if a storage_get call will be performed through flat storage or trie").describe("See [VMConfig::storage_get_mode](crate::vm::Config::storage_get_mode)."), "vm_kind": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Wasmer0").describe("Wasmer 0.17.x VM. Gone now."), z.literal("Wasmtime").describe("Wasmtime VM."), z.literal("Wasmer2").describe("Wasmer 2.x VM."), z.literal("NearVm").describe("NearVM.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("See [VMConfig::vm_kind](crate::vm::Config::vm_kind).") })
export type VMConfigView = z.infer<typeof VMConfigView>


export const VMKind = z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Wasmer0").describe("Wasmer 0.17.x VM. Gone now."), z.literal("Wasmtime").describe("Wasmtime VM."), z.literal("Wasmer2").describe("Wasmer 2.x VM."), z.literal("NearVm").describe("NearVM.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })
export type VMKind = z.infer<typeof VMKind>


export const ValidatorInfo = z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```") })
export type ValidatorInfo = z.infer<typeof ValidatorInfo>


export const ValidatorKickoutReason = z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("_UnusedSlashed").describe("Deprecated"), z.object({ "NotEnoughBlocks": z.object({ "expected": z.number().int().gte(0), "produced": z.number().int().gte(0) }) }).strict().describe("Validator didn't produce enough blocks."), z.object({ "NotEnoughChunks": z.object({ "expected": z.number().int().gte(0), "produced": z.number().int().gte(0) }) }).strict().describe("Validator didn't produce enough chunks."), z.literal("Unstaked").describe("Validator unstaked themselves."), z.object({ "NotEnoughStake": z.object({ "stake_u128": z.string(), "threshold_u128": z.string() }) }).strict().describe("Validator stake is now below threshold"), z.literal("DidNotGetASeat").describe("Enough stake but is not chosen because of seat limits."), z.object({ "NotEnoughChunkEndorsements": z.object({ "expected": z.number().int().gte(0), "produced": z.number().int().gte(0) }) }).strict().describe("Validator didn't produce enough chunk endorsements."), z.object({ "ProtocolVersionTooOld": z.object({ "network_version": z.number().int().gte(0), "version": z.number().int().gte(0) }) }).strict().describe("Validator's last block proposal was for a protocol version older than\nthe network's voted protocol version.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Reasons for removing a validator from the validator set.")
export type ValidatorKickoutReason = z.infer<typeof ValidatorKickoutReason>


export const ValidatorKickoutView = z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "reason": z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("_UnusedSlashed").describe("Deprecated"), z.object({ "NotEnoughBlocks": z.object({ "expected": z.number().int().gte(0), "produced": z.number().int().gte(0) }) }).strict().describe("Validator didn't produce enough blocks."), z.object({ "NotEnoughChunks": z.object({ "expected": z.number().int().gte(0), "produced": z.number().int().gte(0) }) }).strict().describe("Validator didn't produce enough chunks."), z.literal("Unstaked").describe("Validator unstaked themselves."), z.object({ "NotEnoughStake": z.object({ "stake_u128": z.string(), "threshold_u128": z.string() }) }).strict().describe("Validator stake is now below threshold"), z.literal("DidNotGetASeat").describe("Enough stake but is not chosen because of seat limits."), z.object({ "NotEnoughChunkEndorsements": z.object({ "expected": z.number().int().gte(0), "produced": z.number().int().gte(0) }) }).strict().describe("Validator didn't produce enough chunk endorsements."), z.object({ "ProtocolVersionTooOld": z.object({ "network_version": z.number().int().gte(0), "version": z.number().int().gte(0) }) }).strict().describe("Validator's last block proposal was for a protocol version older than\nthe network's voted protocol version.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Reasons for removing a validator from the validator set.") })
export type ValidatorKickoutView = z.infer<typeof ValidatorKickoutView>


export const ValidatorStakeView = z.object({ "validator_stake_struct_version": z.literal("V1") }).and(z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string(), "stake": z.string() }))
export type ValidatorStakeView = z.infer<typeof ValidatorStakeView>


export const ValidatorStakeViewV1 = z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string(), "stake": z.string() })
export type ValidatorStakeViewV1 = z.infer<typeof ValidatorStakeViewV1>


export const ValidatorStakeViews = z.array(z.object({ "validator_stake_struct_version": z.literal("V1") }).and(z.object({ "account_id": z.string().describe("NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n```\nuse near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f)\n```"), "public_key": z.string(), "stake": z.string() })))
export type ValidatorStakeViews = z.infer<typeof ValidatorStakeViews>


export const Version = z.object({ "build": z.string(), "commit": z.string(), "rustc_version": z.string().default(""), "version": z.string() }).describe("Data structure for semver version and github tag or commit.")
export type Version = z.infer<typeof Version>


export const ViewStateResult = z.object({ "proof": z.array(z.string()).optional(), "values": z.array(z.object({ "key": z.string().describe("This type is used to mark keys (arrays of bytes) that are queried from store.\n\nNOTE: Currently, this type is only used in the view_client and RPC to be able to transparently\npretty-serialize the bytes arrays as base64-encoded strings (see `serialize.rs`)."), "value": z.string().describe("This type is used to mark values returned from store (arrays of bytes).\n\nNOTE: Currently, this type is only used in the view_client and RPC to be able to transparently\npretty-serialize the bytes arrays as base64-encoded strings (see `serialize.rs`).") }).describe("Item of the state, key and value are serialized in base64 and proof for inclusion of given state item.")) }).describe("Resulting state values for a view state query request")
export type ViewStateResult = z.infer<typeof ViewStateResult>


export const WasmTrap = z.any().superRefine((x, ctx) => {
    const schemas = [z.literal("Unreachable").describe("An `unreachable` opcode was executed."), z.literal("IncorrectCallIndirectSignature").describe("Call indirect incorrect signature trap."), z.literal("MemoryOutOfBounds").describe("Memory out of bounds trap."), z.literal("CallIndirectOOB").describe("Call indirect out of bounds trap."), z.literal("IllegalArithmetic").describe("An arithmetic exception, e.g. divided by zero."), z.literal("MisalignedAtomicAccess").describe("Misaligned atomic access trap."), z.literal("IndirectCallToNull").describe("Indirect call to null."), z.literal("StackOverflow").describe("Stack overflow."), z.literal("GenericTrap").describe("Generic trap.")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("A kind of a trap happened during execution of a binary")
export type WasmTrap = z.infer<typeof WasmTrap>


export const WitnessConfigView = z.object({ "combined_transactions_size_limit": z.number().int().gte(0).describe("Maximum size of transactions contained inside ChunkStateWitness.\n\nA witness contains transactions from both the previous chunk and the current one.\nThis parameter limits the sum of sizes of transactions from both of those chunks."), "main_storage_proof_size_soft_limit": z.number().int().gte(0).describe("Size limit for storage proof generated while executing receipts in a chunk.\nAfter this limit is reached we defer execution of any new receipts."), "new_transactions_validation_state_size_soft_limit": z.number().int().gte(0).describe("Soft size limit of storage proof used to validate new transactions in ChunkStateWitness.") }).describe("Configuration specific to ChunkStateWitness.")
export type WitnessConfigView = z.infer<typeof WitnessConfigView>


