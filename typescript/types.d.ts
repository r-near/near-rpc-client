/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * Defines permissions for AccessKey
 */
export type AccessKeyPermission = FunctionCall | "FullAccess";
export type NearToken = string;
export type NearGas = number;
/**
 * Describes the permission scope for an access key. Whether it is a function call or a full access key.
 */
export type AccessKeyPermissionView = "FullAccess" | FunctionCall1;
export type PublicKey = string;
/**
 * NEAR Account Identifier.
 *
 * This is a unique, syntactically valid, human-readable account identifier on the NEAR network.
 *
 * [See the crate-level docs for information about validation.](index.html#account-id-rules)
 *
 * Also see [Error kind precedence](AccountId#error-kind-precedence).
 *
 * ## Examples
 *
 * ```
 * use near_account_id::AccountId;
 *
 * let alice: AccountId = "alice.near".parse().unwrap();
 *
 * assert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f)
 * ```
 */
export type AccountId = string;
export type AccountIdValidityRulesVersion = number;
export type CryptoHash = string;
export type ActionErrorKind =
  | AccountAlreadyExists
  | AccountDoesNotExist
  | CreateAccountOnlyByRegistrar
  | CreateAccountNotAllowed
  | ActorNoPermission
  | DeleteKeyDoesNotExist
  | AddKeyAlreadyExists
  | DeleteAccountStaking
  | LackBalanceForState
  | TriesToUnstake
  | TriesToStake
  | InsufficientStake
  | FunctionCallError
  | NewReceiptValidationError
  | OnlyImplicitAccountCreationAllowed
  | DeleteAccountWithLargeState
  | "DelegateActionInvalidSignature"
  | DelegateActionSenderDoesNotMatchTxReceiver
  | "DelegateActionExpired"
  | DelegateActionAccessKeyError
  | DelegateActionInvalidNonce
  | DelegateActionNonceTooLarge
  | GlobalContractDoesNotExist;
/**
 * Serializable version of `near-vm-runner::FunctionCallError`.
 *
 * Must never reorder/remove elements, can only add new variants at the end (but do that very
 * carefully). It describes stable serialization format, and only used by serialization logic.
 */
export type FunctionCallError1 =
  | ("WasmUnknownError" | "_EVMError")
  | CompilationError
  | LinkError
  | MethodResolveError
  | WasmTrap
  | HostError
  | ExecutionError;
export type CompilationError1 = CodeDoesNotExist | PrepareError | WasmerCompileError;
/**
 * Error that can occur while preparing or executing Wasm smart-contract.
 */
export type PrepareError1 =
  | "Serialization"
  | "Deserialization"
  | "InternalMemoryDeclared"
  | "GasInstrumentation"
  | "StackHeightInstrumentation"
  | "Instantiate"
  | "Memory"
  | "TooManyFunctions"
  | "TooManyLocals"
  | "TooManyTables"
  | "TooManyTableElements";
export type MethodResolveError1 = "MethodEmptyName" | "MethodNotFound" | "MethodInvalidSignature";
/**
 * A kind of a trap happened during execution of a binary
 */
export type WasmTrap1 =
  | "Unreachable"
  | "IncorrectCallIndirectSignature"
  | "MemoryOutOfBounds"
  | "CallIndirectOOB"
  | "IllegalArithmetic"
  | "MisalignedAtomicAccess"
  | "IndirectCallToNull"
  | "StackOverflow"
  | "GenericTrap";
export type HostError1 =
  | "BadUTF16"
  | "BadUTF8"
  | "GasExceeded"
  | "GasLimitExceeded"
  | "BalanceExceeded"
  | "EmptyMethodName"
  | GuestPanic
  | "IntegerOverflow"
  | InvalidPromiseIndex
  | "CannotAppendActionToJointPromise"
  | "CannotReturnJointPromise"
  | InvalidPromiseResultIndex
  | InvalidRegisterId
  | IteratorWasInvalidated
  | "MemoryAccessViolation"
  | InvalidReceiptIndex
  | InvalidIteratorIndex
  | "InvalidAccountId"
  | "InvalidMethodName"
  | "InvalidPublicKey"
  | ProhibitedInView
  | NumberOfLogsExceeded
  | KeyLengthExceeded
  | ValueLengthExceeded
  | TotalLogLengthExceeded
  | NumberPromisesExceeded
  | NumberInputDataDependenciesExceeded
  | ReturnedValueLengthExceeded
  | ContractSizeExceeded
  | Deprecated
  | ECRecoverError
  | AltBn128InvalidInput
  | Ed25519VerifyInvalidInput;
/**
 * Describes the error for validating a receipt.
 */
export type ReceiptValidationError =
  | InvalidPredecessorId
  | InvalidReceiverId
  | InvalidSignerId
  | InvalidDataReceiverId
  | ReturnedValueLengthExceeded1
  | NumberInputDataDependenciesExceeded1
  | ActionsValidation
  | ReceiptSizeExceeded
  | InvalidRefundTo;
/**
 * Describes the error for validating a list of actions.
 */
export type ActionsValidationError =
  | "DeleteActionMustBeFinal"
  | TotalPrepaidGasExceeded
  | TotalNumberOfActionsExceeded
  | AddKeyMethodNamesNumberOfBytesExceeded
  | AddKeyMethodNameLengthExceeded
  | "IntegerOverflow"
  | InvalidAccountId
  | ContractSizeExceeded1
  | FunctionCallMethodNameLengthExceeded
  | FunctionCallArgumentsLengthExceeded
  | UnsuitableStakingKey
  | "FunctionCallZeroAttachedGas"
  | "DelegateActionMustBeOnlyOne"
  | UnsupportedProtocolFeature
  | InvalidDeterministicStateInitReceiver
  | DeterministicStateInitKeyLengthExceeded
  | DeterministicStateInitValueLengthExceeded;
export type InvalidAccessKeyError =
  | AccessKeyNotFound
  | ReceiverMismatch
  | MethodNameMismatch
  | "RequiresFullAccess"
  | NotEnoughAllowance
  | "DepositWithFunctionCall";
export type GlobalContractIdentifier = CodeHash | AccountId1;
export type ActionView =
  | "CreateAccount"
  | DeployContract
  | FunctionCall2
  | Transfer
  | Stake
  | AddKey
  | DeleteKey
  | DeleteAccount
  | Delegate
  | DeployGlobalContract1
  | DeployGlobalContractByAccountId
  | UseGlobalContract1
  | UseGlobalContractByAccountId
  | DeterministicStateInit1;
/**
 * This type is used to mark function arguments.
 *
 * NOTE: The main reason for this to exist (except the type-safety) is that the value is
 * transparently serialized and deserialized as a base64-encoded string when serde is used
 * (serde_json).
 */
export type FunctionArgs = string;
/**
 * An Action that can be included in a transaction or receipt, excluding delegate actions. This type represents all possible action types except DelegateAction to prevent infinite recursion in meta-transactions.
 */
export type NonDelegateAction =
  | CreateAccount
  | DeployContract1
  | FunctionCall3
  | Transfer1
  | Stake1
  | AddKey1
  | DeleteKey1
  | DeleteAccount1
  | DeployGlobalContract
  | UseGlobalContract
  | DeterministicStateInit;
export type GlobalContractDeployMode = "CodeHash" | "AccountId";
export type DeterministicAccountStateInit = V1;
export type Signature = string;
export type GlobalContractIdentifierView = Hash | AccountId2;
/**
 * A list of shard's bandwidth requests.
 * Describes how much the shard would like to send to other shards.
 */
export type BandwidthRequests = V11;
export type ValidatorStakeView = V12;
export type V12 = ValidatorStakeViewV1;
export type BlockHeightRanges = BlockHeightRange[];
export type BlockId = BlockHeight | CryptoHash;
export type BlockHeight = number;
/**
 * The shard identifier. It may be an arbitrary number - it does not need to be
 * a number in the range 0..NUM_SHARDS. The shard ids do not need to be
 * sequential or contiguous.
 *
 * The shard id is wrapped in a new type to prevent the old pattern of using
 * indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition
 * if fully complete it potentially may be simplified to a regular type alias.
 */
export type ShardId = number;
export type Direction = "Left" | "Right";
/**
 * Supported external storage backends and their minimal config.
 */
export type ExternalStorageLocation = S3 | Filesystem | GCS;
/**
 * Epoch identifier -- wrapped hash, to make it easier to distinguish.
 * EpochId of epoch T is the hash of last block in T-2
 * EpochId of first two epochs is 0
 */
export type EpochId = CryptoHash;
export type ExecutionStatusView = "Unknown" | Failure | SuccessValue | SuccessReceiptId;
/**
 * Error returned in the ExecutionOutcome in case of failure
 */
export type TxExecutionError = ActionError1 | InvalidTxError;
/**
 * An error happened during TX execution
 */
export type InvalidTxError1 =
  | InvalidAccessKeyError1
  | InvalidSignerId1
  | SignerDoesNotExist
  | InvalidNonce
  | NonceTooLarge
  | InvalidReceiverId1
  | "InvalidSignature"
  | NotEnoughBalance
  | LackBalanceForState1
  | "CostOverflow"
  | "InvalidChain"
  | "Expired"
  | ActionsValidation1
  | TransactionSizeExceeded
  | "InvalidTransactionVersion"
  | StorageError
  | ShardCongested
  | ShardStuck;
/**
 * Errors which may occur during working with trie storages, storing
 * trie values (trie nodes and state values) by their hashes.
 */
export type StorageError1 =
  | "StorageInternalError"
  | MissingTrieValue
  | "UnexpectedTrieValue"
  | StorageInconsistentState
  | FlatStorageBlockNotSupported
  | MemTrieLoadingError;
/**
 * Contexts in which `StorageError::MissingTrieValue` error might occur.
 */
export type MissingTrieValueContext =
  | "TrieIterator"
  | "TriePrefetchingStorage"
  | "TrieMemoryPartialStorage"
  | "TrieStorage";
export type FinalExecutionStatus = "NotStarted" | "Started" | Failure1 | SuccessValue1;
export type ReceiptEnumView = Action | Data | GlobalContractDistribution;
/**
 * Different types of finality.
 */
export type Finality = "optimistic" | "near-final" | "final";
/**
 * A versioned struct that contains all information needed to assign accounts to shards.
 *
 * Because of re-sharding, the chain may use different shard layout to split shards at different
 * times. Currently, `ShardLayout` is stored as part of `EpochConfig`, which is generated each
 * epoch given the epoch protocol version. In mainnet/testnet, we use two shard layouts since
 * re-sharding has only happened once. It is stored as part of genesis config, see
 * default_simple_nightshade_shard_layout() Below is an overview for some important
 * functionalities of ShardLayout interface.
 */
export type ShardLayout = V0 | V13 | V2;
export type LogSummaryStyle = "plain" | "colored";
export type MutableConfigValue = string;
/**
 * Peer id is the public key.
 */
export type PeerId = PublicKey;
/**
 * Configures whether the node checks the next or the next next epoch for network version compatibility.
 */
export type ProtocolVersionCheckConfig = "Next" | "NextNext";
export type RpcBlockRequest = BlockId1 | Finality1 | SyncCheckpoint;
export type SyncCheckpoint1 = "genesis" | "earliest_available";
export type RpcChunkRequest = BlockShardId | ChunkHash;
/**
 * Configures how to fetch state parts during state sync.
 */
export type SyncConfig = "Peers" | ExternalStorage;
/**
 * Describes the expected behavior of the node regarding shard tracking.
 * If the node is an active validator, it will also track the shards it is responsible for as a validator.
 */
export type TrackedShardsConfig = "NoShards" | Shards | "AllShards" | ShadowValidator | Schedule | Accounts;
export type RpcCongestionLevelRequest = BlockShardId1 | ChunkHash1;
export type RpcHealthResponse = null;
export type RpcLightClientExecutionProofRequest = Transaction | Receipt;
export type RpcProtocolConfigRequest = BlockId2 | Finality2 | SyncCheckpoint2;
/**
 * This enum represents if a storage_get call will be performed through flat storage or trie
 */
export type StorageGetMode = "FlatStorage" | "Trie";
export type VMKind = "Wasmer0" | "Wasmtime" | "Wasmer2" | "NearVm";
export type RpcQueryRequest =
  | BlockIdViewAccount
  | BlockIdViewCode
  | BlockIdViewState
  | BlockIdViewAccessKey
  | BlockIdViewAccessKeyList
  | BlockIdCallFunction
  | BlockIdViewGlobalContractCode
  | BlockIdViewGlobalContractCodeByAccountId
  | FinalityViewAccount
  | FinalityViewCode
  | FinalityViewState
  | FinalityViewAccessKey
  | FinalityViewAccessKeyList
  | FinalityCallFunction
  | FinalityViewGlobalContractCode
  | FinalityViewGlobalContractCodeByAccountId
  | SyncCheckpointViewAccount
  | SyncCheckpointViewCode
  | SyncCheckpointViewState
  | SyncCheckpointViewAccessKey
  | SyncCheckpointViewAccessKeyList
  | SyncCheckpointCallFunction
  | SyncCheckpointViewGlobalContractCode
  | SyncCheckpointViewGlobalContractCodeByAccountId;
/**
 * This type is used to mark keys (arrays of bytes) that are queried from store.
 *
 * NOTE: Currently, this type is only used in the view_client and RPC to be able to transparently
 * pretty-serialize the bytes arrays as base64-encoded strings (see `serialize.rs`).
 */
export type StoreKey = string;
export type RpcQueryResponse =
  | AccountView1
  | ContractCodeView1
  | ViewStateResult
  | CallResult1
  | AccessKeyView1
  | AccessKeyList1;
export type AccountView1 = {
  block_hash: CryptoHash;
  block_height: number;
  [k: string]: unknown;
} & AccountView;
export type ContractCodeView1 = {
  block_hash: CryptoHash;
  block_height: number;
  [k: string]: unknown;
} & ContractCodeView;
export type ViewStateResult = {
  block_hash: CryptoHash;
  block_height: number;
  [k: string]: unknown;
} & ViewStateResult1;
/**
 * This type is used to mark values returned from store (arrays of bytes).
 *
 * NOTE: Currently, this type is only used in the view_client and RPC to be able to transparently
 * pretty-serialize the bytes arrays as base64-encoded strings (see `serialize.rs`).
 */
export type StoreValue = string;
export type CallResult1 = {
  block_hash: CryptoHash;
  block_height: number;
  [k: string]: unknown;
} & CallResult;
export type AccessKeyView1 = {
  block_hash: CryptoHash;
  block_height: number;
  [k: string]: unknown;
} & AccessKeyView;
export type AccessKeyList1 = {
  block_hash: CryptoHash;
  block_height: number;
  [k: string]: unknown;
} & AccessKeyList;
export type SignedTransaction = string;
export type TxExecutionStatus = "NONE" | "INCLUDED" | "EXECUTED_OPTIMISTIC" | "INCLUDED_FINAL" | "EXECUTED" | "FINAL";
/**
 * It is a [serializable view] of [`StateChangesRequest`].
 *
 * [serializable view]: ./index.html
 * [`StateChangesRequest`]: ../types/struct.StateChangesRequest.html
 */
export type RpcStateChangesInBlockByTypeRequest =
  | BlockIdAccountChanges
  | BlockIdSingleAccessKeyChanges
  | BlockIdSingleGasKeyChanges
  | BlockIdAllAccessKeyChanges
  | BlockIdAllGasKeyChanges
  | BlockIdContractCodeChanges
  | BlockIdDataChanges
  | FinalityAccountChanges
  | FinalitySingleAccessKeyChanges
  | FinalitySingleGasKeyChanges
  | FinalityAllAccessKeyChanges
  | FinalityAllGasKeyChanges
  | FinalityContractCodeChanges
  | FinalityDataChanges
  | SyncCheckpointAccountChanges
  | SyncCheckpointSingleAccessKeyChanges
  | SyncCheckpointSingleGasKeyChanges
  | SyncCheckpointAllAccessKeyChanges
  | SyncCheckpointAllGasKeyChanges
  | SyncCheckpointContractCodeChanges
  | SyncCheckpointDataChanges;
/**
 * It is a [serializable view] of [`StateChangeKind`].
 *
 * [serializable view]: ./index.html
 * [`StateChangeKind`]: ../types/struct.StateChangeKind.html
 */
export type StateChangeKindView = AccountTouched | AccessKeyTouched | DataTouched | ContractCodeTouched;
export type RpcStateChangesInBlockRequest = BlockId3 | Finality3 | SyncCheckpoint3;
export type StateChangeWithCauseView =
  | AccountUpdate
  | AccountDeletion
  | AccessKeyUpdate
  | AccessKeyDeletion
  | GasKeyUpdate
  | GasKeyNonceUpdate
  | GasKeyDeletion
  | DataUpdate
  | DataDeletion
  | ContractCodeUpdate
  | ContractCodeDeletion;
/**
 * See crate::types::StateChangeCause for details.
 */
export type StateChangeCauseView =
  | NotWritableToDisk
  | InitialState
  | TransactionProcessing
  | ActionReceiptProcessingStarted
  | ActionReceiptGasReward
  | ReceiptProcessing
  | PostponedReceipt
  | UpdatedDelayedReceipts
  | ValidatorAccountsUpdate
  | Migration
  | BandwidthSchedulerStateUpdate;
export type RpcTransactionResponse = FinalExecutionOutcomeWithReceiptView1 | FinalExecutionOutcomeView1 | Empty;
export type FinalExecutionOutcomeWithReceiptView1 = {
  final_execution_status: TxExecutionStatus;
  [k: string]: unknown;
} & FinalExecutionOutcomeWithReceiptView;
export type FinalExecutionOutcomeView1 = {
  final_execution_status: TxExecutionStatus;
  [k: string]: unknown;
} & FinalExecutionOutcomeView;
export type RpcTransactionStatusRequest = SignedTxBase64 | TxHashSenderAccountId;
export type SignedTxBase64 = {
  wait_until?: TxExecutionStatus & string;
  [k: string]: unknown;
} & {
  signed_tx_base64: SignedTransaction;
  [k: string]: unknown;
};
export type TxHashSenderAccountId = {
  wait_until?: TxExecutionStatus & string;
  [k: string]: unknown;
} & {
  sender_account_id: AccountId;
  tx_hash: CryptoHash;
  [k: string]: unknown;
};
export type RpcValidatorRequest = EpochId1 | BlockId4 | Latest;
/**
 * Reasons for removing a validator from the validator set.
 */
export type ValidatorKickoutReason =
  | "_UnusedSlashed"
  | NotEnoughBlocks
  | NotEnoughChunks
  | "Unstaked"
  | NotEnoughStake
  | "DidNotGetASeat"
  | NotEnoughChunkEndorsements
  | ProtocolVersionTooOld;
export type ValidatorStakeViews = ValidatorStakeView[];

export interface TsSchema {
  AccessKey?: AccessKey;
  AccessKeyCreationConfigView?: AccessKeyCreationConfigView;
  AccessKeyInfoView?: AccessKeyInfoView;
  AccessKeyList?: AccessKeyList;
  AccessKeyPermission?: AccessKeyPermission;
  AccessKeyPermissionView?: AccessKeyPermissionView;
  AccessKeyView?: AccessKeyView;
  AccountCreationConfigView?: AccountCreationConfigView;
  AccountDataView?: AccountDataView;
  AccountId?: AccountId;
  AccountIdValidityRulesVersion?: AccountIdValidityRulesVersion;
  AccountInfo?: AccountInfo;
  AccountView?: AccountView;
  AccountWithPublicKey?: AccountWithPublicKey;
  ActionCreationConfigView?: ActionCreationConfigView;
  ActionError?: ActionError;
  ActionErrorKind?: ActionErrorKind;
  ActionView?: ActionView;
  ActionsValidationError?: ActionsValidationError;
  AddKeyAction?: AddKeyAction;
  BandwidthRequest?: BandwidthRequest;
  BandwidthRequestBitmap?: BandwidthRequestBitmap;
  BandwidthRequests?: BandwidthRequests;
  BandwidthRequestsV1?: BandwidthRequestsV1;
  BlockHeaderInnerLiteView?: BlockHeaderInnerLiteView;
  BlockHeaderView?: BlockHeaderView;
  BlockHeightRange?: BlockHeightRange;
  BlockHeightRanges?: BlockHeightRanges;
  BlockId?: BlockId;
  BlockStatusView?: BlockStatusView;
  CallResult?: CallResult;
  CatchupStatusView?: CatchupStatusView;
  ChunkDistributionNetworkConfig?: ChunkDistributionNetworkConfig;
  ChunkDistributionUris?: ChunkDistributionUris;
  ChunkHeaderView?: ChunkHeaderView;
  CloudArchivalWriterConfig?: CloudArchivalWriterConfig;
  CompilationError?: CompilationError1;
  CongestionControlConfigView?: CongestionControlConfigView;
  CongestionInfoView?: CongestionInfoView;
  ContractCodeView?: ContractCodeView;
  CostGasUsed?: CostGasUsed;
  CreateAccountAction?: CreateAccountAction;
  CryptoHash?: CryptoHash;
  CurrentEpochValidatorInfo?: CurrentEpochValidatorInfo;
  DataReceiptCreationConfigView?: DataReceiptCreationConfigView;
  DataReceiverView?: DataReceiverView;
  DelegateAction?: DelegateAction;
  DeleteAccountAction?: DeleteAccountAction;
  DeleteKeyAction?: DeleteKeyAction;
  DeployContractAction?: DeployContractAction;
  DeployGlobalContractAction?: DeployGlobalContractAction;
  DetailedDebugStatus?: DetailedDebugStatus;
  DeterministicAccountStateInit?: DeterministicAccountStateInit;
  DeterministicAccountStateInitV1?: DeterministicAccountStateInitV1;
  DeterministicStateInitAction?: DeterministicStateInitAction;
  Direction?: Direction;
  DumpConfig?: DumpConfig;
  DurationAsStdSchemaProvider?: DurationAsStdSchemaProvider;
  EpochId?: EpochId;
  EpochSyncConfig?: EpochSyncConfig;
  ExecutionMetadataView?: ExecutionMetadataView;
  ExecutionOutcomeView?: ExecutionOutcomeView;
  ExecutionOutcomeWithIdView?: ExecutionOutcomeWithIdView;
  ExecutionStatusView?: ExecutionStatusView;
  ExtCostsConfigView?: ExtCostsConfigView;
  ExternalStorageConfig?: ExternalStorageConfig;
  ExternalStorageLocation?: ExternalStorageLocation;
  Fee?: Fee;
  FinalExecutionOutcomeView?: FinalExecutionOutcomeView;
  FinalExecutionOutcomeWithReceiptView?: FinalExecutionOutcomeWithReceiptView;
  FinalExecutionStatus?: FinalExecutionStatus;
  Finality?: Finality;
  FunctionArgs?: FunctionArgs;
  FunctionCallAction?: FunctionCallAction;
  FunctionCallError?: FunctionCallError1;
  FunctionCallPermission?: FunctionCallPermission;
  GCConfig?: GCConfig;
  GasKeyView?: GasKeyView;
  GenesisConfig?: GenesisConfig;
  GenesisConfigRequest?: GenesisConfigRequest;
  GlobalContractDeployMode?: GlobalContractDeployMode;
  GlobalContractIdentifier?: GlobalContractIdentifier;
  GlobalContractIdentifierView?: GlobalContractIdentifierView;
  HostError?: HostError1;
  InvalidAccessKeyError?: InvalidAccessKeyError;
  InvalidTxError?: InvalidTxError1;
  KnownProducerView?: KnownProducerView;
  LightClientBlockLiteView?: LightClientBlockLiteView;
  LimitConfig?: LimitConfig;
  LogSummaryStyle?: LogSummaryStyle;
  MerklePathItem?: MerklePathItem;
  MethodResolveError?: MethodResolveError1;
  MissingTrieValue?: MissingTrieValue1;
  MissingTrieValueContext?: MissingTrieValueContext;
  MutableConfigValue?: MutableConfigValue;
  NearGas?: NearGas;
  NearToken?: NearToken;
  NetworkInfoView?: NetworkInfoView;
  NextEpochValidatorInfo?: NextEpochValidatorInfo;
  NonDelegateAction?: NonDelegateAction;
  PeerId?: PeerId;
  PeerInfoView?: PeerInfoView;
  PrepareError?: PrepareError1;
  ProtocolVersionCheckConfig?: ProtocolVersionCheckConfig;
  PublicKey?: PublicKey;
  ReceiptEnumView?: ReceiptEnumView;
  ReceiptValidationError?: ReceiptValidationError;
  ReceiptView?: ReceiptView;
  RpcBlockRequest?: RpcBlockRequest;
  RpcBlockResponse?: RpcBlockResponse;
  RpcChunkRequest?: RpcChunkRequest;
  RpcChunkResponse?: RpcChunkResponse;
  RpcClientConfigRequest?: RpcClientConfigRequest;
  RpcClientConfigResponse?: RpcClientConfigResponse;
  RpcCongestionLevelRequest?: RpcCongestionLevelRequest;
  RpcCongestionLevelResponse?: RpcCongestionLevelResponse;
  RpcGasPriceRequest?: RpcGasPriceRequest;
  RpcGasPriceResponse?: RpcGasPriceResponse;
  RpcHealthRequest?: RpcHealthRequest;
  RpcHealthResponse?: RpcHealthResponse;
  RpcKnownProducer?: RpcKnownProducer;
  RpcLightClientBlockProofRequest?: RpcLightClientBlockProofRequest;
  RpcLightClientBlockProofResponse?: RpcLightClientBlockProofResponse;
  RpcLightClientExecutionProofRequest?: RpcLightClientExecutionProofRequest;
  RpcLightClientExecutionProofResponse?: RpcLightClientExecutionProofResponse;
  RpcLightClientNextBlockRequest?: RpcLightClientNextBlockRequest;
  RpcLightClientNextBlockResponse?: RpcLightClientNextBlockResponse;
  RpcMaintenanceWindowsRequest?: RpcMaintenanceWindowsRequest;
  RpcNetworkInfoRequest?: RpcNetworkInfoRequest;
  RpcNetworkInfoResponse?: RpcNetworkInfoResponse;
  RpcPeerInfo?: RpcPeerInfo;
  RpcProtocolConfigRequest?: RpcProtocolConfigRequest;
  RpcProtocolConfigResponse?: RpcProtocolConfigResponse;
  RpcQueryRequest?: RpcQueryRequest;
  RpcQueryResponse?: RpcQueryResponse;
  RpcReceiptRequest?: RpcReceiptRequest;
  RpcReceiptResponse?: RpcReceiptResponse;
  RpcSendTransactionRequest?: RpcSendTransactionRequest;
  RpcSplitStorageInfoRequest?: RpcSplitStorageInfoRequest;
  RpcSplitStorageInfoResponse?: RpcSplitStorageInfoResponse;
  RpcStateChangesInBlockByTypeRequest?: RpcStateChangesInBlockByTypeRequest;
  RpcStateChangesInBlockByTypeResponse?: RpcStateChangesInBlockByTypeResponse;
  RpcStateChangesInBlockRequest?: RpcStateChangesInBlockRequest;
  RpcStateChangesInBlockResponse?: RpcStateChangesInBlockResponse;
  RpcStatusRequest?: RpcStatusRequest;
  RpcStatusResponse?: RpcStatusResponse;
  RpcTransactionResponse?: RpcTransactionResponse;
  RpcTransactionStatusRequest?: RpcTransactionStatusRequest;
  RpcValidatorRequest?: RpcValidatorRequest;
  RpcValidatorResponse?: RpcValidatorResponse;
  RpcValidatorsOrderedRequest?: RpcValidatorsOrderedRequest;
  RuntimeConfigView?: RuntimeConfigView;
  RuntimeFeesConfigView?: RuntimeFeesConfigView;
  ShardId?: ShardId;
  ShardLayout?: ShardLayout;
  ShardLayoutV0?: ShardLayoutV0;
  ShardLayoutV1?: ShardLayoutV1;
  ShardLayoutV2?: ShardLayoutV2;
  ShardUId?: ShardUId;
  Signature?: Signature;
  SignedDelegateAction?: SignedDelegateAction;
  SignedTransaction?: SignedTransaction;
  SignedTransactionView?: SignedTransactionView;
  SlashedValidator?: SlashedValidator;
  StakeAction?: StakeAction;
  StateChangeCauseView?: StateChangeCauseView;
  StateChangeKindView?: StateChangeKindView;
  StateChangeWithCauseView?: StateChangeWithCauseView;
  StateItem?: StateItem;
  StateSyncConfig?: StateSyncConfig;
  StatusSyncInfo?: StatusSyncInfo;
  StorageError?: StorageError1;
  StorageGetMode?: StorageGetMode;
  StorageUsageConfigView?: StorageUsageConfigView;
  StoreKey?: StoreKey;
  StoreValue?: StoreValue;
  SyncCheckpoint?: SyncCheckpoint1;
  SyncConcurrency?: SyncConcurrency;
  SyncConfig?: SyncConfig;
  Tier1ProxyView?: Tier1ProxyView;
  TrackedShardsConfig?: TrackedShardsConfig;
  TransferAction?: TransferAction;
  TxExecutionError?: TxExecutionError;
  TxExecutionStatus?: TxExecutionStatus;
  UseGlobalContractAction?: UseGlobalContractAction;
  VMConfigView?: VMConfigView;
  VMKind?: VMKind;
  ValidatorInfo?: ValidatorInfo;
  ValidatorKickoutReason?: ValidatorKickoutReason;
  ValidatorKickoutView?: ValidatorKickoutView;
  ValidatorStakeView?: ValidatorStakeView;
  ValidatorStakeViewV1?: ValidatorStakeViewV1;
  ValidatorStakeViews?: ValidatorStakeViews;
  Version?: Version;
  ViewStateResult?: ViewStateResult1;
  WasmTrap?: WasmTrap1;
  WitnessConfigView?: WitnessConfigView;
  [k: string]: unknown;
}
/**
 * Access key provides limited access to an account. Each access key belongs to some account and
 * is identified by a unique (within the account) public key. One account may have large number of
 * access keys. Access keys allow to act on behalf of the account by restricting transactions
 * that can be issued.
 * `account_id,public_key` is a key in the state
 */
export interface AccessKey {
  /**
   * Nonce for this access key, used for tx nonce generation. When access key is created, nonce
   * is set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.
   * See <https://github.com/near/nearcore/issues/3779> for more details.
   */
  nonce: number;
  /**
   * Defines permissions for this access key.
   */
  permission: AccessKeyPermission;
  [k: string]: unknown;
}
export interface FunctionCall {
  FunctionCall: FunctionCallPermission;
}
/**
 * Grants limited permission to make transactions with FunctionCallActions
 * The permission can limit the allowed balance to be spent on the prepaid gas.
 * It also restrict the account ID of the receiver for this function call.
 * It also can restrict the method name for the allowed function calls.
 */
export interface FunctionCallPermission {
  /**
   * Allowance is a balance limit to use by this access key to pay for function call gas and
   * transaction fees. When this access key is used, both account balance and the allowance is
   * decreased by the same value.
   * `None` means unlimited allowance.
   * NOTE: To change or increase the allowance, the old access key needs to be deleted and a new
   * access key should be created.
   */
  allowance?: NearToken | null;
  /**
   * A list of method names that can be used. The access key only allows transactions with the
   * function call of one of the given method names.
   * Empty list means any method name can be used.
   */
  method_names: string[];
  /**
   * The access key only allows transactions with the given receiver's account id.
   */
  receiver_id: string;
  [k: string]: unknown;
}
/**
 * Describes the cost of creating an access key.
 */
export interface AccessKeyCreationConfigView {
  /**
   * Base cost of creating a full access access-key.
   */
  full_access_cost: Fee;
  /**
   * Base cost of creating an access-key restricted to specific functions.
   */
  function_call_cost: Fee;
  /**
   * Cost per byte of method_names of creating a restricted access-key.
   */
  function_call_cost_per_byte: Fee;
  [k: string]: unknown;
}
/**
 * Costs associated with an object that can only be sent over the network (and executed
 * by the receiver).
 * NOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.
 * And `execution` fee is burned when the item is being executed.
 */
export interface Fee {
  /**
   * Fee for executing the object.
   */
  execution: NearGas;
  /**
   * Fee for sending an object potentially across the shards.
   */
  send_not_sir: NearGas;
  /**
   * Fee for sending an object from the sender to itself, guaranteeing that it does not leave
   * the shard.
   */
  send_sir: NearGas;
  [k: string]: unknown;
}
/**
 * Describes information about an access key including the public key.
 */
export interface AccessKeyInfoView {
  access_key: AccessKeyView;
  public_key: PublicKey;
  [k: string]: unknown;
}
/**
 * Describes access key permission scope and nonce.
 */
export interface AccessKeyView {
  nonce: number;
  permission: AccessKeyPermissionView;
  [k: string]: unknown;
}
export interface FunctionCall1 {
  FunctionCall: {
    allowance?: NearToken | null;
    method_names: string[];
    receiver_id: string;
    [k: string]: unknown;
  };
}
/**
 * Lists access keys
 */
export interface AccessKeyList {
  keys: AccessKeyInfoView[];
  [k: string]: unknown;
}
/**
 * The structure describes configuration for creation of new accounts.
 */
export interface AccountCreationConfigView {
  /**
   * The minimum length of the top-level account ID that is allowed to be created by any account.
   */
  min_allowed_top_level_account_length: number;
  /**
   * The account ID of the account registrar. This account ID allowed to create top-level
   * accounts of any valid length.
   */
  registrar_account_id: AccountId;
  [k: string]: unknown;
}
/**
 * AccountData is a piece of global state that a validator
 * signs and broadcasts to the network.
 *
 * It is essentially the data that a validator wants to share with the network.
 * All the nodes in the network are collecting the account data
 * broadcasted by the validators.
 * Since the number of the validators is bounded and their
 * identity is known (and the maximal size of allowed AccountData is bounded)
 * the global state that is distributed in the form of AccountData is bounded
 * as well.
 * Find more information in the docs [here](https://github.com/near/nearcore/blob/560f7fc8f4b3106e0d5d46050688610b1f104ac6/chain/client/src/client.rs#L2232)
 */
export interface AccountDataView {
  /**
   * Account key of the validator signing this AccountData.
   */
  account_key: PublicKey;
  /**
   * ID of the node that handles the account key (aka validator key).
   */
  peer_id: PublicKey;
  /**
   * Proxy nodes that are directly connected to the validator node
   * (this list may include the validator node itself).
   * TIER1 nodes should connect to one of the proxies to sent TIER1
   * messages to the validator.
   */
  proxies: Tier1ProxyView[];
  /**
   * UTC timestamp of when the AccountData has been signed.
   */
  timestamp: string;
  [k: string]: unknown;
}
export interface Tier1ProxyView {
  addr: string;
  peer_id: PublicKey;
  [k: string]: unknown;
}
/**
 * Account info for validators
 */
export interface AccountInfo {
  account_id: AccountId;
  amount: NearToken;
  public_key: PublicKey;
  [k: string]: unknown;
}
/**
 * A view of the account
 */
export interface AccountView {
  amount: NearToken;
  code_hash: CryptoHash;
  global_contract_account_id?: AccountId | null;
  global_contract_hash?: CryptoHash | null;
  locked: NearToken;
  /**
   * TODO(2271): deprecated.
   */
  storage_paid_at?: number;
  storage_usage: number;
  [k: string]: unknown;
}
/**
 * Account ID with its public key.
 */
export interface AccountWithPublicKey {
  account_id: AccountId;
  public_key: PublicKey;
  [k: string]: unknown;
}
/**
 * Describes the cost of creating a specific action, `Action`. Includes all variants.
 */
export interface ActionCreationConfigView {
  /**
   * Base cost of adding a key.
   */
  add_key_cost: AccessKeyCreationConfigView;
  /**
   * Base cost of creating an account.
   */
  create_account_cost: Fee;
  /**
   * Base cost for processing a delegate action.
   *
   * This is on top of the costs for the actions inside the delegate action.
   */
  delegate_cost: Fee;
  /**
   * Base cost of deleting an account.
   */
  delete_account_cost: Fee;
  /**
   * Base cost of deleting a key.
   */
  delete_key_cost: Fee;
  /**
   * Base cost of deploying a contract.
   */
  deploy_contract_cost: Fee;
  /**
   * Cost per byte of deploying a contract.
   */
  deploy_contract_cost_per_byte: Fee;
  /**
   * Base cost of calling a function.
   */
  function_call_cost: Fee;
  /**
   * Cost per byte of method name and arguments of calling a function.
   */
  function_call_cost_per_byte: Fee;
  /**
   * Base cost of staking.
   */
  stake_cost: Fee;
  /**
   * Base cost of making a transfer.
   */
  transfer_cost: Fee;
  [k: string]: unknown;
}
/**
 * An error happened during Action execution
 */
export interface ActionError {
  /**
   * Index of the failed action in the transaction.
   * Action index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`
   */
  index?: number | null;
  /**
   * The kind of ActionError happened
   */
  kind: ActionErrorKind;
  [k: string]: unknown;
}
/**
 * Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage
 */
export interface AccountAlreadyExists {
  AccountAlreadyExists: {
    account_id: AccountId;
    [k: string]: unknown;
  };
}
/**
 * Happens when TX receiver_id doesn't exist (but action is not Action::CreateAccount)
 */
export interface AccountDoesNotExist {
  AccountDoesNotExist: {
    account_id: AccountId;
    [k: string]: unknown;
  };
}
/**
 * A top-level account ID can only be created by registrar.
 */
export interface CreateAccountOnlyByRegistrar {
  CreateAccountOnlyByRegistrar: {
    account_id: AccountId;
    predecessor_id: AccountId;
    registrar_account_id: AccountId;
    [k: string]: unknown;
  };
}
/**
 * A newly created account must be under a namespace of the creator account
 */
export interface CreateAccountNotAllowed {
  CreateAccountNotAllowed: {
    account_id: AccountId;
    predecessor_id: AccountId;
    [k: string]: unknown;
  };
}
/**
 * Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver
 * or the first TX action is a `CreateAccount` action
 */
export interface ActorNoPermission {
  ActorNoPermission: {
    account_id: AccountId;
    actor_id: AccountId;
    [k: string]: unknown;
  };
}
/**
 * Account tries to remove an access key that doesn't exist
 */
export interface DeleteKeyDoesNotExist {
  DeleteKeyDoesNotExist: {
    account_id: AccountId;
    public_key: PublicKey;
    [k: string]: unknown;
  };
}
/**
 * The public key is already used for an existing access key
 */
export interface AddKeyAlreadyExists {
  AddKeyAlreadyExists: {
    account_id: AccountId;
    public_key: PublicKey;
    [k: string]: unknown;
  };
}
/**
 * Account is staking and can not be deleted
 */
export interface DeleteAccountStaking {
  DeleteAccountStaking: {
    account_id: AccountId;
    [k: string]: unknown;
  };
}
/**
 * ActionReceipt can't be completed, because the remaining balance will not be enough to cover storage.
 */
export interface LackBalanceForState {
  LackBalanceForState: {
    /**
     * An account which needs balance
     */
    account_id: AccountId;
    /**
     * Balance required to complete an action.
     */
    amount: NearToken;
    [k: string]: unknown;
  };
}
/**
 * Account is not yet staked, but tries to unstake
 */
export interface TriesToUnstake {
  TriesToUnstake: {
    account_id: AccountId;
    [k: string]: unknown;
  };
}
/**
 * The account doesn't have enough balance to increase the stake.
 */
export interface TriesToStake {
  TriesToStake: {
    account_id: AccountId;
    balance: NearToken;
    locked: NearToken;
    stake: NearToken;
    [k: string]: unknown;
  };
}
export interface InsufficientStake {
  InsufficientStake: {
    account_id: AccountId;
    minimum_stake: NearToken;
    stake: NearToken;
    [k: string]: unknown;
  };
}
/**
 * An error occurred during a `FunctionCall` Action, parameter is debug message.
 */
export interface FunctionCallError {
  FunctionCallError: FunctionCallError1;
}
/**
 * Wasm compilation error
 */
export interface CompilationError {
  CompilationError: CompilationError1;
}
export interface CodeDoesNotExist {
  CodeDoesNotExist: {
    account_id: AccountId;
    [k: string]: unknown;
  };
}
export interface PrepareError {
  PrepareError: PrepareError1;
}
/**
 * This is for defense in depth.
 * We expect our runtime-independent preparation code to fully catch all invalid wasms,
 * but, if it ever misses something we’ll emit this error
 */
export interface WasmerCompileError {
  WasmerCompileError: {
    msg: string;
    [k: string]: unknown;
  };
}
/**
 * Wasm binary env link error
 *
 * Note: this is only to deserialize old data, use execution error for new data
 */
export interface LinkError {
  LinkError: {
    msg: string;
    [k: string]: unknown;
  };
}
/**
 * Import/export resolve error
 */
export interface MethodResolveError {
  MethodResolveError: MethodResolveError1;
}
/**
 * A trap happened during execution of a binary
 *
 * Note: this is only to deserialize old data, use execution error for new data
 */
export interface WasmTrap {
  WasmTrap: WasmTrap1;
}
/**
 * Note: this is only to deserialize old data, use execution error for new data
 */
export interface HostError {
  HostError: HostError1;
}
/**
 * Smart contract panicked
 */
export interface GuestPanic {
  GuestPanic: {
    panic_msg: string;
    [k: string]: unknown;
  };
}
/**
 * `promise_idx` does not correspond to existing promises
 */
export interface InvalidPromiseIndex {
  InvalidPromiseIndex: {
    promise_idx: number;
    [k: string]: unknown;
  };
}
/**
 * Accessed invalid promise result index
 */
export interface InvalidPromiseResultIndex {
  InvalidPromiseResultIndex: {
    result_idx: number;
    [k: string]: unknown;
  };
}
/**
 * Accessed invalid register id
 */
export interface InvalidRegisterId {
  InvalidRegisterId: {
    register_id: number;
    [k: string]: unknown;
  };
}
/**
 * Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie
 */
export interface IteratorWasInvalidated {
  IteratorWasInvalidated: {
    iterator_index: number;
    [k: string]: unknown;
  };
}
/**
 * VM Logic returned an invalid receipt index
 */
export interface InvalidReceiptIndex {
  InvalidReceiptIndex: {
    receipt_index: number;
    [k: string]: unknown;
  };
}
/**
 * Iterator index `iterator_index` does not exist
 */
export interface InvalidIteratorIndex {
  InvalidIteratorIndex: {
    iterator_index: number;
    [k: string]: unknown;
  };
}
/**
 * `method_name` is not allowed in view calls
 */
export interface ProhibitedInView {
  ProhibitedInView: {
    method_name: string;
    [k: string]: unknown;
  };
}
/**
 * The total number of logs will exceed the limit.
 */
export interface NumberOfLogsExceeded {
  NumberOfLogsExceeded: {
    limit: number;
    [k: string]: unknown;
  };
}
/**
 * The storage key length exceeded the limit.
 */
export interface KeyLengthExceeded {
  KeyLengthExceeded: {
    length: number;
    limit: number;
    [k: string]: unknown;
  };
}
/**
 * The storage value length exceeded the limit.
 */
export interface ValueLengthExceeded {
  ValueLengthExceeded: {
    length: number;
    limit: number;
    [k: string]: unknown;
  };
}
/**
 * The total log length exceeded the limit.
 */
export interface TotalLogLengthExceeded {
  TotalLogLengthExceeded: {
    length: number;
    limit: number;
    [k: string]: unknown;
  };
}
/**
 * The maximum number of promises within a FunctionCall exceeded the limit.
 */
export interface NumberPromisesExceeded {
  NumberPromisesExceeded: {
    limit: number;
    number_of_promises: number;
    [k: string]: unknown;
  };
}
/**
 * The maximum number of input data dependencies exceeded the limit.
 */
export interface NumberInputDataDependenciesExceeded {
  NumberInputDataDependenciesExceeded: {
    limit: number;
    number_of_input_data_dependencies: number;
    [k: string]: unknown;
  };
}
/**
 * The returned value length exceeded the limit.
 */
export interface ReturnedValueLengthExceeded {
  ReturnedValueLengthExceeded: {
    length: number;
    limit: number;
    [k: string]: unknown;
  };
}
/**
 * The contract size for DeployContract action exceeded the limit.
 */
export interface ContractSizeExceeded {
  ContractSizeExceeded: {
    limit: number;
    size: number;
    [k: string]: unknown;
  };
}
/**
 * The host function was deprecated.
 */
export interface Deprecated {
  Deprecated: {
    method_name: string;
    [k: string]: unknown;
  };
}
/**
 * General errors for ECDSA recover.
 */
export interface ECRecoverError {
  ECRecoverError: {
    msg: string;
    [k: string]: unknown;
  };
}
/**
 * Invalid input to alt_bn128 family of functions (e.g., point which isn't
 * on the curve).
 */
export interface AltBn128InvalidInput {
  AltBn128InvalidInput: {
    msg: string;
    [k: string]: unknown;
  };
}
/**
 * Invalid input to ed25519 signature verification function (e.g. signature cannot be
 * derived from bytes).
 */
export interface Ed25519VerifyInvalidInput {
  Ed25519VerifyInvalidInput: {
    msg: string;
    [k: string]: unknown;
  };
}
export interface ExecutionError {
  ExecutionError: string;
}
/**
 * Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails
 * receipt validation.
 */
export interface NewReceiptValidationError {
  NewReceiptValidationError: ReceiptValidationError;
}
/**
 * The `predecessor_id` of a Receipt is not valid.
 */
export interface InvalidPredecessorId {
  InvalidPredecessorId: {
    account_id: string;
    [k: string]: unknown;
  };
}
/**
 * The `receiver_id` of a Receipt is not valid.
 */
export interface InvalidReceiverId {
  InvalidReceiverId: {
    account_id: string;
    [k: string]: unknown;
  };
}
/**
 * The `signer_id` of an ActionReceipt is not valid.
 */
export interface InvalidSignerId {
  InvalidSignerId: {
    account_id: string;
    [k: string]: unknown;
  };
}
/**
 * The `receiver_id` of a DataReceiver within an ActionReceipt is not valid.
 */
export interface InvalidDataReceiverId {
  InvalidDataReceiverId: {
    account_id: string;
    [k: string]: unknown;
  };
}
/**
 * The length of the returned data exceeded the limit in a DataReceipt.
 */
export interface ReturnedValueLengthExceeded1 {
  ReturnedValueLengthExceeded: {
    length: number;
    limit: number;
    [k: string]: unknown;
  };
}
/**
 * The number of input data dependencies exceeds the limit in an ActionReceipt.
 */
export interface NumberInputDataDependenciesExceeded1 {
  NumberInputDataDependenciesExceeded: {
    limit: number;
    number_of_input_data_dependencies: number;
    [k: string]: unknown;
  };
}
/**
 * An error occurred while validating actions of an ActionReceipt.
 */
export interface ActionsValidation {
  ActionsValidation: ActionsValidationError;
}
/**
 * The total prepaid gas (for all given actions) exceeded the limit.
 */
export interface TotalPrepaidGasExceeded {
  TotalPrepaidGasExceeded: {
    limit: NearGas;
    total_prepaid_gas: NearGas;
    [k: string]: unknown;
  };
}
/**
 * The number of actions exceeded the given limit.
 */
export interface TotalNumberOfActionsExceeded {
  TotalNumberOfActionsExceeded: {
    limit: number;
    total_number_of_actions: number;
    [k: string]: unknown;
  };
}
/**
 * The total number of bytes of the method names exceeded the limit in a Add Key action.
 */
export interface AddKeyMethodNamesNumberOfBytesExceeded {
  AddKeyMethodNamesNumberOfBytesExceeded: {
    limit: number;
    total_number_of_bytes: number;
    [k: string]: unknown;
  };
}
/**
 * The length of some method name exceeded the limit in a Add Key action.
 */
export interface AddKeyMethodNameLengthExceeded {
  AddKeyMethodNameLengthExceeded: {
    length: number;
    limit: number;
    [k: string]: unknown;
  };
}
/**
 * Invalid account ID.
 */
export interface InvalidAccountId {
  InvalidAccountId: {
    account_id: string;
    [k: string]: unknown;
  };
}
/**
 * The size of the contract code exceeded the limit in a DeployContract action.
 */
export interface ContractSizeExceeded1 {
  ContractSizeExceeded: {
    limit: number;
    size: number;
    [k: string]: unknown;
  };
}
/**
 * The length of the method name exceeded the limit in a Function Call action.
 */
export interface FunctionCallMethodNameLengthExceeded {
  FunctionCallMethodNameLengthExceeded: {
    length: number;
    limit: number;
    [k: string]: unknown;
  };
}
/**
 * The length of the arguments exceeded the limit in a Function Call action.
 */
export interface FunctionCallArgumentsLengthExceeded {
  FunctionCallArgumentsLengthExceeded: {
    length: number;
    limit: number;
    [k: string]: unknown;
  };
}
/**
 * An attempt to stake with a public key that is not convertible to ristretto.
 */
export interface UnsuitableStakingKey {
  UnsuitableStakingKey: {
    public_key: PublicKey;
    [k: string]: unknown;
  };
}
/**
 * The transaction includes a feature that the current protocol version
 * does not support.
 *
 * Note: we stringify the protocol feature name instead of using
 * `ProtocolFeature` here because we don't want to leak the internals of
 * that type into observable borsh serialization.
 */
export interface UnsupportedProtocolFeature {
  UnsupportedProtocolFeature: {
    protocol_feature: string;
    version: number;
    [k: string]: unknown;
  };
}
export interface InvalidDeterministicStateInitReceiver {
  InvalidDeterministicStateInitReceiver: {
    derived_id: AccountId;
    receiver_id: AccountId;
    [k: string]: unknown;
  };
}
export interface DeterministicStateInitKeyLengthExceeded {
  DeterministicStateInitKeyLengthExceeded: {
    length: number;
    limit: number;
    [k: string]: unknown;
  };
}
export interface DeterministicStateInitValueLengthExceeded {
  DeterministicStateInitValueLengthExceeded: {
    length: number;
    limit: number;
    [k: string]: unknown;
  };
}
/**
 * Receipt is bigger than the limit.
 */
export interface ReceiptSizeExceeded {
  ReceiptSizeExceeded: {
    limit: number;
    size: number;
    [k: string]: unknown;
  };
}
/**
 * The `refund_to` of an ActionReceipt is not valid.
 */
export interface InvalidRefundTo {
  InvalidRefundTo: {
    account_id: string;
    [k: string]: unknown;
  };
}
/**
 * Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.
 * See NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.
 * Also, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.
 *
 * TODO(#8598): This error is named very poorly. A better name would be
 * `OnlyNamedAccountCreationAllowed`.
 */
export interface OnlyImplicitAccountCreationAllowed {
  OnlyImplicitAccountCreationAllowed: {
    account_id: AccountId;
    [k: string]: unknown;
  };
}
/**
 * Delete account whose state is large is temporarily banned.
 */
export interface DeleteAccountWithLargeState {
  DeleteAccountWithLargeState: {
    account_id: AccountId;
    [k: string]: unknown;
  };
}
/**
 * Receiver of the transaction doesn't match Sender of the delegate action
 */
export interface DelegateActionSenderDoesNotMatchTxReceiver {
  DelegateActionSenderDoesNotMatchTxReceiver: {
    receiver_id: AccountId;
    sender_id: AccountId;
    [k: string]: unknown;
  };
}
/**
 * The given public key doesn't exist for Sender account
 */
export interface DelegateActionAccessKeyError {
  DelegateActionAccessKeyError: InvalidAccessKeyError;
}
/**
 * The access key identified by the `public_key` doesn't exist for the account
 */
export interface AccessKeyNotFound {
  AccessKeyNotFound: {
    account_id: AccountId;
    public_key: PublicKey;
    [k: string]: unknown;
  };
}
/**
 * Transaction `receiver_id` doesn't match the access key receiver_id
 */
export interface ReceiverMismatch {
  ReceiverMismatch: {
    ak_receiver: string;
    tx_receiver: AccountId;
    [k: string]: unknown;
  };
}
/**
 * Transaction method name isn't allowed by the access key
 */
export interface MethodNameMismatch {
  MethodNameMismatch: {
    method_name: string;
    [k: string]: unknown;
  };
}
/**
 * Access Key does not have enough allowance to cover transaction cost
 */
export interface NotEnoughAllowance {
  NotEnoughAllowance: {
    account_id: AccountId;
    allowance: NearToken;
    cost: NearToken;
    public_key: PublicKey;
    [k: string]: unknown;
  };
}
/**
 * DelegateAction nonce must be greater sender[public_key].nonce
 */
export interface DelegateActionInvalidNonce {
  DelegateActionInvalidNonce: {
    ak_nonce: number;
    delegate_nonce: number;
    [k: string]: unknown;
  };
}
/**
 * DelegateAction nonce is larger than the upper bound given by the block height
 */
export interface DelegateActionNonceTooLarge {
  DelegateActionNonceTooLarge: {
    delegate_nonce: number;
    upper_bound: number;
    [k: string]: unknown;
  };
}
export interface GlobalContractDoesNotExist {
  GlobalContractDoesNotExist: {
    identifier: GlobalContractIdentifier;
    [k: string]: unknown;
  };
}
export interface CodeHash {
  CodeHash: CryptoHash;
}
export interface AccountId1 {
  AccountId: AccountId;
}
export interface DeployContract {
  DeployContract: {
    code: string;
    [k: string]: unknown;
  };
}
export interface FunctionCall2 {
  FunctionCall: {
    args: FunctionArgs;
    deposit: NearToken;
    gas: NearGas;
    method_name: string;
    [k: string]: unknown;
  };
}
export interface Transfer {
  Transfer: {
    deposit: NearToken;
    [k: string]: unknown;
  };
}
export interface Stake {
  Stake: {
    public_key: PublicKey;
    stake: NearToken;
    [k: string]: unknown;
  };
}
export interface AddKey {
  AddKey: {
    access_key: AccessKeyView;
    public_key: PublicKey;
    [k: string]: unknown;
  };
}
export interface DeleteKey {
  DeleteKey: {
    public_key: PublicKey;
    [k: string]: unknown;
  };
}
export interface DeleteAccount {
  DeleteAccount: {
    beneficiary_id: AccountId;
    [k: string]: unknown;
  };
}
export interface Delegate {
  Delegate: {
    delegate_action: DelegateAction;
    signature: Signature;
    [k: string]: unknown;
  };
}
/**
 * This action allows to execute the inner actions behalf of the defined sender.
 */
export interface DelegateAction {
  /**
   * List of actions to be executed.
   *
   * With the meta transactions MVP defined in NEP-366, nested
   * DelegateActions are not allowed. A separate type is used to enforce it.
   */
  actions: NonDelegateAction[];
  /**
   * The maximal height of the block in the blockchain below which the given DelegateAction is valid.
   */
  max_block_height: number;
  /**
   * Nonce to ensure that the same delegate action is not sent twice by a
   * relayer and should match for given account's `public_key`.
   * After this action is processed it will increment.
   */
  nonce: number;
  /**
   * Public key used to sign this delegated action.
   */
  public_key: PublicKey;
  /**
   * Receiver of the delegated actions.
   */
  receiver_id: AccountId;
  /**
   * Signer of the delegated actions
   */
  sender_id: AccountId;
  [k: string]: unknown;
}
/**
 * Create an (sub)account using a transaction `receiver_id` as an ID for
 * a new account ID must pass validation rules described here
 * <https://nomicon.io/DataStructures/Account>.
 */
export interface CreateAccount {
  CreateAccount: CreateAccountAction;
}
/**
 * Create account action
 */
export interface CreateAccountAction {
  [k: string]: unknown;
}
/**
 * Sets a Wasm code to a receiver_id
 */
export interface DeployContract1 {
  DeployContract: DeployContractAction;
}
/**
 * Deploy contract action
 */
export interface DeployContractAction {
  /**
   * WebAssembly binary
   */
  code: string;
  [k: string]: unknown;
}
export interface FunctionCall3 {
  FunctionCall: FunctionCallAction;
}
export interface FunctionCallAction {
  args: string;
  deposit: NearToken;
  gas: NearGas;
  method_name: string;
  [k: string]: unknown;
}
export interface Transfer1 {
  Transfer: TransferAction;
}
export interface TransferAction {
  deposit: NearToken;
  [k: string]: unknown;
}
export interface Stake1 {
  Stake: StakeAction;
}
/**
 * An action which stakes signer_id tokens and setup's validator public key
 */
export interface StakeAction {
  /**
   * Validator key which will be used to sign transactions on behalf of signer_id
   */
  public_key: PublicKey;
  /**
   * Amount of tokens to stake.
   */
  stake: NearToken;
  [k: string]: unknown;
}
export interface AddKey1 {
  AddKey: AddKeyAction;
}
/**
 * An action that adds key with public key associated
 */
export interface AddKeyAction {
  /**
   * An access key with the permission
   */
  access_key: AccessKey;
  /**
   * A public key which will be associated with an access_key
   */
  public_key: PublicKey;
  [k: string]: unknown;
}
export interface DeleteKey1 {
  DeleteKey: DeleteKeyAction;
}
export interface DeleteKeyAction {
  /**
   * A public key associated with the access_key to be deleted.
   */
  public_key: PublicKey;
  [k: string]: unknown;
}
export interface DeleteAccount1 {
  DeleteAccount: DeleteAccountAction;
}
export interface DeleteAccountAction {
  beneficiary_id: AccountId;
  [k: string]: unknown;
}
export interface DeployGlobalContract {
  DeployGlobalContract: DeployGlobalContractAction;
}
/**
 * Deploy global contract action
 */
export interface DeployGlobalContractAction {
  /**
   * WebAssembly binary
   */
  code: string;
  deploy_mode: GlobalContractDeployMode;
  [k: string]: unknown;
}
export interface UseGlobalContract {
  UseGlobalContract: UseGlobalContractAction;
}
/**
 * Use global contract action
 */
export interface UseGlobalContractAction {
  contract_identifier: GlobalContractIdentifier;
  [k: string]: unknown;
}
export interface DeterministicStateInit {
  DeterministicStateInit: DeterministicStateInitAction;
}
export interface DeterministicStateInitAction {
  deposit: NearToken;
  state_init: DeterministicAccountStateInit;
  [k: string]: unknown;
}
export interface V1 {
  V1: DeterministicAccountStateInitV1;
}
export interface DeterministicAccountStateInitV1 {
  code: GlobalContractIdentifier;
  data: {
    [k: string]: string;
  };
  [k: string]: unknown;
}
export interface DeployGlobalContract1 {
  DeployGlobalContract: {
    code: string;
    [k: string]: unknown;
  };
}
export interface DeployGlobalContractByAccountId {
  DeployGlobalContractByAccountId: {
    code: string;
    [k: string]: unknown;
  };
}
export interface UseGlobalContract1 {
  UseGlobalContract: {
    code_hash: CryptoHash;
    [k: string]: unknown;
  };
}
export interface UseGlobalContractByAccountId {
  UseGlobalContractByAccountId: {
    account_id: AccountId;
    [k: string]: unknown;
  };
}
export interface DeterministicStateInit1 {
  DeterministicStateInit: {
    code: GlobalContractIdentifierView;
    data: {
      [k: string]: string;
    };
    deposit: NearToken;
    [k: string]: unknown;
  };
}
export interface Hash {
  hash: CryptoHash;
}
export interface AccountId2 {
  account_id: AccountId;
}
/**
 * `BandwidthRequest` describes the size of receipts that a shard would like to send to another shard.
 * When a shard wants to send a lot of receipts to another shard, it needs to create a request and wait
 * for a bandwidth grant from the bandwidth scheduler.
 */
export interface BandwidthRequest {
  /**
   * Bitmap which describes what values of bandwidth are requested.
   */
  requested_values_bitmap: BandwidthRequestBitmap;
  /**
   * Requesting bandwidth to this shard.
   */
  to_shard: number;
  [k: string]: unknown;
}
/**
 * Bitmap which describes which values from the predefined list are being requested.
 * The nth bit is set to 1 when the nth value from the list is being requested.
 */
export interface BandwidthRequestBitmap {
  /**
   * @minItems 5
   * @maxItems 5
   */
  data: [number, number, number, number, number];
  [k: string]: unknown;
}
export interface V11 {
  V1: BandwidthRequestsV1;
}
/**
 * Version 1 of [`BandwidthRequest`].
 */
export interface BandwidthRequestsV1 {
  requests: BandwidthRequest[];
  [k: string]: unknown;
}
/**
 * A part of a state for the current head of a light client. More info [here](https://nomicon.io/ChainSpec/LightClient).
 */
export interface BlockHeaderInnerLiteView {
  /**
   * The merkle root of all the block hashes
   */
  block_merkle_root: CryptoHash;
  /**
   * The epoch to which the block that is the current known head belongs
   */
  epoch_id: CryptoHash;
  height: number;
  /**
   * The hash of the block producers set for the next epoch
   */
  next_bp_hash: CryptoHash;
  /**
   * The epoch that will follow the current epoch
   */
  next_epoch_id: CryptoHash;
  outcome_root: CryptoHash;
  prev_state_root: CryptoHash;
  /**
   * Legacy json number. Should not be used.
   */
  timestamp: number;
  timestamp_nanosec: string;
  [k: string]: unknown;
}
/**
 * Contains main info about the block.
 */
export interface BlockHeaderView {
  approvals: (Signature | null)[];
  block_body_hash?: CryptoHash | null;
  block_merkle_root: CryptoHash;
  block_ordinal?: number | null;
  challenges_result: SlashedValidator[];
  challenges_root: CryptoHash;
  chunk_endorsements?: number[][] | null;
  chunk_headers_root: CryptoHash;
  chunk_mask: boolean[];
  chunk_receipts_root: CryptoHash;
  chunk_tx_root: CryptoHash;
  chunks_included: number;
  epoch_id: CryptoHash;
  epoch_sync_data_hash?: CryptoHash | null;
  gas_price: NearToken;
  hash: CryptoHash;
  height: number;
  last_ds_final_block: CryptoHash;
  last_final_block: CryptoHash;
  latest_protocol_version: number;
  next_bp_hash: CryptoHash;
  next_epoch_id: CryptoHash;
  outcome_root: CryptoHash;
  /**
   * The hash of the previous Block
   */
  prev_hash: CryptoHash;
  prev_height?: number | null;
  prev_state_root: CryptoHash;
  random_value: CryptoHash;
  /**
   * TODO(2271): deprecated.
   */
  rent_paid?: NearToken;
  /**
   * Signature of the block producer.
   */
  signature: Signature;
  /**
   * Legacy json number. Should not be used.
   */
  timestamp: number;
  timestamp_nanosec: string;
  total_supply: NearToken;
  validator_proposals: ValidatorStakeView[];
  /**
   * TODO(2271): deprecated.
   */
  validator_reward?: NearToken;
  [k: string]: unknown;
}
export interface SlashedValidator {
  account_id: AccountId;
  is_double_sign: boolean;
  [k: string]: unknown;
}
export interface ValidatorStakeViewV1 {
  account_id: AccountId;
  public_key: PublicKey;
  stake: NearToken;
  [k: string]: unknown;
}
export interface BlockHeightRange {
  end: number;
  start: number;
  [k: string]: unknown;
}
/**
 * Height and hash of a block
 */
export interface BlockStatusView {
  hash: CryptoHash;
  height: number;
  [k: string]: unknown;
}
/**
 * A result returned by contract method
 */
export interface CallResult {
  logs: string[];
  result: number[];
  [k: string]: unknown;
}
/**
 * Status of the [catchup](https://near.github.io/nearcore/architecture/how/sync.html#catchup) process
 */
export interface CatchupStatusView {
  blocks_to_catchup: BlockStatusView[];
  shard_sync_status: {
    /**
     * This interface was referenced by `undefined`'s JSON-Schema definition
     * via the `patternProperty` "^\d+$".
     */
    [k: string]: string;
  };
  sync_block_hash: CryptoHash;
  sync_block_height: number;
  [k: string]: unknown;
}
/**
 * Config for the Chunk Distribution Network feature.
 * This allows nodes to push and pull chunks from a central stream.
 * The two benefits of this approach are: (1) less request/response traffic
 * on the peer-to-peer network and (2) lower latency for RPC nodes indexing the chain.
 */
export interface ChunkDistributionNetworkConfig {
  enabled: boolean;
  uris: ChunkDistributionUris;
  [k: string]: unknown;
}
/**
 * URIs for the Chunk Distribution Network feature.
 */
export interface ChunkDistributionUris {
  /**
   * URI for pulling chunks from the stream.
   */
  get: string;
  /**
   * URI for publishing chunks to the stream.
   */
  set: string;
  [k: string]: unknown;
}
/**
 * Contains main info about the chunk.
 */
export interface ChunkHeaderView {
  balance_burnt: NearToken;
  bandwidth_requests?: BandwidthRequests | null;
  chunk_hash: CryptoHash;
  congestion_info?: CongestionInfoView | null;
  encoded_length: number;
  encoded_merkle_root: CryptoHash;
  gas_limit: NearGas;
  gas_used: NearGas;
  height_created: number;
  height_included: number;
  outcome_root: CryptoHash;
  outgoing_receipts_root: CryptoHash;
  prev_block_hash: CryptoHash;
  prev_state_root: CryptoHash;
  /**
   * TODO(2271): deprecated.
   */
  rent_paid?: NearToken;
  shard_id: ShardId;
  signature: Signature;
  tx_root: CryptoHash;
  validator_proposals: ValidatorStakeView[];
  /**
   * TODO(2271): deprecated.
   */
  validator_reward?: NearToken;
  [k: string]: unknown;
}
/**
 * Stores the congestion level of a shard. More info about congestion [here](https://near.github.io/nearcore/architecture/how/receipt-congestion.html?highlight=congestion#receipt-congestion)
 */
export interface CongestionInfoView {
  allowed_shard: number;
  buffered_receipts_gas: string;
  delayed_receipts_gas: string;
  receipt_bytes: number;
  [k: string]: unknown;
}
/**
 * Configuration for a cloud-based archival writer. If this config is present, the writer is enabled and
 * writes chunk-related data based on the tracked shards. This config also controls additional archival
 * behavior such as block data and polling interval.
 */
export interface CloudArchivalWriterConfig {
  /**
   * Determines whether block-related data should be written to cloud storage.
   */
  archive_block_data?: boolean;
  /**
   * Interval at which the system checks for new blocks or chunks to archive.
   */
  polling_interval?: DurationAsStdSchemaProvider;
  [k: string]: unknown;
}
export interface DurationAsStdSchemaProvider {
  nanos: number;
  secs: number;
  [k: string]: unknown;
}
/**
 * The configuration for congestion control. More info about congestion [here](https://near.github.io/nearcore/architecture/how/receipt-congestion.html?highlight=congestion#receipt-congestion)
 */
export interface CongestionControlConfigView {
  /**
   * How much gas the chosen allowed shard can send to a 100% congested shard.
   *
   * See [`CongestionControlConfig`] for more details.
   */
  allowed_shard_outgoing_gas: NearGas;
  /**
   * How much gas in delayed receipts of a shard is 100% incoming congestion.
   *
   * See [`CongestionControlConfig`] for more details.
   */
  max_congestion_incoming_gas: NearGas;
  /**
   * How much memory space of all delayed and buffered receipts in a shard is
   * considered 100% congested.
   *
   * See [`CongestionControlConfig`] for more details.
   */
  max_congestion_memory_consumption: number;
  /**
   * How many missed chunks in a row in a shard is considered 100% congested.
   */
  max_congestion_missed_chunks: number;
  /**
   * How much gas in outgoing buffered receipts of a shard is 100% congested.
   *
   * Outgoing congestion contributes to overall congestion, which reduces how
   * much other shards are allowed to forward to this shard.
   */
  max_congestion_outgoing_gas: NearGas;
  /**
   * The maximum amount of gas attached to receipts a shard can forward to
   * another shard per chunk.
   *
   * See [`CongestionControlConfig`] for more details.
   */
  max_outgoing_gas: NearGas;
  /**
   * The maximum amount of gas in a chunk spent on converting new transactions to
   * receipts.
   *
   * See [`CongestionControlConfig`] for more details.
   */
  max_tx_gas: NearGas;
  /**
   * The minimum gas each shard can send to a shard that is not fully congested.
   *
   * See [`CongestionControlConfig`] for more details.
   */
  min_outgoing_gas: NearGas;
  /**
   * The minimum amount of gas in a chunk spent on converting new transactions
   * to receipts, as long as the receiving shard is not congested.
   *
   * See [`CongestionControlConfig`] for more details.
   */
  min_tx_gas: NearGas;
  /**
   * Large size limit for outgoing receipts to a shard, used when it's safe
   * to send a lot of receipts without making the state witness too large.
   * It limits the total sum of outgoing receipts, not individual receipts.
   */
  outgoing_receipts_big_size_limit: number;
  /**
   * The standard size limit for outgoing receipts aimed at a single shard.
   * This limit is pretty small to keep the size of source_receipt_proofs under control.
   * It limits the total sum of outgoing receipts, not individual receipts.
   */
  outgoing_receipts_usual_size_limit: number;
  /**
   * How much congestion a shard can tolerate before it stops all shards from
   * accepting new transactions with the receiver set to the congested shard.
   */
  reject_tx_congestion_threshold: number;
  [k: string]: unknown;
}
/**
 * A view of the contract code.
 */
export interface ContractCodeView {
  code_base64: string;
  hash: CryptoHash;
  [k: string]: unknown;
}
/**
 * Shows gas profile. More info [here](https://near.github.io/nearcore/architecture/gas/gas_profile.html?highlight=WASM_HOST_COST#example-transaction-gas-profile).
 */
export interface CostGasUsed {
  cost: string;
  /**
   * Either ACTION_COST or WASM_HOST_COST.
   */
  cost_category: string;
  gas_used: string;
  [k: string]: unknown;
}
/**
 * Describes information about the current epoch validator
 */
export interface CurrentEpochValidatorInfo {
  account_id: AccountId;
  is_slashed: boolean;
  num_expected_blocks: number;
  num_expected_chunks?: number;
  /**
   * Number of chunks this validator was expected to produce in each shard.
   * Each entry in the array corresponds to the shard in the `shards_produced` array.
   */
  num_expected_chunks_per_shard?: number[];
  num_expected_endorsements?: number;
  /**
   * Number of chunks this validator was expected to validate and endorse in each shard.
   * Each entry in the array corresponds to the shard in the `shards_endorsed` array.
   */
  num_expected_endorsements_per_shard?: number[];
  num_produced_blocks: number;
  num_produced_chunks?: number;
  num_produced_chunks_per_shard?: number[];
  num_produced_endorsements?: number;
  num_produced_endorsements_per_shard?: number[];
  public_key: PublicKey;
  /**
   * Shards this validator is assigned to as chunk producer in the current epoch.
   */
  shards: ShardId[];
  /**
   * Shards this validator is assigned to as chunk validator in the current epoch.
   */
  shards_endorsed?: ShardId[];
  stake: NearToken;
  [k: string]: unknown;
}
/**
 * The fees settings for a data receipt creation
 */
export interface DataReceiptCreationConfigView {
  /**
   * Base cost of creating a data receipt.
   * Both `send` and `exec` costs are burned when a new receipt has input dependencies. The gas
   * is charged for each input dependency. The dependencies are specified when a receipt is
   * created using `promise_then` and `promise_batch_then`.
   * NOTE: Any receipt with output dependencies will produce data receipts. Even if it fails.
   * Even if the last action is not a function call (in case of success it will return empty
   * value).
   */
  base_cost: Fee;
  /**
   * Additional cost per byte sent.
   * Both `send` and `exec` costs are burned when a function call finishes execution and returns
   * `N` bytes of data to every output dependency. For each output dependency the cost is
   * `(send(sir) + exec()) * N`.
   */
  cost_per_byte: Fee;
  [k: string]: unknown;
}
export interface DataReceiverView {
  data_id: CryptoHash;
  receiver_id: AccountId;
  [k: string]: unknown;
}
export interface DetailedDebugStatus {
  block_production_delay_millis: number;
  catchup_status: CatchupStatusView[];
  current_head_status: BlockStatusView;
  current_header_head_status: BlockStatusView;
  network_info: NetworkInfoView;
  sync_status: string;
  [k: string]: unknown;
}
export interface NetworkInfoView {
  connected_peers: PeerInfoView[];
  known_producers: KnownProducerView[];
  num_connected_peers: number;
  peer_max_count: number;
  tier1_accounts_data: AccountDataView[];
  tier1_accounts_keys: PublicKey[];
  tier1_connections: PeerInfoView[];
  [k: string]: unknown;
}
export interface PeerInfoView {
  account_id?: AccountId | null;
  addr: string;
  archival: boolean;
  block_hash?: CryptoHash | null;
  connection_established_time_millis: number;
  height?: number | null;
  is_highest_block_invalid: boolean;
  is_outbound_peer: boolean;
  last_time_peer_requested_millis: number;
  last_time_received_message_millis: number;
  /**
   * Connection nonce.
   */
  nonce: number;
  peer_id: PublicKey;
  received_bytes_per_sec: number;
  sent_bytes_per_sec: number;
  tracked_shards: ShardId[];
  [k: string]: unknown;
}
/**
 * Information about a Producer: its account name, peer_id and a list of connected peers that
 * the node can use to send message for this producer.
 */
export interface KnownProducerView {
  account_id: AccountId;
  next_hops?: PublicKey[] | null;
  peer_id: PublicKey;
  [k: string]: unknown;
}
/**
 * Configures how to dump state to external storage.
 */
export interface DumpConfig {
  /**
   * Location of a json file with credentials allowing access to the bucket.
   */
  credentials_file?: string | null;
  /**
   * How often to check if a new epoch has started.
   * Feel free to set to `None`, defaults are sensible.
   */
  iteration_delay?: DurationAsStdSchemaProvider | null;
  /**
   * Specifies where to write the obtained state parts.
   */
  location: ExternalStorageLocation;
  /**
   * Use in case a node that dumps state to the external storage
   * gets in trouble.
   */
  restart_dump_for_shards?: ShardId[] | null;
  [k: string]: unknown;
}
export interface S3 {
  S3: {
    /**
     * Location on S3.
     */
    bucket: string;
    /**
     * Data may only be available in certain locations.
     */
    region: string;
    [k: string]: unknown;
  };
}
/**
 * Local filesystem root for storing data.
 */
export interface Filesystem {
  Filesystem: {
    root_dir: string;
    [k: string]: unknown;
  };
}
/**
 * Google Cloud Storage bucket name.
 */
export interface GCS {
  GCS: {
    bucket: string;
    [k: string]: unknown;
  };
}
export interface EpochSyncConfig {
  /**
   * If true, even if the node started from genesis, it will not perform epoch sync.
   * There should be no reason to set this flag in production, because on both mainnet
   * and testnet it would be infeasible to catch up from genesis without epoch sync.
   */
  disable_epoch_sync_for_bootstrapping?: boolean;
  /**
   * This serves as two purposes: (1) the node will not epoch sync and instead resort to
   * header sync, if the genesis block is within this many blocks from the current block;
   * (2) the node will reject an epoch sync proof if the provided proof is for an epoch
   * that is more than this many blocks behind the current block.
   */
  epoch_sync_horizon: number;
  /**
   * If true, the node will ignore epoch sync requests from the network. It is strongly
   * recommended not to set this flag, because it will prevent other nodes from
   * bootstrapping. This flag is only included as a kill-switch and may be removed in a
   * future release. Please note that epoch sync requests are heavily rate limited and
   * cached, and therefore should not affect the performance of the node or introduce
   * any non-negligible increase in network traffic.
   */
  ignore_epoch_sync_network_requests?: boolean;
  /**
   * Timeout for epoch sync requests. The node will continue retrying indefinitely even
   * if this timeout is exceeded.
   */
  timeout_for_epoch_sync: DurationAsStdSchemaProvider;
  [k: string]: unknown;
}
export interface ExecutionMetadataView {
  gas_profile?: CostGasUsed[] | null;
  version: number;
  [k: string]: unknown;
}
export interface ExecutionOutcomeView {
  /**
   * The id of the account on which the execution happens. For transaction this is signer_id,
   * for receipt this is receiver_id.
   */
  executor_id: AccountId;
  /**
   * The amount of the gas burnt by the given transaction or receipt.
   */
  gas_burnt: NearGas;
  /**
   * Logs from this transaction or receipt.
   */
  logs: string[];
  /**
   * Execution metadata, versioned
   */
  metadata?: ExecutionMetadataView;
  /**
   * Receipt IDs generated by this transaction or receipt.
   */
  receipt_ids: CryptoHash[];
  /**
   * Execution status. Contains the result in case of successful execution.
   */
  status: ExecutionStatusView;
  /**
   * The amount of tokens burnt corresponding to the burnt gas amount.
   * This value doesn't always equal to the `gas_burnt` multiplied by the gas price, because
   * the prepaid gas price might be lower than the actual gas price and it creates a deficit.
   * `tokens_burnt` also contains the penalty subtracted from refunds, while
   * `gas_burnt` only contains the gas that we actually burn for the execution.
   */
  tokens_burnt: NearToken;
  [k: string]: unknown;
}
/**
 * The execution has failed.
 */
export interface Failure {
  Failure: TxExecutionError;
}
/**
 * An error happened during Action execution
 */
export interface ActionError1 {
  ActionError: ActionError;
}
/**
 * An error happened during Transaction execution
 */
export interface InvalidTxError {
  InvalidTxError: InvalidTxError1;
}
/**
 * Happens if a wrong AccessKey used or AccessKey has not enough permissions
 */
export interface InvalidAccessKeyError1 {
  InvalidAccessKeyError: InvalidAccessKeyError;
}
/**
 * TX signer_id is not a valid [`AccountId`]
 */
export interface InvalidSignerId1 {
  InvalidSignerId: {
    signer_id: string;
    [k: string]: unknown;
  };
}
/**
 * TX signer_id is not found in a storage
 */
export interface SignerDoesNotExist {
  SignerDoesNotExist: {
    signer_id: AccountId;
    [k: string]: unknown;
  };
}
/**
 * Transaction nonce must be strictly greater than `account[access_key].nonce`.
 */
export interface InvalidNonce {
  InvalidNonce: {
    ak_nonce: number;
    tx_nonce: number;
    [k: string]: unknown;
  };
}
/**
 * Transaction nonce is larger than the upper bound given by the block height
 */
export interface NonceTooLarge {
  NonceTooLarge: {
    tx_nonce: number;
    upper_bound: number;
    [k: string]: unknown;
  };
}
/**
 * TX receiver_id is not a valid AccountId
 */
export interface InvalidReceiverId1 {
  InvalidReceiverId: {
    receiver_id: string;
    [k: string]: unknown;
  };
}
/**
 * Account does not have enough balance to cover TX cost
 */
export interface NotEnoughBalance {
  NotEnoughBalance: {
    balance: NearToken;
    cost: NearToken;
    signer_id: AccountId;
    [k: string]: unknown;
  };
}
/**
 * Signer account doesn't have enough balance after transaction.
 */
export interface LackBalanceForState1 {
  LackBalanceForState: {
    /**
     * Required balance to cover the state.
     */
    amount: NearToken;
    /**
     * An account which doesn't have enough balance to cover storage.
     */
    signer_id: AccountId;
    [k: string]: unknown;
  };
}
/**
 * An error occurred while validating actions of a Transaction.
 */
export interface ActionsValidation1 {
  ActionsValidation: ActionsValidationError;
}
/**
 * The size of serialized transaction exceeded the limit.
 */
export interface TransactionSizeExceeded {
  TransactionSizeExceeded: {
    limit: number;
    size: number;
    [k: string]: unknown;
  };
}
export interface StorageError {
  StorageError: StorageError1;
}
/**
 * Requested trie value by its hash which is missing in storage.
 */
export interface MissingTrieValue {
  MissingTrieValue: MissingTrieValue1;
}
export interface MissingTrieValue1 {
  context: MissingTrieValueContext;
  hash: CryptoHash;
  [k: string]: unknown;
}
/**
 * Either invalid state or key-value db is corrupted.
 * For PartialStorage it cannot be corrupted.
 * Error message is unreliable and for debugging purposes only. It's also probably ok to
 * panic in every place that produces this error.
 * We can check if db is corrupted by verifying everything in the state trie.
 */
export interface StorageInconsistentState {
  StorageInconsistentState: string;
}
/**
 * Flat storage error, meaning that it doesn't support some block anymore.
 * We guarantee that such block cannot become final, thus block processing
 * must resume normally.
 */
export interface FlatStorageBlockNotSupported {
  FlatStorageBlockNotSupported: string;
}
/**
 * In-memory trie could not be loaded for some reason.
 */
export interface MemTrieLoadingError {
  MemTrieLoadingError: string;
}
/**
 * The receiver shard of the transaction is too congested to accept new
 * transactions at the moment.
 */
export interface ShardCongested {
  ShardCongested: {
    /**
     * A value between 0 (no congestion) and 1 (max congestion).
     */
    congestion_level: number;
    /**
     * The congested shard.
     */
    shard_id: number;
    [k: string]: unknown;
  };
}
/**
 * The receiver shard of the transaction missed several chunks and rejects
 * new transaction until it can make progress again.
 */
export interface ShardStuck {
  ShardStuck: {
    /**
     * The number of blocks since the last included chunk of the shard.
     */
    missed_chunks: number;
    /**
     * The shard that fails making progress.
     */
    shard_id: number;
    [k: string]: unknown;
  };
}
/**
 * The final action succeeded and returned some value or an empty vec encoded in base64.
 */
export interface SuccessValue {
  SuccessValue: string;
}
/**
 * The final action of the receipt returned a promise or the signed transaction was converted
 * to a receipt. Contains the receipt_id of the generated receipt.
 */
export interface SuccessReceiptId {
  SuccessReceiptId: CryptoHash;
}
export interface ExecutionOutcomeWithIdView {
  block_hash: CryptoHash;
  id: CryptoHash;
  outcome: ExecutionOutcomeView;
  proof: MerklePathItem[];
  [k: string]: unknown;
}
export interface MerklePathItem {
  direction: Direction;
  hash: CryptoHash;
  [k: string]: unknown;
}
/**
 * Typed view of ExtCostsConfig to preserve JSON output field names in protocol
 * config RPC output.
 */
export interface ExtCostsConfigView {
  /**
   * Base cost for multiexp
   */
  alt_bn128_g1_multiexp_base: NearGas;
  /**
   * Per element cost for multiexp
   */
  alt_bn128_g1_multiexp_element: NearGas;
  /**
   * Base cost for sum
   */
  alt_bn128_g1_sum_base: NearGas;
  /**
   * Per element cost for sum
   */
  alt_bn128_g1_sum_element: NearGas;
  /**
   * Base cost for pairing check
   */
  alt_bn128_pairing_check_base: NearGas;
  /**
   * Per element cost for pairing check
   */
  alt_bn128_pairing_check_element: NearGas;
  /**
   * Base cost for calling a host function.
   */
  base: NearGas;
  bls12381_g1_multiexp_base: NearGas;
  bls12381_g1_multiexp_element: NearGas;
  bls12381_g2_multiexp_base: NearGas;
  bls12381_g2_multiexp_element: NearGas;
  bls12381_map_fp2_to_g2_base: NearGas;
  bls12381_map_fp2_to_g2_element: NearGas;
  bls12381_map_fp_to_g1_base: NearGas;
  bls12381_map_fp_to_g1_element: NearGas;
  bls12381_p1_decompress_base: NearGas;
  bls12381_p1_decompress_element: NearGas;
  bls12381_p1_sum_base: NearGas;
  bls12381_p1_sum_element: NearGas;
  bls12381_p2_decompress_base: NearGas;
  bls12381_p2_decompress_element: NearGas;
  bls12381_p2_sum_base: NearGas;
  bls12381_p2_sum_element: NearGas;
  bls12381_pairing_base: NearGas;
  bls12381_pairing_element: NearGas;
  contract_compile_base: NearGas;
  contract_compile_bytes: NearGas;
  /**
   * Base cost of loading a pre-compiled contract
   */
  contract_loading_base: NearGas;
  /**
   * Cost per byte of loading a pre-compiled contract
   */
  contract_loading_bytes: NearGas;
  /**
   * Cost of calling ecrecover
   */
  ecrecover_base: NearGas;
  /**
   * Cost of getting ed25519 base
   */
  ed25519_verify_base: NearGas;
  /**
   * Cost of getting ed25519 per byte
   */
  ed25519_verify_byte: NearGas;
  /**
   * Cost of getting sha256 base
   */
  keccak256_base: NearGas;
  /**
   * Cost of getting sha256 per byte
   */
  keccak256_byte: NearGas;
  /**
   * Cost of getting sha256 base
   */
  keccak512_base: NearGas;
  /**
   * Cost of getting sha256 per byte
   */
  keccak512_byte: NearGas;
  /**
   * Cost for calling logging.
   */
  log_base: NearGas;
  /**
   * Cost for logging per byte
   */
  log_byte: NearGas;
  /**
   * Cost for calling `promise_and`
   */
  promise_and_base: NearGas;
  /**
   * Cost for calling `promise_and` for each promise
   */
  promise_and_per_promise: NearGas;
  /**
   * Cost for calling `promise_return`
   */
  promise_return: NearGas;
  /**
   * Cost for reading trie node from memory
   */
  read_cached_trie_node: NearGas;
  /**
   * Base cost for guest memory read
   */
  read_memory_base: NearGas;
  /**
   * Cost for guest memory read
   */
  read_memory_byte: NearGas;
  /**
   * Base cost for reading from register
   */
  read_register_base: NearGas;
  /**
   * Cost for reading byte from register
   */
  read_register_byte: NearGas;
  /**
   * Cost of getting ripemd160 base
   */
  ripemd160_base: NearGas;
  /**
   * Cost of getting ripemd160 per message block
   */
  ripemd160_block: NearGas;
  /**
   * Cost of getting sha256 base
   */
  sha256_base: NearGas;
  /**
   * Cost of getting sha256 per byte
   */
  sha256_byte: NearGas;
  /**
   * Storage trie check for key existence cost base
   */
  storage_has_key_base: NearGas;
  /**
   * Storage trie check for key existence per key byte
   */
  storage_has_key_byte: NearGas;
  /**
   * Create trie range iterator cost per byte of from key.
   */
  storage_iter_create_from_byte: NearGas;
  /**
   * Create trie prefix iterator cost base
   */
  storage_iter_create_prefix_base: NearGas;
  /**
   * Create trie prefix iterator cost per byte.
   */
  storage_iter_create_prefix_byte: NearGas;
  /**
   * Create trie range iterator cost base
   */
  storage_iter_create_range_base: NearGas;
  /**
   * Create trie range iterator cost per byte of to key.
   */
  storage_iter_create_to_byte: NearGas;
  /**
   * Trie iterator per key base cost
   */
  storage_iter_next_base: NearGas;
  /**
   * Trie iterator next key byte cost
   */
  storage_iter_next_key_byte: NearGas;
  /**
   * Trie iterator next key byte cost
   */
  storage_iter_next_value_byte: NearGas;
  /**
   * Storage trie read key overhead base cost, when doing large reads
   */
  storage_large_read_overhead_base: NearGas;
  /**
   * Storage trie read key overhead  per-byte cost, when doing large reads
   */
  storage_large_read_overhead_byte: NearGas;
  /**
   * Storage trie read key base cost
   */
  storage_read_base: NearGas;
  /**
   * Storage trie read key per byte cost
   */
  storage_read_key_byte: NearGas;
  /**
   * Storage trie read value cost per byte cost
   */
  storage_read_value_byte: NearGas;
  /**
   * Remove key from trie base cost
   */
  storage_remove_base: NearGas;
  /**
   * Remove key from trie per byte cost
   */
  storage_remove_key_byte: NearGas;
  /**
   * Remove key from trie ret value byte cost
   */
  storage_remove_ret_value_byte: NearGas;
  /**
   * Storage trie write key base cost
   */
  storage_write_base: NearGas;
  /**
   * Storage trie write cost per byte of evicted value.
   */
  storage_write_evicted_byte: NearGas;
  /**
   * Storage trie write key per byte cost
   */
  storage_write_key_byte: NearGas;
  /**
   * Storage trie write value per byte cost
   */
  storage_write_value_byte: NearGas;
  /**
   * Cost per reading trie node from DB
   */
  touching_trie_node: NearGas;
  /**
   * Base cost of decoding utf16. It's used for `log_utf16`.
   */
  utf16_decoding_base: NearGas;
  /**
   * Cost per byte of decoding utf16. It's used for `log_utf16`.
   */
  utf16_decoding_byte: NearGas;
  /**
   * Base cost of decoding utf8. It's used for `log_utf8` and `panic_utf8`.
   */
  utf8_decoding_base: NearGas;
  /**
   * Cost per byte of decoding utf8. It's used for `log_utf8` and `panic_utf8`.
   */
  utf8_decoding_byte: NearGas;
  /**
   * Cost of calling `validator_stake`.
   */
  validator_stake_base: NearGas;
  /**
   * Cost of calling `validator_total_stake`.
   */
  validator_total_stake_base: NearGas;
  /**
   * Base cost for guest memory write
   */
  write_memory_base: NearGas;
  /**
   * Cost for guest memory write per byte
   */
  write_memory_byte: NearGas;
  /**
   * Base cost for writing into register
   */
  write_register_base: NearGas;
  /**
   * Cost for writing byte into register
   */
  write_register_byte: NearGas;
  /**
   * Base cost for creating a yield promise.
   */
  yield_create_base: NearGas;
  /**
   * Per byte cost of arguments and method name.
   */
  yield_create_byte: NearGas;
  /**
   * Base cost for resuming a yield receipt.
   */
  yield_resume_base: NearGas;
  /**
   * Per byte cost of resume payload.
   */
  yield_resume_byte: NearGas;
  [k: string]: unknown;
}
export interface ExternalStorageConfig {
  /**
   * The number of attempts the node will make to obtain a part from peers in
   * the network before it fetches from external storage.
   */
  external_storage_fallback_threshold?: number;
  /**
   * Location of state parts.
   */
  location: ExternalStorageLocation;
  /**
   * When fetching state parts from external storage, throttle fetch requests
   * to this many concurrent requests.
   */
  num_concurrent_requests?: number;
  /**
   * During catchup, the node will use a different number of concurrent requests
   * to reduce the performance impact of state sync.
   */
  num_concurrent_requests_during_catchup?: number;
  [k: string]: unknown;
}
/**
 * Execution outcome of the transaction and all the subsequent receipts.
 * Could be not finalized yet
 */
export interface FinalExecutionOutcomeView {
  /**
   * The execution outcome of receipts.
   */
  receipts_outcome: ExecutionOutcomeWithIdView[];
  /**
   * Execution status defined by chain.rs:get_final_transaction_result
   * FinalExecutionStatus::NotStarted - the tx is not converted to the receipt yet
   * FinalExecutionStatus::Started - we have at least 1 receipt, but the first leaf receipt_id (using dfs) hasn't finished the execution
   * FinalExecutionStatus::Failure - the result of the first leaf receipt_id
   * FinalExecutionStatus::SuccessValue - the result of the first leaf receipt_id
   */
  status: FinalExecutionStatus;
  /**
   * Signed Transaction
   */
  transaction: SignedTransactionView;
  /**
   * The execution outcome of the signed transaction.
   */
  transaction_outcome: ExecutionOutcomeWithIdView;
  [k: string]: unknown;
}
/**
 * The execution has failed with the given error.
 */
export interface Failure1 {
  Failure: TxExecutionError;
}
/**
 * The execution has succeeded and returned some value or an empty vec encoded in base64.
 */
export interface SuccessValue1 {
  SuccessValue: string;
}
export interface SignedTransactionView {
  actions: ActionView[];
  hash: CryptoHash;
  nonce: number;
  priority_fee?: number;
  public_key: PublicKey;
  receiver_id: AccountId;
  signature: Signature;
  signer_id: AccountId;
  [k: string]: unknown;
}
/**
 * Final execution outcome of the transaction and all of subsequent the receipts. Also includes
 * the generated receipt.
 */
export interface FinalExecutionOutcomeWithReceiptView {
  /**
   * Receipts generated from the transaction
   */
  receipts: ReceiptView[];
  /**
   * The execution outcome of receipts.
   */
  receipts_outcome: ExecutionOutcomeWithIdView[];
  /**
   * Execution status defined by chain.rs:get_final_transaction_result
   * FinalExecutionStatus::NotStarted - the tx is not converted to the receipt yet
   * FinalExecutionStatus::Started - we have at least 1 receipt, but the first leaf receipt_id (using dfs) hasn't finished the execution
   * FinalExecutionStatus::Failure - the result of the first leaf receipt_id
   * FinalExecutionStatus::SuccessValue - the result of the first leaf receipt_id
   */
  status: FinalExecutionStatus;
  /**
   * Signed Transaction
   */
  transaction: SignedTransactionView;
  /**
   * The execution outcome of the signed transaction.
   */
  transaction_outcome: ExecutionOutcomeWithIdView;
  [k: string]: unknown;
}
export interface ReceiptView {
  predecessor_id: AccountId;
  priority?: number;
  receipt: ReceiptEnumView;
  receipt_id: CryptoHash;
  receiver_id: AccountId;
  [k: string]: unknown;
}
export interface Action {
  Action: {
    actions: ActionView[];
    gas_price: NearToken;
    input_data_ids: CryptoHash[];
    is_promise_yield?: boolean;
    output_data_receivers: DataReceiverView[];
    refund_to?: AccountId | null;
    signer_id: AccountId;
    signer_public_key: PublicKey;
    [k: string]: unknown;
  };
}
export interface Data {
  Data: {
    data?: string | null;
    data_id: CryptoHash;
    is_promise_resume?: boolean;
    [k: string]: unknown;
  };
}
export interface GlobalContractDistribution {
  GlobalContractDistribution: {
    already_delivered_shards: ShardId[];
    code: string;
    id: GlobalContractIdentifier;
    target_shard: ShardId;
    [k: string]: unknown;
  };
}
/**
 * Configuration for garbage collection.
 */
export interface GCConfig {
  /**
   * Maximum number of blocks to garbage collect at every garbage collection
   * call.
   */
  gc_blocks_limit?: number;
  /**
   * Maximum number of height to go through at each garbage collection step
   * when cleaning forks during garbage collection.
   */
  gc_fork_clean_step?: number;
  /**
   * Number of epochs for which we keep store data.
   */
  gc_num_epochs_to_keep?: number;
  /**
   * How often gc should be run
   */
  gc_step_period?: DurationAsStdSchemaProvider;
  [k: string]: unknown;
}
export interface GasKeyView {
  balance: NearToken;
  num_nonces: number;
  permission: AccessKeyPermissionView;
  [k: string]: unknown;
}
export interface GenesisConfig {
  /**
   * Expected number of hidden validators per shard.
   */
  avg_hidden_validator_seats_per_shard: number[];
  /**
   * Threshold for kicking out block producers, between 0 and 100.
   */
  block_producer_kickout_threshold: number;
  /**
   * ID of the blockchain. This must be unique for every blockchain.
   * If your testnet blockchains do not have unique chain IDs, you will have a bad time.
   */
  chain_id: string;
  /**
   * Limits the number of shard changes in chunk producer assignments,
   * if algorithm is able to choose assignment with better balance of
   * number of chunk producers for shards.
   */
  chunk_producer_assignment_changes_limit?: number;
  /**
   * Threshold for kicking out chunk producers, between 0 and 100.
   */
  chunk_producer_kickout_threshold: number;
  /**
   * Threshold for kicking out nodes which are only chunk validators, between 0 and 100.
   */
  chunk_validator_only_kickout_threshold?: number;
  /**
   * Enable dynamic re-sharding.
   */
  dynamic_resharding: boolean;
  /**
   * Epoch length counted in block heights.
   */
  epoch_length: number;
  /**
   * Fishermen stake threshold.
   */
  fishermen_threshold: NearToken;
  /**
   * Initial gas limit.
   */
  gas_limit: NearGas;
  /**
   * Gas price adjustment rate
   *
   * @minItems 2
   * @maxItems 2
   */
  gas_price_adjustment_rate: [number, number];
  /**
   * Height of genesis block.
   */
  genesis_height: number;
  /**
   * Official time of blockchain start.
   */
  genesis_time: string;
  max_gas_price: NearToken;
  /**
   * Maximum inflation on the total supply every epoch.
   *
   * @minItems 2
   * @maxItems 2
   */
  max_inflation_rate: [number, number];
  /**
   * Max stake percentage of the validators we will kick out.
   */
  max_kickout_stake_perc?: number;
  /**
   * Minimum gas price. It is also the initial gas price.
   */
  min_gas_price: NearToken;
  /**
   * The minimum stake required for staking is last seat price divided by this number.
   */
  minimum_stake_divisor?: number;
  /**
   * The lowest ratio s/s_total any block producer can have.
   * See <https://github.com/near/NEPs/pull/167> for details
   *
   * @minItems 2
   * @maxItems 2
   */
  minimum_stake_ratio?: [number, number];
  /**
   * The minimum number of validators each shard must have
   */
  minimum_validators_per_shard?: number;
  /**
   * Number of block producer seats at genesis.
   */
  num_block_producer_seats: number;
  /**
   * Defines number of shards and number of block producer seats per each shard at genesis.
   * Note: not used with protocol_feature_chunk_only_producers -- replaced by minimum_validators_per_shard
   * Note: not used before as all block producers produce chunks for all shards
   */
  num_block_producer_seats_per_shard: number[];
  /**
   * Expected number of blocks per year
   */
  num_blocks_per_year: number;
  /**
   * Deprecated.
   */
  num_chunk_only_producer_seats?: number;
  /**
   * Number of chunk producers.
   * Don't mess it up with chunk-only producers feature which is deprecated.
   */
  num_chunk_producer_seats?: number;
  num_chunk_validator_seats?: number;
  /**
   * Online maximum threshold above which validator gets full reward.
   *
   * @minItems 2
   * @maxItems 2
   */
  online_max_threshold?: [number, number];
  /**
   * Online minimum threshold below which validator doesn't receive reward.
   *
   * @minItems 2
   * @maxItems 2
   */
  online_min_threshold?: [number, number];
  /**
   * Protocol treasury rate
   *
   * @minItems 2
   * @maxItems 2
   */
  protocol_reward_rate: [number, number];
  /**
   * Protocol treasury account
   */
  protocol_treasury_account: AccountId;
  /**
   * Threshold of stake that needs to indicate that they ready for upgrade.
   *
   * @minItems 2
   * @maxItems 2
   */
  protocol_upgrade_stake_threshold?: [number, number];
  /**
   * Protocol version that this genesis works with.
   */
  protocol_version: number;
  /**
   * Layout information regarding how to split accounts to shards
   */
  shard_layout?: ShardLayout;
  /**
   * If true, shuffle the chunk producers across shards. In other words, if
   * the shard assignments were `[S_0, S_1, S_2, S_3]` where `S_i` represents
   * the set of chunk producers for shard `i`, if this flag were true, the
   * shard assignments might become, for example, `[S_2, S_0, S_3, S_1]`.
   */
  shuffle_shard_assignment_for_chunk_producers?: boolean;
  /**
   * Number of target chunk validator mandates for each shard.
   */
  target_validator_mandates_per_shard?: number;
  /**
   * Total supply of tokens at genesis.
   */
  total_supply: NearToken;
  /**
   * Number of blocks for which a given transaction is valid
   */
  transaction_validity_period: number;
  /**
   * This is only for test purposes. We hard code some configs for mainnet and testnet
   * in AllEpochConfig, and we want to have a way to test that code path. This flag is for that.
   * If set to true, the node will use the same config override path as mainnet and testnet.
   */
  use_production_config?: boolean;
  /**
   * List of initial validators.
   */
  validators: AccountInfo[];
  [k: string]: unknown;
}
export interface V0 {
  V0: ShardLayoutV0;
}
/**
 * A shard layout that maps accounts evenly across all shards -- by calculate the hash of account
 * id and mod number of shards. This is added to capture the old `account_id_to_shard_id` algorithm,
 * to keep backward compatibility for some existing tests.
 * `parent_shards` for `ShardLayoutV1` is always `None`, meaning it can only be the first shard layout
 * a chain uses.
 */
export interface ShardLayoutV0 {
  /**
   * Map accounts evenly across all shards
   */
  num_shards: number;
  /**
   * Version of the shard layout, this is useful for uniquely identify the shard layout
   */
  version: number;
  [k: string]: unknown;
}
export interface V13 {
  V1: ShardLayoutV1;
}
export interface ShardLayoutV1 {
  /**
   * The boundary accounts are the accounts on boundaries between shards.
   * Each shard contains a range of accounts from one boundary account to
   * another - or the smallest or largest account possible. The total
   * number of shards is equal to the number of boundary accounts plus 1.
   */
  boundary_accounts: AccountId[];
  /**
   * Maps shards from the last shard layout to shards that it splits to in this shard layout,
   * Useful for constructing states for the shards.
   * None for the genesis shard layout
   */
  shards_split_map?: ShardId[][] | null;
  /**
   * Maps shard in this shard layout to their parent shard
   * Since shard_ids always range from 0 to num_shards - 1, we use vec instead of a hashmap
   */
  to_parent_shard_map?: ShardId[] | null;
  /**
   * Version of the shard layout, this is useful for uniquely identify the shard layout
   */
  version: number;
  [k: string]: unknown;
}
export interface V2 {
  V2: ShardLayoutV2;
}
/**
 * Counterpart to `ShardLayoutV2` composed of maps with string keys to aid
 * serde serialization.
 */
export interface ShardLayoutV2 {
  boundary_accounts: AccountId[];
  id_to_index_map: {
    [k: string]: number;
  };
  index_to_id_map: {
    [k: string]: ShardId;
  };
  shard_ids: ShardId[];
  shards_parent_map?: {
    [k: string]: ShardId;
  } | null;
  shards_split_map?: {
    [k: string]: ShardId[];
  } | null;
  version: number;
  [k: string]: unknown;
}
export interface GenesisConfigRequest {
  [k: string]: unknown;
}
export interface LightClientBlockLiteView {
  inner_lite: BlockHeaderInnerLiteView;
  inner_rest_hash: CryptoHash;
  prev_block_hash: CryptoHash;
  [k: string]: unknown;
}
/**
 * Describes limits for VM and Runtime.
 * TODO #4139: consider switching to strongly-typed wrappers instead of raw quantities
 */
export interface LimitConfig {
  /**
   * Whether to enforce account_id well-formed-ness where it wasn't enforced
   * historically.
   */
  account_id_validity_rules_version?: AccountIdValidityRulesVersion;
  /**
   * The initial number of memory pages.
   * NOTE: It's not a limiter itself, but it's a value we use for initial_memory_pages.
   */
  initial_memory_pages: number;
  /**
   * Max number of actions per receipt.
   */
  max_actions_per_receipt: number;
  /**
   * Max length of arguments in a function call action.
   */
  max_arguments_length: number;
  /**
   * Max contract size
   */
  max_contract_size: number;
  /**
   * If present, stores max number of elements in a single contract's table
   */
  max_elements_per_contract_table?: number | null;
  /**
   * If present, stores max number of functions in one contract
   */
  max_functions_number_per_contract?: number | null;
  /**
   * Max amount of gas that can be used, excluding gas attached to promises.
   */
  max_gas_burnt: NearGas;
  /**
   * Max length of any method name (without terminating character).
   */
  max_length_method_name: number;
  /**
   * Max length of returned data
   */
  max_length_returned_data: number;
  /**
   * Max storage key size
   */
  max_length_storage_key: number;
  /**
   * Max storage value size
   */
  max_length_storage_value: number;
  /**
   * If present, stores max number of locals declared globally in one contract
   */
  max_locals_per_contract?: number | null;
  /**
   * What is the maximal memory pages amount is allowed to have for a contract.
   */
  max_memory_pages: number;
  /**
   * Max total length of all method names (including terminating character) for a function call
   * permission access key.
   */
  max_number_bytes_method_names: number;
  /**
   * Max number of input data dependencies
   */
  max_number_input_data_dependencies: number;
  /**
   * Maximum number of log entries.
   */
  max_number_logs: number;
  /**
   * Maximum number of registers that can be used simultaneously.
   *
   * Note that due to an implementation quirk [read: a bug] in VMLogic, if we
   * have this number of registers, no subsequent writes to the registers
   * will succeed even if they replace an existing register.
   */
  max_number_registers: number;
  /**
   * Max number of promises that a function call can create
   */
  max_promises_per_function_call_action: number;
  /**
   * Max receipt size
   */
  max_receipt_size: number;
  /**
   * Maximum number of bytes that can be stored in a single register.
   */
  max_register_size: number;
  /**
   * How tall the stack is allowed to grow?
   *
   * See <https://wiki.parity.io/WebAssembly-StackHeight> to find out how the stack frame cost
   * is calculated.
   */
  max_stack_height: number;
  /**
   * If present, stores max number of tables declared globally in one contract
   */
  max_tables_per_contract?: number | null;
  /**
   * Maximum total length in bytes of all log messages.
   */
  max_total_log_length: number;
  /**
   * Max total prepaid gas for all function call actions per receipt.
   */
  max_total_prepaid_gas: NearGas;
  /**
   * Max transaction size
   */
  max_transaction_size: number;
  /**
   * Maximum number of bytes for payload passed over a yield resume.
   */
  max_yield_payload_size: number;
  /**
   * Hard limit on the size of storage proof generated while executing a single receipt.
   */
  per_receipt_storage_proof_size_limit: number;
  /**
   * Limit of memory used by registers.
   */
  registers_memory_limit: number;
  /**
   * Number of blocks after which a yielded promise times out.
   */
  yield_timeout_length_in_blocks: number;
  [k: string]: unknown;
}
export interface NextEpochValidatorInfo {
  account_id: AccountId;
  public_key: PublicKey;
  shards: ShardId[];
  stake: NearToken;
  [k: string]: unknown;
}
export interface BlockId1 {
  block_id: BlockId;
  [k: string]: unknown;
}
export interface Finality1 {
  finality: Finality;
  [k: string]: unknown;
}
export interface SyncCheckpoint {
  sync_checkpoint: SyncCheckpoint1;
  [k: string]: unknown;
}
export interface RpcBlockResponse {
  /**
   * The AccountId of the author of the Block
   */
  author: AccountId;
  chunks: ChunkHeaderView[];
  header: BlockHeaderView;
  [k: string]: unknown;
}
export interface BlockShardId {
  block_id: BlockId;
  shard_id: ShardId;
  [k: string]: unknown;
}
export interface ChunkHash {
  chunk_id: CryptoHash;
  [k: string]: unknown;
}
export interface RpcChunkResponse {
  author: AccountId;
  header: ChunkHeaderView;
  receipts: ReceiptView[];
  transactions: SignedTransactionView[];
  [k: string]: unknown;
}
export interface RpcClientConfigRequest {
  [k: string]: unknown;
}
/**
 * ClientConfig where some fields can be updated at runtime.
 */
export interface RpcClientConfigResponse {
  /**
   * Not clear old data, set `true` for archive nodes.
   */
  archive: boolean;
  /**
   * Horizon at which instead of fetching block, fetch full state.
   */
  block_fetch_horizon: number;
  /**
   * Behind this horizon header fetch kicks in.
   */
  block_header_fetch_horizon: number;
  /**
   * Duration to check for producing / skipping block.
   *
   * @minItems 2
   * @maxItems 2
   */
  block_production_tracking_delay: [number, number];
  /**
   * Time between check to perform catchup.
   *
   * @minItems 2
   * @maxItems 2
   */
  catchup_step_period: [number, number];
  /**
   * Chain id for status.
   */
  chain_id: string;
  /**
   * Optional config for the Chunk Distribution Network feature.
   * If set to `None` then this node does not participate in the Chunk Distribution Network.
   * Nodes not participating will still function fine, but possibly with higher
   * latency due to the need of requesting chunks over the peer-to-peer network.
   */
  chunk_distribution_network?: ChunkDistributionNetworkConfig | null;
  /**
   * Time between checking to re-request chunks.
   *
   * @minItems 2
   * @maxItems 2
   */
  chunk_request_retry_period: [number, number];
  /**
   * Number of threads for ChunkValidationActor pool.
   */
  chunk_validation_threads: number;
  /**
   * Multiplier for the wait time for all chunks to be received.
   *
   * @minItems 2
   * @maxItems 2
   */
  chunk_wait_mult: [number, number];
  /**
   * Number of threads to execute background migration work in client.
   */
  client_background_migration_threads: number;
  /**
   * Configuration for a cloud-based archival writer. If this config is present, the writer is enabled and
   * writes chunk-related data based on the tracked shards.
   */
  cloud_archival_writer?: CloudArchivalWriterConfig | null;
  /**
   * Time between running doomslug timer.
   *
   * @minItems 2
   * @maxItems 2
   */
  doomslug_step_period: [number, number];
  /**
   * If true, the runtime will do a dynamic resharding 'dry run' at the last block of each epoch.
   * This means calculating tentative boundary accounts for splitting the tracked shards.
   */
  dynamic_resharding_dry_run: boolean;
  /**
   * If true, transactions for the next chunk will be prepared early, right after the previous chunk's
   * post-state is ready. This can help produce chunks faster, for high-throughput chains.
   * The current implementation increases latency on low-load chains, which will be fixed in the future.
   * The default is disabled.
   */
  enable_early_prepare_transactions: boolean;
  enable_multiline_logging: boolean;
  /**
   * Re-export storage layer statistics as prometheus metrics.
   */
  enable_statistics_export: boolean;
  /**
   * Epoch length.
   */
  epoch_length: number;
  /**
   * Options for epoch sync.
   */
  epoch_sync: EpochSyncConfig;
  /**
   * Graceful shutdown at expected block height.
   */
  expected_shutdown: MutableConfigValue;
  /**
   * Garbage collection configuration.
   */
  gc: GCConfig;
  /**
   * Expected increase of header head height per second during header sync
   */
  header_sync_expected_height_per_second: number;
  /**
   * How much time to wait after initial header sync
   *
   * @minItems 2
   * @maxItems 2
   */
  header_sync_initial_timeout: [number, number];
  /**
   * How much time to wait after some progress is made in header sync
   *
   * @minItems 2
   * @maxItems 2
   */
  header_sync_progress_timeout: [number, number];
  /**
   * How much time to wait before banning a peer in header sync if sync is too slow
   *
   * @minItems 2
   * @maxItems 2
   */
  header_sync_stall_ban_timeout: [number, number];
  /**
   * Period between logging summary information.
   *
   * @minItems 2
   * @maxItems 2
   */
  log_summary_period: [number, number];
  /**
   * Enable coloring of the logs
   */
  log_summary_style: LogSummaryStyle;
  /**
   * Maximum wait for approvals before producing block.
   *
   * @minItems 2
   * @maxItems 2
   */
  max_block_production_delay: [number, number];
  /**
   * Maximum duration before skipping given height.
   *
   * @minItems 2
   * @maxItems 2
   */
  max_block_wait_delay: [number, number];
  /**
   * Max burnt gas per view method.  If present, overrides value stored in
   * genesis file.  The value only affects the RPCs without influencing the
   * protocol thus changing it per-node doesn’t affect the blockchain.
   */
  max_gas_burnt_view?: NearGas | null;
  /**
   * Minimum duration before producing block.
   *
   * @minItems 2
   * @maxItems 2
   */
  min_block_production_delay: [number, number];
  /**
   * Minimum number of peers to start syncing.
   */
  min_num_peers: number;
  /**
   * Number of block producer seats
   */
  num_block_producer_seats: number;
  /**
   * Maximum size of state witnesses in the OrphanStateWitnessPool.
   *
   * We keep only orphan witnesses which are smaller than this size.
   * This limits the maximum memory usage of OrphanStateWitnessPool.
   */
  orphan_state_witness_max_size: number;
  /**
   * OrphanStateWitnessPool keeps instances of ChunkStateWitness which can't be processed
   * because the previous block isn't available. The witnesses wait in the pool until the
   * required block appears. This variable controls how many witnesses can be stored in the pool.
   */
  orphan_state_witness_pool_size: number;
  /**
   * Limit the time of adding transactions to a chunk.
   * A node produces a chunk by adding transactions from the transaction pool until
   * some limit is reached. This time limit ensures that adding transactions won't take
   * longer than the specified duration, which helps to produce the chunk quickly.
   */
  produce_chunk_add_transactions_time_limit: string;
  /**
   * Produce empty blocks, use `false` for testing.
   */
  produce_empty_blocks: boolean;
  /**
   * Determines whether client should exit if the protocol version is not supported
   * for the next or next next epoch.
   */
  protocol_version_check: ProtocolVersionCheckConfig;
  resharding_config: MutableConfigValue;
  /**
   * Listening rpc port for status.
   */
  rpc_addr?: string | null;
  /**
   * Save observed instances of invalid ChunkStateWitness to the database in DBCol::InvalidChunkStateWitnesses.
   * Saving invalid witnesses is useful for analysis and debugging.
   * This option can cause extra load on the database and is not recommended for production use.
   */
  save_invalid_witnesses: boolean;
  /**
   * Save observed instances of ChunkStateWitness to the database in DBCol::LatestChunkStateWitnesses.
   * Saving the latest witnesses is useful for analysis and debugging.
   * This option can cause extra load on the database and is not recommended for production use.
   */
  save_latest_witnesses: boolean;
  /**
   * save_trie_changes should be set to true iff
   * - archive if false - non-archival nodes need trie changes to perform garbage collection
   * - archive is true, cold_store is configured and migration to split_storage is finished - node
   * working in split storage mode needs trie changes in order to do garbage collection on hot.
   */
  save_trie_changes: boolean;
  /**
   * Whether to persist transaction outcomes to disk or not.
   */
  save_tx_outcomes: boolean;
  /**
   * Whether to persist partial chunk parts for untracked shards or not.
   */
  save_untracked_partial_chunks_parts: boolean;
  /**
   * Skip waiting for sync (for testing or single node testnet).
   */
  skip_sync_wait: boolean;
  /**
   * Number of threads for StateRequestActor pool.
   */
  state_request_server_threads: number;
  /**
   * Number of seconds between state requests for view client.
   * Throttling window for state requests (headers and parts).
   *
   * @minItems 2
   * @maxItems 2
   */
  state_request_throttle_period: [number, number];
  /**
   * Maximum number of state requests served per throttle period
   */
  state_requests_per_throttle_period: number;
  /**
   * Options for syncing state.
   */
  state_sync: StateSyncConfig;
  /**
   * Whether to use the State Sync mechanism.
   * If disabled, the node will do Block Sync instead of State Sync.
   */
  state_sync_enabled: boolean;
  /**
   * Additional waiting period after a failed request to external storage
   *
   * @minItems 2
   * @maxItems 2
   */
  state_sync_external_backoff: [number, number];
  /**
   * How long to wait for a response from centralized state sync
   *
   * @minItems 2
   * @maxItems 2
   */
  state_sync_external_timeout: [number, number];
  /**
   * How long to wait for a response from p2p state sync
   *
   * @minItems 2
   * @maxItems 2
   */
  state_sync_p2p_timeout: [number, number];
  /**
   * How long to wait after a failed state sync request
   *
   * @minItems 2
   * @maxItems 2
   */
  state_sync_retry_backoff: [number, number];
  /**
   * How often to check that we are not out of sync.
   *
   * @minItems 2
   * @maxItems 2
   */
  sync_check_period: [number, number];
  /**
   * Sync height threshold: below this difference in height don't start syncing.
   */
  sync_height_threshold: number;
  /**
   * Maximum number of block requests to send to peers to sync
   */
  sync_max_block_requests: number;
  /**
   * While syncing, how long to check for each step.
   *
   * @minItems 2
   * @maxItems 2
   */
  sync_step_period: [number, number];
  tracked_shards_config: TrackedShardsConfig;
  /**
   * Limit of the size of per-shard transaction pool measured in bytes. If not set, the size
   * will be unbounded.
   */
  transaction_pool_size_limit?: number | null;
  transaction_request_handler_threads: number;
  /**
   * Upper bound of the byte size of contract state that is still viewable. None is no limit
   */
  trie_viewer_state_size_limit?: number | null;
  /**
   * Time to persist Accounts Id in the router without removing them.
   *
   * @minItems 2
   * @maxItems 2
   */
  ttl_account_id_router: [number, number];
  /**
   * If the node is not a chunk producer within that many blocks, then route
   * to upcoming chunk producers.
   */
  tx_routing_height_horizon: number;
  /**
   * Version of the binary.
   */
  version: Version;
  /**
   * Number of threads for ViewClientActor pool.
   */
  view_client_threads: number;
  [k: string]: unknown;
}
export interface StateSyncConfig {
  concurrency?: SyncConcurrency;
  /**
   * `none` value disables state dump to external storage.
   */
  dump?: DumpConfig | null;
  /**
   * Zstd compression level for state parts.
   */
  parts_compression_lvl?: number;
  sync?: SyncConfig;
  [k: string]: unknown;
}
export interface SyncConcurrency {
  /**
   * Maximum number of "apply parts" tasks that can be performed in parallel.
   * This is a very disk-heavy task and therefore we set this to a low limit,
   * or else the rocksdb contention makes the whole server freeze up.
   */
  apply: number;
  /**
   * Maximum number of "apply parts" tasks that can be performed in parallel
   * during catchup. We set this to a very low value to avoid overloading the
   * node while it is still performing normal tasks.
   */
  apply_during_catchup: number;
  /**
   * Maximum number of outstanding requests for decentralized state sync.
   */
  peer_downloads: number;
  /**
   * The maximum parallelism to use per shard. This is mostly for fairness, because
   * the actual rate limiting is done by the TaskTrackers, but this is useful for
   * balancing the shards a little.
   */
  per_shard: number;
  [k: string]: unknown;
}
/**
 * Expects parts to be available in external storage.
 *
 * Usually as a fallback after some number of attempts to use peers.
 */
export interface ExternalStorage {
  ExternalStorage: ExternalStorageConfig;
}
/**
 * Tracks arbitrary shards.
 */
export interface Shards {
  Shards: ShardUId[];
}
/**
 * `ShardUId` is a unique representation for shards from different shard layouts.
 *
 * Comparing to `ShardId`, which is just an ordinal number ranging from 0 to NUM_SHARDS-1,
 * `ShardUId` provides a way to unique identify shards when shard layouts may change across epochs.
 * This is important because we store states indexed by shards in our database, so we need a
 * way to unique identify shard even when shards change across epochs.
 * Another difference between `ShardUId` and `ShardId` is that `ShardUId` should only exist in
 * a node's internal state while `ShardId` can be exposed to outside APIs and used in protocol
 * level information (for example, `ShardChunkHeader` contains `ShardId` instead of `ShardUId`)
 */
export interface ShardUId {
  shard_id: number;
  version: number;
  [k: string]: unknown;
}
/**
 * Tracks shards that are assigned to given validator account.
 */
export interface ShadowValidator {
  ShadowValidator: AccountId;
}
/**
 * Rotate between these sets of tracked shards.
 * Used to simulate the behavior of chunk only producers without staking tokens.
 */
export interface Schedule {
  Schedule: ShardId[][];
}
/**
 * Tracks shards that contain one of the given account.
 */
export interface Accounts {
  Accounts: AccountId[];
}
/**
 * Data structure for semver version and github tag or commit.
 */
export interface Version {
  build: string;
  commit: string;
  rustc_version?: string;
  version: string;
  [k: string]: unknown;
}
export interface BlockShardId1 {
  block_id: BlockId;
  shard_id: ShardId;
  [k: string]: unknown;
}
export interface ChunkHash1 {
  chunk_id: CryptoHash;
  [k: string]: unknown;
}
export interface RpcCongestionLevelResponse {
  congestion_level: number;
  [k: string]: unknown;
}
export interface RpcGasPriceRequest {
  block_id?: BlockId | null;
  [k: string]: unknown;
}
export interface RpcGasPriceResponse {
  gas_price: NearToken;
  [k: string]: unknown;
}
export interface RpcHealthRequest {
  [k: string]: unknown;
}
export interface RpcKnownProducer {
  account_id: AccountId;
  addr?: string | null;
  peer_id: PeerId;
  [k: string]: unknown;
}
export interface RpcLightClientBlockProofRequest {
  block_hash: CryptoHash;
  light_client_head: CryptoHash;
  [k: string]: unknown;
}
export interface RpcLightClientBlockProofResponse {
  block_header_lite: LightClientBlockLiteView;
  block_proof: MerklePathItem[];
  [k: string]: unknown;
}
export interface Transaction {
  light_client_head: CryptoHash;
  sender_id: AccountId;
  transaction_hash: CryptoHash;
  type: "transaction";
  [k: string]: unknown;
}
export interface Receipt {
  light_client_head: CryptoHash;
  receipt_id: CryptoHash;
  receiver_id: AccountId;
  type: "receipt";
  [k: string]: unknown;
}
export interface RpcLightClientExecutionProofResponse {
  block_header_lite: LightClientBlockLiteView;
  block_proof: MerklePathItem[];
  outcome_proof: ExecutionOutcomeWithIdView;
  outcome_root_proof: MerklePathItem[];
  [k: string]: unknown;
}
export interface RpcLightClientNextBlockRequest {
  last_block_hash: CryptoHash;
  [k: string]: unknown;
}
/**
 * A state for the current head of a light client. More info [here](https://nomicon.io/ChainSpec/LightClient).
 */
export interface RpcLightClientNextBlockResponse {
  approvals_after_next?: (Signature | null)[];
  /**
   * Inner part of the block header that gets hashed, split into two parts, one that is sent
   *    to light clients, and the rest
   */
  inner_lite?: BlockHeaderInnerLiteView;
  inner_rest_hash?: CryptoHash;
  next_block_inner_hash?: CryptoHash;
  next_bps?: ValidatorStakeView[] | null;
  prev_block_hash?: CryptoHash;
  [k: string]: unknown;
}
export interface RpcMaintenanceWindowsRequest {
  account_id: AccountId;
  [k: string]: unknown;
}
export interface RpcNetworkInfoRequest {
  [k: string]: unknown;
}
export interface RpcNetworkInfoResponse {
  active_peers: RpcPeerInfo[];
  /**
   * Accounts of known block and chunk producers from routing table.
   */
  known_producers: RpcKnownProducer[];
  num_active_peers: number;
  peer_max_count: number;
  received_bytes_per_sec: number;
  sent_bytes_per_sec: number;
  [k: string]: unknown;
}
export interface RpcPeerInfo {
  account_id?: AccountId | null;
  addr?: string | null;
  id: PeerId;
  [k: string]: unknown;
}
export interface BlockId2 {
  block_id: BlockId;
  [k: string]: unknown;
}
export interface Finality2 {
  finality: Finality;
  [k: string]: unknown;
}
export interface SyncCheckpoint2 {
  sync_checkpoint: SyncCheckpoint1;
  [k: string]: unknown;
}
export interface RpcProtocolConfigResponse {
  /**
   * Expected number of hidden validators per shard.
   */
  avg_hidden_validator_seats_per_shard: number[];
  /**
   * Threshold for kicking out block producers, between 0 and 100.
   */
  block_producer_kickout_threshold: number;
  /**
   * ID of the blockchain. This must be unique for every blockchain.
   * If your testnet blockchains do not have unique chain IDs, you will have a bad time.
   */
  chain_id: string;
  /**
   * Threshold for kicking out chunk producers, between 0 and 100.
   */
  chunk_producer_kickout_threshold: number;
  /**
   * Threshold for kicking out nodes which are only chunk validators, between 0 and 100.
   */
  chunk_validator_only_kickout_threshold: number;
  /**
   * Enable dynamic re-sharding.
   */
  dynamic_resharding: boolean;
  /**
   * Epoch length counted in block heights.
   */
  epoch_length: number;
  /**
   * Fishermen stake threshold.
   */
  fishermen_threshold: NearToken;
  /**
   * Initial gas limit.
   */
  gas_limit: NearGas;
  /**
   * Gas price adjustment rate
   *
   * @minItems 2
   * @maxItems 2
   */
  gas_price_adjustment_rate: [number, number];
  /**
   * Height of genesis block.
   */
  genesis_height: number;
  /**
   * Official time of blockchain start.
   */
  genesis_time: string;
  /**
   * Maximum gas price.
   */
  max_gas_price: NearToken;
  /**
   * Maximum inflation on the total supply every epoch.
   *
   * @minItems 2
   * @maxItems 2
   */
  max_inflation_rate: [number, number];
  /**
   * Max stake percentage of the validators we will kick out.
   */
  max_kickout_stake_perc: number;
  /**
   * Minimum gas price. It is also the initial gas price.
   */
  min_gas_price: NearToken;
  /**
   * The minimum stake required for staking is last seat price divided by this number.
   */
  minimum_stake_divisor: number;
  /**
   * The lowest ratio s/s_total any block producer can have.
   * See <https://github.com/near/NEPs/pull/167> for details
   *
   * @minItems 2
   * @maxItems 2
   */
  minimum_stake_ratio: [number, number];
  /**
   * The minimum number of validators each shard must have
   */
  minimum_validators_per_shard: number;
  /**
   * Number of block producer seats at genesis.
   */
  num_block_producer_seats: number;
  /**
   * Defines number of shards and number of block producer seats per each shard at genesis.
   */
  num_block_producer_seats_per_shard: number[];
  /**
   * Expected number of blocks per year
   */
  num_blocks_per_year: number;
  /**
   * Online maximum threshold above which validator gets full reward.
   *
   * @minItems 2
   * @maxItems 2
   */
  online_max_threshold: [number, number];
  /**
   * Online minimum threshold below which validator doesn't receive reward.
   *
   * @minItems 2
   * @maxItems 2
   */
  online_min_threshold: [number, number];
  /**
   * Protocol treasury rate
   *
   * @minItems 2
   * @maxItems 2
   */
  protocol_reward_rate: [number, number];
  /**
   * Protocol treasury account
   */
  protocol_treasury_account: AccountId;
  /**
   * Threshold of stake that needs to indicate that they ready for upgrade.
   *
   * @minItems 2
   * @maxItems 2
   */
  protocol_upgrade_stake_threshold: [number, number];
  /**
   * Current Protocol Version
   */
  protocol_version: number;
  /**
   * Runtime configuration (mostly economics constants).
   */
  runtime_config: RuntimeConfigView;
  /**
   * Layout information regarding how to split accounts to shards
   */
  shard_layout: ShardLayout;
  /**
   * If true, shuffle the chunk producers across shards. In other words, if
   * the shard assignments were `[S_0, S_1, S_2, S_3]` where `S_i` represents
   * the set of chunk producers for shard `i`, if this flag were true, the
   * shard assignments might become, for example, `[S_2, S_0, S_3, S_1]`.
   */
  shuffle_shard_assignment_for_chunk_producers: boolean;
  /**
   * Number of target chunk validator mandates for each shard.
   */
  target_validator_mandates_per_shard: number;
  /**
   * Number of blocks for which a given transaction is valid
   */
  transaction_validity_period: number;
  [k: string]: unknown;
}
/**
 * View that preserves JSON format of the runtime config.
 */
export interface RuntimeConfigView {
  /**
   * Config that defines rules for account creation.
   */
  account_creation_config: AccountCreationConfigView;
  /**
   * The configuration for congestion control.
   */
  congestion_control_config: CongestionControlConfigView;
  /**
   * Amount of yN per byte required to have on the account.  See
   * <https://nomicon.io/Economics/Economic#state-stake> for details.
   */
  storage_amount_per_byte: NearToken;
  /**
   * Costs of different actions that need to be performed when sending and
   * processing transaction and receipts.
   */
  transaction_costs: RuntimeFeesConfigView;
  /**
   * Config of wasm operations.
   */
  wasm_config: VMConfigView;
  /**
   * Configuration specific to ChunkStateWitness.
   */
  witness_config: WitnessConfigView;
  [k: string]: unknown;
}
/**
 * Describes different fees for the runtime
 */
export interface RuntimeFeesConfigView {
  /**
   * Describes the cost of creating a certain action, `Action`. Includes all variants.
   */
  action_creation_config: ActionCreationConfigView;
  /**
   * Describes the cost of creating an action receipt, `ActionReceipt`, excluding the actual cost
   * of actions.
   * - `send` cost is burned when a receipt is created using `promise_create` or
   *     `promise_batch_create`
   * - `exec` cost is burned when the receipt is being executed.
   */
  action_receipt_creation_config: Fee;
  /**
   * Fraction of the burnt gas to reward to the contract account for execution.
   *
   * @minItems 2
   * @maxItems 2
   */
  burnt_gas_reward: [number, number];
  /**
   * Describes the cost of creating a data receipt, `DataReceipt`.
   */
  data_receipt_creation_config: DataReceiptCreationConfigView;
  /**
   * Pessimistic gas price inflation ratio.
   *
   * @minItems 2
   * @maxItems 2
   */
  pessimistic_gas_price_inflation_ratio: [number, number];
  /**
   * Describes fees for storage.
   */
  storage_usage_config: StorageUsageConfigView;
  [k: string]: unknown;
}
/**
 * Describes cost of storage per block
 */
export interface StorageUsageConfigView {
  /**
   * Number of bytes for an account record, including rounding up for account id.
   */
  num_bytes_account: number;
  /**
   * Additional number of bytes for a k/v record
   */
  num_extra_bytes_record: number;
  [k: string]: unknown;
}
export interface VMConfigView {
  /**
   * See [VMConfig::deterministic_account_ids](crate::vm::Config::deterministic_account_ids).
   */
  deterministic_account_ids: boolean;
  /**
   * See [VMConfig::discard_custom_sections](crate::vm::Config::discard_custom_sections).
   */
  discard_custom_sections: boolean;
  /**
   * See [VMConfig::eth_implicit_accounts](crate::vm::Config::eth_implicit_accounts).
   */
  eth_implicit_accounts: boolean;
  /**
   * Costs for runtime externals
   */
  ext_costs: ExtCostsConfigView;
  /**
   * See [VMConfig::fix_contract_loading_cost](crate::vm::Config::fix_contract_loading_cost).
   */
  fix_contract_loading_cost: boolean;
  /**
   * See [VMConfig::global_contract_host_fns](crate::vm::Config::global_contract_host_fns).
   */
  global_contract_host_fns: boolean;
  /**
   * Gas cost of a growing memory by single page.
   */
  grow_mem_cost: number;
  /**
   * See [VMConfig::implicit_account_creation](crate::vm::Config::implicit_account_creation).
   */
  implicit_account_creation: boolean;
  /**
   * Describes limits for VM and Runtime.
   *
   * TODO: Consider changing this to `VMLimitConfigView` to avoid dependency
   * on runtime.
   */
  limit_config: LimitConfig;
  /**
   * Base gas cost of a linear operation
   */
  linear_op_base_cost: number;
  /**
   * Unit gas cost of a linear operation
   */
  linear_op_unit_cost: number;
  /**
   * See [VMConfig::reftypes_bulk_memory](crate::vm::Config::reftypes_bulk_memory).
   */
  reftypes_bulk_memory: boolean;
  /**
   * Gas cost of a regular operation.
   */
  regular_op_cost: number;
  /**
   * See [VMConfig::saturating_float_to_int](crate::vm::Config::saturating_float_to_int).
   */
  saturating_float_to_int: boolean;
  /**
   * See [VMConfig::storage_get_mode](crate::vm::Config::storage_get_mode).
   */
  storage_get_mode: StorageGetMode;
  /**
   * See [VMConfig::vm_kind](crate::vm::Config::vm_kind).
   */
  vm_kind: VMKind;
  [k: string]: unknown;
}
/**
 * Configuration specific to ChunkStateWitness.
 */
export interface WitnessConfigView {
  /**
   * Maximum size of transactions contained inside ChunkStateWitness.
   *
   * A witness contains transactions from both the previous chunk and the current one.
   * This parameter limits the sum of sizes of transactions from both of those chunks.
   */
  combined_transactions_size_limit: number;
  /**
   * Size limit for storage proof generated while executing receipts in a chunk.
   * After this limit is reached we defer execution of any new receipts.
   */
  main_storage_proof_size_soft_limit: number;
  /**
   * Soft size limit of storage proof used to validate new transactions in ChunkStateWitness.
   */
  new_transactions_validation_state_size_soft_limit: number;
  [k: string]: unknown;
}
export interface BlockIdViewAccount {
  account_id: AccountId;
  block_id: BlockId;
  request_type: "view_account";
  [k: string]: unknown;
}
export interface BlockIdViewCode {
  account_id: AccountId;
  block_id: BlockId;
  request_type: "view_code";
  [k: string]: unknown;
}
export interface BlockIdViewState {
  account_id: AccountId;
  block_id: BlockId;
  include_proof?: boolean;
  prefix_base64: StoreKey;
  request_type: "view_state";
  [k: string]: unknown;
}
export interface BlockIdViewAccessKey {
  account_id: AccountId;
  block_id: BlockId;
  public_key: PublicKey;
  request_type: "view_access_key";
  [k: string]: unknown;
}
export interface BlockIdViewAccessKeyList {
  account_id: AccountId;
  block_id: BlockId;
  request_type: "view_access_key_list";
  [k: string]: unknown;
}
export interface BlockIdCallFunction {
  account_id: AccountId;
  args_base64: FunctionArgs;
  block_id: BlockId;
  method_name: string;
  request_type: "call_function";
  [k: string]: unknown;
}
export interface BlockIdViewGlobalContractCode {
  block_id: BlockId;
  code_hash: CryptoHash;
  request_type: "view_global_contract_code";
  [k: string]: unknown;
}
export interface BlockIdViewGlobalContractCodeByAccountId {
  account_id: AccountId;
  block_id: BlockId;
  request_type: "view_global_contract_code_by_account_id";
  [k: string]: unknown;
}
export interface FinalityViewAccount {
  account_id: AccountId;
  finality: Finality;
  request_type: "view_account";
  [k: string]: unknown;
}
export interface FinalityViewCode {
  account_id: AccountId;
  finality: Finality;
  request_type: "view_code";
  [k: string]: unknown;
}
export interface FinalityViewState {
  account_id: AccountId;
  finality: Finality;
  include_proof?: boolean;
  prefix_base64: StoreKey;
  request_type: "view_state";
  [k: string]: unknown;
}
export interface FinalityViewAccessKey {
  account_id: AccountId;
  finality: Finality;
  public_key: PublicKey;
  request_type: "view_access_key";
  [k: string]: unknown;
}
export interface FinalityViewAccessKeyList {
  account_id: AccountId;
  finality: Finality;
  request_type: "view_access_key_list";
  [k: string]: unknown;
}
export interface FinalityCallFunction {
  account_id: AccountId;
  args_base64: FunctionArgs;
  finality: Finality;
  method_name: string;
  request_type: "call_function";
  [k: string]: unknown;
}
export interface FinalityViewGlobalContractCode {
  code_hash: CryptoHash;
  finality: Finality;
  request_type: "view_global_contract_code";
  [k: string]: unknown;
}
export interface FinalityViewGlobalContractCodeByAccountId {
  account_id: AccountId;
  finality: Finality;
  request_type: "view_global_contract_code_by_account_id";
  [k: string]: unknown;
}
export interface SyncCheckpointViewAccount {
  account_id: AccountId;
  request_type: "view_account";
  sync_checkpoint: SyncCheckpoint1;
  [k: string]: unknown;
}
export interface SyncCheckpointViewCode {
  account_id: AccountId;
  request_type: "view_code";
  sync_checkpoint: SyncCheckpoint1;
  [k: string]: unknown;
}
export interface SyncCheckpointViewState {
  account_id: AccountId;
  include_proof?: boolean;
  prefix_base64: StoreKey;
  request_type: "view_state";
  sync_checkpoint: SyncCheckpoint1;
  [k: string]: unknown;
}
export interface SyncCheckpointViewAccessKey {
  account_id: AccountId;
  public_key: PublicKey;
  request_type: "view_access_key";
  sync_checkpoint: SyncCheckpoint1;
  [k: string]: unknown;
}
export interface SyncCheckpointViewAccessKeyList {
  account_id: AccountId;
  request_type: "view_access_key_list";
  sync_checkpoint: SyncCheckpoint1;
  [k: string]: unknown;
}
export interface SyncCheckpointCallFunction {
  account_id: AccountId;
  args_base64: FunctionArgs;
  method_name: string;
  request_type: "call_function";
  sync_checkpoint: SyncCheckpoint1;
  [k: string]: unknown;
}
export interface SyncCheckpointViewGlobalContractCode {
  code_hash: CryptoHash;
  request_type: "view_global_contract_code";
  sync_checkpoint: SyncCheckpoint1;
  [k: string]: unknown;
}
export interface SyncCheckpointViewGlobalContractCodeByAccountId {
  account_id: AccountId;
  request_type: "view_global_contract_code_by_account_id";
  sync_checkpoint: SyncCheckpoint1;
  [k: string]: unknown;
}
/**
 * Resulting state values for a view state query request
 */
export interface ViewStateResult1 {
  proof?: string[];
  values: StateItem[];
  [k: string]: unknown;
}
/**
 * Item of the state, key and value are serialized in base64 and proof for inclusion of given state item.
 */
export interface StateItem {
  key: StoreKey;
  value: StoreValue;
  [k: string]: unknown;
}
export interface RpcReceiptRequest {
  receipt_id: CryptoHash;
  [k: string]: unknown;
}
export interface RpcReceiptResponse {
  predecessor_id: AccountId;
  priority?: number;
  receipt: ReceiptEnumView;
  receipt_id: CryptoHash;
  receiver_id: AccountId;
  [k: string]: unknown;
}
export interface RpcSendTransactionRequest {
  signed_tx_base64: SignedTransaction;
  wait_until?: TxExecutionStatus & string;
  [k: string]: unknown;
}
export interface RpcSplitStorageInfoRequest {
  [k: string]: unknown;
}
/**
 * Contains the split storage information.
 */
export interface RpcSplitStorageInfoResponse {
  cold_head_height?: number | null;
  final_head_height?: number | null;
  head_height?: number | null;
  hot_db_kind?: string | null;
  [k: string]: unknown;
}
export interface BlockIdAccountChanges {
  account_ids: AccountId[];
  block_id: BlockId;
  changes_type: "account_changes";
  [k: string]: unknown;
}
export interface BlockIdSingleAccessKeyChanges {
  block_id: BlockId;
  changes_type: "single_access_key_changes";
  keys: AccountWithPublicKey[];
  [k: string]: unknown;
}
export interface BlockIdSingleGasKeyChanges {
  block_id: BlockId;
  changes_type: "single_gas_key_changes";
  keys: AccountWithPublicKey[];
  [k: string]: unknown;
}
export interface BlockIdAllAccessKeyChanges {
  account_ids: AccountId[];
  block_id: BlockId;
  changes_type: "all_access_key_changes";
  [k: string]: unknown;
}
export interface BlockIdAllGasKeyChanges {
  account_ids: AccountId[];
  block_id: BlockId;
  changes_type: "all_gas_key_changes";
  [k: string]: unknown;
}
export interface BlockIdContractCodeChanges {
  account_ids: AccountId[];
  block_id: BlockId;
  changes_type: "contract_code_changes";
  [k: string]: unknown;
}
export interface BlockIdDataChanges {
  account_ids: AccountId[];
  block_id: BlockId;
  changes_type: "data_changes";
  key_prefix_base64: StoreKey;
  [k: string]: unknown;
}
export interface FinalityAccountChanges {
  account_ids: AccountId[];
  changes_type: "account_changes";
  finality: Finality;
  [k: string]: unknown;
}
export interface FinalitySingleAccessKeyChanges {
  changes_type: "single_access_key_changes";
  finality: Finality;
  keys: AccountWithPublicKey[];
  [k: string]: unknown;
}
export interface FinalitySingleGasKeyChanges {
  changes_type: "single_gas_key_changes";
  finality: Finality;
  keys: AccountWithPublicKey[];
  [k: string]: unknown;
}
export interface FinalityAllAccessKeyChanges {
  account_ids: AccountId[];
  changes_type: "all_access_key_changes";
  finality: Finality;
  [k: string]: unknown;
}
export interface FinalityAllGasKeyChanges {
  account_ids: AccountId[];
  changes_type: "all_gas_key_changes";
  finality: Finality;
  [k: string]: unknown;
}
export interface FinalityContractCodeChanges {
  account_ids: AccountId[];
  changes_type: "contract_code_changes";
  finality: Finality;
  [k: string]: unknown;
}
export interface FinalityDataChanges {
  account_ids: AccountId[];
  changes_type: "data_changes";
  finality: Finality;
  key_prefix_base64: StoreKey;
  [k: string]: unknown;
}
export interface SyncCheckpointAccountChanges {
  account_ids: AccountId[];
  changes_type: "account_changes";
  sync_checkpoint: SyncCheckpoint1;
  [k: string]: unknown;
}
export interface SyncCheckpointSingleAccessKeyChanges {
  changes_type: "single_access_key_changes";
  keys: AccountWithPublicKey[];
  sync_checkpoint: SyncCheckpoint1;
  [k: string]: unknown;
}
export interface SyncCheckpointSingleGasKeyChanges {
  changes_type: "single_gas_key_changes";
  keys: AccountWithPublicKey[];
  sync_checkpoint: SyncCheckpoint1;
  [k: string]: unknown;
}
export interface SyncCheckpointAllAccessKeyChanges {
  account_ids: AccountId[];
  changes_type: "all_access_key_changes";
  sync_checkpoint: SyncCheckpoint1;
  [k: string]: unknown;
}
export interface SyncCheckpointAllGasKeyChanges {
  account_ids: AccountId[];
  changes_type: "all_gas_key_changes";
  sync_checkpoint: SyncCheckpoint1;
  [k: string]: unknown;
}
export interface SyncCheckpointContractCodeChanges {
  account_ids: AccountId[];
  changes_type: "contract_code_changes";
  sync_checkpoint: SyncCheckpoint1;
  [k: string]: unknown;
}
export interface SyncCheckpointDataChanges {
  account_ids: AccountId[];
  changes_type: "data_changes";
  key_prefix_base64: StoreKey;
  sync_checkpoint: SyncCheckpoint1;
  [k: string]: unknown;
}
export interface RpcStateChangesInBlockByTypeResponse {
  block_hash: CryptoHash;
  changes: StateChangeKindView[];
  [k: string]: unknown;
}
export interface AccountTouched {
  account_id: AccountId;
  type: "account_touched";
  [k: string]: unknown;
}
export interface AccessKeyTouched {
  account_id: AccountId;
  type: "access_key_touched";
  [k: string]: unknown;
}
export interface DataTouched {
  account_id: AccountId;
  type: "data_touched";
  [k: string]: unknown;
}
export interface ContractCodeTouched {
  account_id: AccountId;
  type: "contract_code_touched";
  [k: string]: unknown;
}
export interface BlockId3 {
  block_id: BlockId;
  [k: string]: unknown;
}
export interface Finality3 {
  finality: Finality;
  [k: string]: unknown;
}
export interface SyncCheckpoint3 {
  sync_checkpoint: SyncCheckpoint1;
  [k: string]: unknown;
}
export interface RpcStateChangesInBlockResponse {
  block_hash: CryptoHash;
  changes: StateChangeWithCauseView[];
  [k: string]: unknown;
}
export interface AccountUpdate {
  cause: StateChangeCauseView;
  /**
   * A view of the account
   */
  change: {
    account_id: AccountId;
    amount: NearToken;
    code_hash: CryptoHash;
    global_contract_account_id?: AccountId | null;
    global_contract_hash?: CryptoHash | null;
    locked: NearToken;
    /**
     * TODO(2271): deprecated.
     */
    storage_paid_at?: number;
    storage_usage: number;
    [k: string]: unknown;
  };
  type: "account_update";
  [k: string]: unknown;
}
export interface NotWritableToDisk {
  type: "not_writable_to_disk";
  [k: string]: unknown;
}
export interface InitialState {
  type: "initial_state";
  [k: string]: unknown;
}
export interface TransactionProcessing {
  tx_hash: CryptoHash;
  type: "transaction_processing";
  [k: string]: unknown;
}
export interface ActionReceiptProcessingStarted {
  receipt_hash: CryptoHash;
  type: "action_receipt_processing_started";
  [k: string]: unknown;
}
export interface ActionReceiptGasReward {
  receipt_hash: CryptoHash;
  type: "action_receipt_gas_reward";
  [k: string]: unknown;
}
export interface ReceiptProcessing {
  receipt_hash: CryptoHash;
  type: "receipt_processing";
  [k: string]: unknown;
}
export interface PostponedReceipt {
  receipt_hash: CryptoHash;
  type: "postponed_receipt";
  [k: string]: unknown;
}
export interface UpdatedDelayedReceipts {
  type: "updated_delayed_receipts";
  [k: string]: unknown;
}
export interface ValidatorAccountsUpdate {
  type: "validator_accounts_update";
  [k: string]: unknown;
}
export interface Migration {
  type: "migration";
  [k: string]: unknown;
}
export interface BandwidthSchedulerStateUpdate {
  type: "bandwidth_scheduler_state_update";
  [k: string]: unknown;
}
export interface AccountDeletion {
  cause: StateChangeCauseView;
  change: {
    account_id: AccountId;
    [k: string]: unknown;
  };
  type: "account_deletion";
  [k: string]: unknown;
}
export interface AccessKeyUpdate {
  cause: StateChangeCauseView;
  change: {
    access_key: AccessKeyView;
    account_id: AccountId;
    public_key: PublicKey;
    [k: string]: unknown;
  };
  type: "access_key_update";
  [k: string]: unknown;
}
export interface AccessKeyDeletion {
  cause: StateChangeCauseView;
  change: {
    account_id: AccountId;
    public_key: PublicKey;
    [k: string]: unknown;
  };
  type: "access_key_deletion";
  [k: string]: unknown;
}
export interface GasKeyUpdate {
  cause: StateChangeCauseView;
  change: {
    account_id: AccountId;
    gas_key: GasKeyView;
    public_key: PublicKey;
    [k: string]: unknown;
  };
  type: "gas_key_update";
  [k: string]: unknown;
}
export interface GasKeyNonceUpdate {
  cause: StateChangeCauseView;
  change: {
    account_id: AccountId;
    index: number;
    nonce: number;
    public_key: PublicKey;
    [k: string]: unknown;
  };
  type: "gas_key_nonce_update";
  [k: string]: unknown;
}
export interface GasKeyDeletion {
  cause: StateChangeCauseView;
  change: {
    account_id: AccountId;
    public_key: PublicKey;
    [k: string]: unknown;
  };
  type: "gas_key_deletion";
  [k: string]: unknown;
}
export interface DataUpdate {
  cause: StateChangeCauseView;
  change: {
    account_id: AccountId;
    key_base64: StoreKey;
    value_base64: StoreValue;
    [k: string]: unknown;
  };
  type: "data_update";
  [k: string]: unknown;
}
export interface DataDeletion {
  cause: StateChangeCauseView;
  change: {
    account_id: AccountId;
    key_base64: StoreKey;
    [k: string]: unknown;
  };
  type: "data_deletion";
  [k: string]: unknown;
}
export interface ContractCodeUpdate {
  cause: StateChangeCauseView;
  change: {
    account_id: AccountId;
    code_base64: string;
    [k: string]: unknown;
  };
  type: "contract_code_update";
  [k: string]: unknown;
}
export interface ContractCodeDeletion {
  cause: StateChangeCauseView;
  change: {
    account_id: AccountId;
    [k: string]: unknown;
  };
  type: "contract_code_deletion";
  [k: string]: unknown;
}
export interface RpcStatusRequest {
  [k: string]: unknown;
}
export interface RpcStatusResponse {
  /**
   * Unique chain id.
   */
  chain_id: string;
  /**
   * Information about last blocks, network, epoch and chain & chunk info.
   */
  detailed_debug_status?: DetailedDebugStatus | null;
  /**
   * Genesis hash of the chain.
   */
  genesis_hash: CryptoHash;
  /**
   * Latest protocol version that this client supports.
   */
  latest_protocol_version: number;
  /**
   * Deprecated; same as `validator_public_key` which you should use instead.
   */
  node_key?: PublicKey | null;
  /**
   * Public key of the node.
   */
  node_public_key: PublicKey;
  /**
   * Currently active protocol version.
   */
  protocol_version: number;
  /**
   * Address for RPC server.  None if node doesn't have RPC endpoint enabled.
   */
  rpc_addr?: string | null;
  /**
   * Sync status of the node.
   */
  sync_info: StatusSyncInfo;
  /**
   * Uptime of the node.
   */
  uptime_sec: number;
  /**
   * Validator id of the node
   */
  validator_account_id?: AccountId | null;
  /**
   * Public key of the validator.
   */
  validator_public_key?: PublicKey | null;
  /**
   * Current epoch validators.
   */
  validators: ValidatorInfo[];
  /**
   * Binary version.
   */
  version: Version;
  [k: string]: unknown;
}
export interface StatusSyncInfo {
  earliest_block_hash?: CryptoHash | null;
  earliest_block_height?: number | null;
  earliest_block_time?: string | null;
  epoch_id?: EpochId | null;
  epoch_start_height?: number | null;
  latest_block_hash: CryptoHash;
  latest_block_height: number;
  latest_block_time: string;
  latest_state_root: CryptoHash;
  syncing: boolean;
  [k: string]: unknown;
}
export interface ValidatorInfo {
  account_id: AccountId;
  [k: string]: unknown;
}
export interface Empty {
  final_execution_status: TxExecutionStatus;
  [k: string]: unknown;
}
export interface EpochId1 {
  epoch_id: EpochId;
  [k: string]: unknown;
}
export interface BlockId4 {
  block_id: BlockId;
  [k: string]: unknown;
}
export interface Latest {
  latest: null;
  [k: string]: unknown;
}
/**
 * Information about this epoch validators and next epoch validators
 */
export interface RpcValidatorResponse {
  /**
   * Fishermen for the current epoch
   */
  current_fishermen: ValidatorStakeView[];
  /**
   * Proposals in the current epoch
   */
  current_proposals: ValidatorStakeView[];
  /**
   * Validators for the current epoch
   */
  current_validators: CurrentEpochValidatorInfo[];
  /**
   * Epoch height
   */
  epoch_height: number;
  /**
   * Epoch start block height
   */
  epoch_start_height: number;
  /**
   * Fishermen for the next epoch
   */
  next_fishermen: ValidatorStakeView[];
  /**
   * Validators for the next epoch
   */
  next_validators: NextEpochValidatorInfo[];
  /**
   * Kickout in the previous epoch
   */
  prev_epoch_kickout: ValidatorKickoutView[];
  [k: string]: unknown;
}
export interface ValidatorKickoutView {
  account_id: AccountId;
  reason: ValidatorKickoutReason;
  [k: string]: unknown;
}
/**
 * Validator didn't produce enough blocks.
 */
export interface NotEnoughBlocks {
  NotEnoughBlocks: {
    expected: number;
    produced: number;
    [k: string]: unknown;
  };
}
/**
 * Validator didn't produce enough chunks.
 */
export interface NotEnoughChunks {
  NotEnoughChunks: {
    expected: number;
    produced: number;
    [k: string]: unknown;
  };
}
/**
 * Validator stake is now below threshold
 */
export interface NotEnoughStake {
  NotEnoughStake: {
    stake_u128: NearToken;
    threshold_u128: NearToken;
    [k: string]: unknown;
  };
}
/**
 * Validator didn't produce enough chunk endorsements.
 */
export interface NotEnoughChunkEndorsements {
  NotEnoughChunkEndorsements: {
    expected: number;
    produced: number;
    [k: string]: unknown;
  };
}
/**
 * Validator's last block proposal was for a protocol version older than
 * the network's voted protocol version.
 */
export interface ProtocolVersionTooOld {
  ProtocolVersionTooOld: {
    network_version: number;
    version: number;
    [k: string]: unknown;
  };
}
export interface RpcValidatorsOrderedRequest {
  block_id?: BlockId | null;
  [k: string]: unknown;
}
export interface SignedDelegateAction {
  delegate_action: DelegateAction;
  signature: Signature;
  [k: string]: unknown;
}
